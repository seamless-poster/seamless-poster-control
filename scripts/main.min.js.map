{"version":3,"sources":["main.min.js","/source/main.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/app/scripts/app/device.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/app/scripts/fake_3e9ce187.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/buffer/index.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/process/browser.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/ieee754/index.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/browser-pack/_prelude.js"],"names":["_classCallCheck","instance","Constructor","TypeError","isLocalhost","Boolean","window","location","hostname","match","navigator","protocol","serviceWorker","register","then","registration","onupdatefound","controller","installingWorker","installing","onstatechange","state","Error","e","console","error","_typeof","Symbol","iterator","obj","constructor","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","t","n","r","s","o","u","a","require","f","exports","call","1","module","process","global","Buffer","__argument0","__argument1","__argument2","__argument3","__filename","__dirname","PosterDevice","this","device","onDisconnected","bind","value","_this","log","options","filters","name","optionalServices","bluetooth","requestDevice","addEventListener","gatt","connect","Promise","reject","data","getPrimaryService","service","getCharacteristic","characteristic","writeValue","readValue","disconnect","posterDevice","self","arguments","b55mWE","buffer","2","blue","connectButton","document","getElementById","okButton","request","readData","getValue","./app/device.js","3","lookup","decode","elt","code","charCodeAt","PLUS","PLUS_URL_SAFE","SLASH","SLASH_URL_SAFE","NUMBER","UPPER","LOWER","b64ToByteArray","b64","push","v","arr","L","j","l","tmp","placeHolders","len","charAt","Arr","uint8ToBase64","uint8","encode","num","tripletToBase64","temp","extraBytes","output","Uint8Array","Array","toByteArray","fromByteArray","base64js","4","subject","encoding","noZero","type","stringtrim","coerce","byteLength","buf","_useTypedArrays","_augment","_isBuffer","_set","isArrayish","isBuffer","readUInt8","write","_hexWrite","string","offset","Number","remaining","strLen","assert","byte","parseInt","substr","isNaN","_charsWritten","_utf8Write","charsWritten","blitBuffer","utf8ToBytes","_asciiWrite","asciiToBytes","_binaryWrite","_base64Write","base64ToBytes","_utf16leWrite","utf16leToBytes","_base64Slice","start","end","base64","slice","_utf8Slice","res","Math","min","decodeUtf8Char","String","fromCharCode","toString","_asciiSlice","ret","_binarySlice","_hexSlice","out","toHex","_utf16leSlice","bytes","_readUInt16","littleEndian","noAssert","undefined","val","_readUInt32","_readInt16","neg","_readInt32","_readFloat","ieee754","read","_readDouble","_writeUInt16","verifuint","_writeUInt32","_writeInt16","verifsint","_writeInt32","_writeFloat","verifIEEE754","_writeDouble","str","trim","replace","clamp","index","defaultValue","ceil","isArray","byteArray","b","h","encodeURIComponent","split","c","hi","lo","src","dst","decodeURIComponent","err","max","floor","test","message","SlowBuffer","INSPECT_MAX_BYTES","poolSize","ArrayBuffer","foo","subarray","isEncoding","toLowerCase","concat","list","totalLength","pos","item","copy","isFinite","swap","toJSON","_arr","target_start","source","sliceLen","newBuf","get","set","writeUInt8","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","fill","inspect","join","toArrayBuffer","BP","_get","toLocaleString","base64-js","5","noop","nextTick","canSetImmediate","setImmediate","canPost","postMessage","queue","ev","stopPropagation","fn","shift","setTimeout","title","browser","env","argv","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","6","isLE","mLen","nBytes","m","eLen","eMax","eBias","nBits","d","NaN","Infinity","pow","rt","abs","LN2"],"mappings":"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","file":"main.min.js","sourcesContent":["'use strict'; /*!\n               *\n               *  Web Starter Kit\n               *  Copyright 2015 Google Inc. All rights reserved.\n               *\n               *  Licensed under the Apache License, Version 2.0 (the \"License\");\n               *  you may not use this file except in compliance with the License.\n               *  You may obtain a copy of the License at\n               *\n               *    https://www.apache.org/licenses/LICENSE-2.0\n               *\n               *  Unless required by applicable law or agreed to in writing, software\n               *  distributed under the License is distributed on an \"AS IS\" BASIS,\n               *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n               *  See the License for the specific language governing permissions and\n               *  limitations under the License\n               *\n               */\n/* eslint-env browser */\n(function () {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  var isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.1/8 is considered localhost for IPv4.\n  window.location.hostname.match(\n  /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));\n\n\n\n  if ('serviceWorker' in navigator && (\n  window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js').\n    then(function (registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function () {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {\n          // The updatefound event implies that registration.installing is set:\n          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n          var installingWorker = registration.installing;\n\n          installingWorker.onstatechange = function () {\n            switch (installingWorker.state) {\n              case 'installed':\n                // At this point, the old content will have been purged and the\n                // fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in the page's interface.\n                break;\n\n              case 'redundant':\n                throw new Error('The installing ' +\n                'service worker became redundant.');\n\n              default:\n              // Ignore\n            }\n          };\n        }\n      };\n    }).catch(function (e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uanMiXSwibmFtZXMiOlsiaXNMb2NhbGhvc3QiLCJCb29sZWFuIiwid2luZG93IiwibG9jYXRpb24iLCJob3N0bmFtZSIsIm1hdGNoIiwibmF2aWdhdG9yIiwicHJvdG9jb2wiLCJzZXJ2aWNlV29ya2VyIiwicmVnaXN0ZXIiLCJ0aGVuIiwicmVnaXN0cmF0aW9uIiwib251cGRhdGVmb3VuZCIsImNvbnRyb2xsZXIiLCJpbnN0YWxsaW5nV29ya2VyIiwiaW5zdGFsbGluZyIsIm9uc3RhdGVjaGFuZ2UiLCJzdGF0ZSIsIkVycm9yIiwiY2F0Y2giLCJlIiwiY29uc29sZSIsImVycm9yIl0sIm1hcHBpbmdzIjoiY0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBO0FBQ0EsQ0FBQyxZQUFXO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJQSxjQUFjQyxRQUFRQyxPQUFPQyxRQUFQLENBQWdCQyxRQUFoQixLQUE2QixXQUE3QjtBQUN0QjtBQUNBRixTQUFPQyxRQUFQLENBQWdCQyxRQUFoQixLQUE2QixPQUZQO0FBR3RCO0FBQ0FGLFNBQU9DLFFBQVAsQ0FBZ0JDLFFBQWhCLENBQXlCQyxLQUF6QjtBQUNFLDBEQURGLENBSmMsQ0FBbEI7Ozs7QUFTQSxNQUFJLG1CQUFtQkMsU0FBbkI7QUFDQ0osU0FBT0MsUUFBUCxDQUFnQkksUUFBaEIsS0FBNkIsUUFBN0IsSUFBeUNQLFdBRDFDLENBQUosRUFDNEQ7QUFDMURNLGNBQVVFLGFBQVYsQ0FBd0JDLFFBQXhCLENBQWlDLG1CQUFqQztBQUNDQyxRQURELENBQ00sVUFBU0MsWUFBVCxFQUF1QjtBQUMzQjtBQUNBQSxtQkFBYUMsYUFBYixHQUE2QixZQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSU4sVUFBVUUsYUFBVixDQUF3QkssVUFBNUIsRUFBd0M7QUFDdEM7QUFDQTtBQUNBLGNBQUlDLG1CQUFtQkgsYUFBYUksVUFBcEM7O0FBRUFELDJCQUFpQkUsYUFBakIsR0FBaUMsWUFBVztBQUMxQyxvQkFBUUYsaUJBQWlCRyxLQUF6QjtBQUNFLG1CQUFLLFdBQUw7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVGLG1CQUFLLFdBQUw7QUFDRSxzQkFBTSxJQUFJQyxLQUFKLENBQVU7QUFDQSxrREFEVixDQUFOOztBQUdGO0FBQ0U7QUFiSjtBQWVELFdBaEJEO0FBaUJEO0FBQ0YsT0E1QkQ7QUE2QkQsS0FoQ0QsRUFnQ0dDLEtBaENILENBZ0NTLFVBQVNDLENBQVQsRUFBWTtBQUNuQkMsY0FBUUMsS0FBUixDQUFjLDJDQUFkLEVBQTJERixDQUEzRDtBQUNELEtBbENEO0FBbUNEOztBQUVEO0FBQ0QsQ0F4REQiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICpcbiAqICBXZWIgU3RhcnRlciBLaXRcbiAqICBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlXG4gKlxuICovXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENoZWNrIHRvIG1ha2Ugc3VyZSBzZXJ2aWNlIHdvcmtlcnMgYXJlIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyLFxuICAvLyBhbmQgdGhhdCB0aGUgY3VycmVudCBwYWdlIGlzIGFjY2Vzc2VkIGZyb20gYSBzZWN1cmUgb3JpZ2luLiBVc2luZyBhXG4gIC8vIHNlcnZpY2Ugd29ya2VyIGZyb20gYW4gaW5zZWN1cmUgb3JpZ2luIHdpbGwgdHJpZ2dlciBKUyBjb25zb2xlIGVycm9ycy4gU2VlXG4gIC8vIGh0dHA6Ly93d3cuY2hyb21pdW0ub3JnL0hvbWUvY2hyb21pdW0tc2VjdXJpdHkvcHJlZmVyLXNlY3VyZS1vcmlnaW5zLWZvci1wb3dlcmZ1bC1uZXctZmVhdHVyZXNcbiAgdmFyIGlzTG9jYWxob3N0ID0gQm9vbGVhbih3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnIHx8XG4gICAgICAvLyBbOjoxXSBpcyB0aGUgSVB2NiBsb2NhbGhvc3QgYWRkcmVzcy5cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gJ1s6OjFdJyB8fFxuICAgICAgLy8gMTI3LjAuMC4xLzggaXMgY29uc2lkZXJlZCBsb2NhbGhvc3QgZm9yIElQdjQuXG4gICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUubWF0Y2goXG4gICAgICAgIC9eMTI3KD86XFwuKD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSl7M30kL1xuICAgICAgKVxuICAgICk7XG5cbiAgaWYgKCdzZXJ2aWNlV29ya2VyJyBpbiBuYXZpZ2F0b3IgJiZcbiAgICAgICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonIHx8IGlzTG9jYWxob3N0KSkge1xuICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKCdzZXJ2aWNlLXdvcmtlci5qcycpXG4gICAgLnRoZW4oZnVuY3Rpb24ocmVnaXN0cmF0aW9uKSB7XG4gICAgICAvLyB1cGRhdGVmb3VuZCBpcyBmaXJlZCBpZiBzZXJ2aWNlLXdvcmtlci5qcyBjaGFuZ2VzLlxuICAgICAgcmVnaXN0cmF0aW9uLm9udXBkYXRlZm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gdXBkYXRlZm91bmQgaXMgYWxzbyBmaXJlZCB0aGUgdmVyeSBmaXJzdCB0aW1lIHRoZSBTVyBpcyBpbnN0YWxsZWQsXG4gICAgICAgIC8vIGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gcHJvbXB0IGZvciBhIHJlbG9hZCBhdCB0aGF0IHBvaW50LlxuICAgICAgICAvLyBTbyBjaGVjayBoZXJlIHRvIHNlZSBpZiB0aGUgcGFnZSBpcyBhbHJlYWR5IGNvbnRyb2xsZWQsXG4gICAgICAgIC8vIGkuZS4gd2hldGhlciB0aGVyZSdzIGFuIGV4aXN0aW5nIHNlcnZpY2Ugd29ya2VyLlxuICAgICAgICBpZiAobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xuICAgICAgICAgIC8vIFRoZSB1cGRhdGVmb3VuZCBldmVudCBpbXBsaWVzIHRoYXQgcmVnaXN0cmF0aW9uLmluc3RhbGxpbmcgaXMgc2V0OlxuICAgICAgICAgIC8vIGh0dHBzOi8vc2xpZ2h0bHlvZmYuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvc3BlYy9zZXJ2aWNlX3dvcmtlci9pbmRleC5odG1sI3NlcnZpY2Utd29ya2VyLWNvbnRhaW5lci11cGRhdGVmb3VuZC1ldmVudFxuICAgICAgICAgIHZhciBpbnN0YWxsaW5nV29ya2VyID0gcmVnaXN0cmF0aW9uLmluc3RhbGxpbmc7XG5cbiAgICAgICAgICBpbnN0YWxsaW5nV29ya2VyLm9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5zdGFsbGluZ1dvcmtlci5zdGF0ZSkge1xuICAgICAgICAgICAgICBjYXNlICdpbnN0YWxsZWQnOlxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBvbGQgY29udGVudCB3aWxsIGhhdmUgYmVlbiBwdXJnZWQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGZyZXNoIGNvbnRlbnQgd2lsbCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgIC8vIEl0J3MgdGhlIHBlcmZlY3QgdGltZSB0byBkaXNwbGF5IGEgXCJOZXcgY29udGVudCBpc1xuICAgICAgICAgICAgICAgIC8vIGF2YWlsYWJsZTsgcGxlYXNlIHJlZnJlc2guXCIgbWVzc2FnZSBpbiB0aGUgcGFnZSdzIGludGVyZmFjZS5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdyZWR1bmRhbnQnOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluc3RhbGxpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZXJ2aWNlIHdvcmtlciBiZWNhbWUgcmVkdW5kYW50LicpO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uOicsIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gWW91ciBjdXN0b20gSmF2YVNjcmlwdCBnb2VzIGhlcmVcbn0pKCk7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=\n\n\"use strict\";var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {return typeof obj;} : function (obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;};var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}(function e(t, n, r) {function s(o, u) {if (!n[o]) {if (!t[o]) {var a = typeof require == \"function\" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);throw new Error(\"Cannot find module '\" + o + \"'\");}var f = n[o] = { exports: {} };t[o][0].call(f.exports, function (e) {var n = t[o][1][e];return s(n ? n : e);}, f, f.exports, e, t, n, r);}return n[o].exports;}var i = typeof require == \"function\" && require;for (var o = 0; o < r.length; o++) {s(r[o]);}return s;})({ 1: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {var\n      PosterDevice = function () {\n\n        function PosterDevice() {_classCallCheck(this, PosterDevice);\n          this.device = null;\n          this.onDisconnected = this.onDisconnected.bind(this);\n        }_createClass(PosterDevice, [{ key: \"request\", value: function request()\n\n          {var _this = this;\n            console.log('request');\n            var options = {\n              filters: [{\n                name: 'commService' }],\n\n              optionalServices: [0x12ab] };\n\n            return navigator.bluetooth.requestDevice(options).\n            then(function (device) {\n              _this.device = device;\n              _this.device.addEventListener('gattserverdisconnected', _this.onDisconnected);\n              return device;\n            });\n          } }, { key: \"connect\", value: function connect()\n\n          {\n            console.log('connect');\n            if (this.device) {\n              return this.device.gatt.connect();\n            }\n            return Promise.reject('Device is not connected.');\n          } }, { key: \"writeData\", value: function writeData(\n\n          data) {\n            console.log('writeData');\n            return this.device.gatt.getPrimaryService(0x12ab).\n            then(function (service) {return service.getCharacteristic(0x34cd);}).\n            then(function (characteristic) {return characteristic.writeValue(data);});\n          } }, { key: \"readData\", value: function readData()\n\n          {\n            console.log('readData');\n            return this.device.gatt.getPrimaryService(0x12ab).\n            then(function (service) {return service.getCharacteristic(0x34cd);}).\n            then(function (characteristic) {return characteristic.readValue();});\n          } }, { key: \"disconnect\", value: function disconnect()\n\n          {\n            console.log('disconnect');\n            if (this.device) {\n              return this.device.gatt.disconnect();\n            }\n            return Promise.reject('Device is not connected.');\n          } }, { key: \"onDisconnected\", value: function onDisconnected()\n\n          {\n            console.log('onDisconnected');\n            console.log('Device is disconnected.');\n          } }]);return PosterDevice;}();\n\n\n      var posterDevice = new PosterDevice();\n      module.exports = posterDevice;\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/app/device.js\", \"/app\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }], 2: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      // const BluetoothDevice = require('web-bluetooth');\n      // const stateManager = require('./app/state.js');\n      var posterDevice = require('./app/device.js');\n\n      // const service = '1ecce4f2-7f9e-11e6-ae22-56b6b6499611';\n      var characteristic = '488d7950-7f9e-11e6-ae22-56b6b6499611';\n\n      // const filter = {\n      //   name: 'MyDevice',\n      //   service: [service]\n      // };\n      var blue = void 0;\n\n      var connectButton = document.getElementById('js-connect');\n      // const disconnectButton = document.getElementById('js-disconnect');\n\n      var okButton = document.getElementById('js-ok');\n\n      // connectButton.addEventListener('click', () => {\n      //   connectButton.disabled = true;\n      //   stateManager.change('connecting');\n      //\n      //   blue = new BluetoothDevice(filter);\n      //   blue.connect()\n      //     .then(device => {\n      //       console.log(device);\n      //       stateManager.change('connected');\n      //       connectButton.disabled = false;\n      //     })\n      //     .catch(error => {\n      //       console.log(error);\n      //       stateManager.change('init');\n      //       connectButton.disabled = false;\n      //     });\n      // });\n      //\n      // disconnectButton.addEventListener('click', () => {\n      //   if (blue.disconnect()) {\n      //     stateManager.change('init');\n      //   } else {\n      //     console.log('error while disconnect');\n      //   }\n      // });\n\n      connectButton.addEventListener('click', function () {\n        posterDevice.request().\n        then(function () {return posterDevice.connect();}).\n        then(function () {\n          return posterDevice.readData();\n        }).\n        then(function (data) {\n          console.log(data);\n        }).\n        catch(function (error) {\n          console.log(error);\n        });\n      });\n      // connectButton.addEventListener('click', () => {\n      //   console.log('Requesting Bluetooth Device...');\n      //   navigator.bluetooth.requestDevice({\n      //     filters: [{services: [service]}]\n      //   })\n      //   .then(device => {\n      //     console.log('Connecting to GATT Server...');\n      //     return device.gatt.connect();\n      //   })\n      //   .then(server => {\n      //     console.log('Getting Service...');\n      //     return server.getPrimaryService(service);\n      //   })\n      //   .then(service => {\n      //     console.log('Getting Characteristics...');\n      //     // if (characteristic) {\n      //     //   // Get all characteristics that match this UUID.\n      //     //   return service.getCharacteristics(characteristic);\n      //     // }\n      //     // Get all characteristics.\n      //     return service.getCharacteristic(characteristic);\n      //     // return service.getCharacteristics();\n      //   })\n      //   .then(characteristics => {\n      //     // console.log('> Characteristics: ' +\n      //     //   characteristics.map(c => c.uuid).join('\\n' + ' '.repeat(19)));\n      //\n      //     return characteristics[0].readValue();\n      //   })\n      //   .then(value => {\n      //     console.log('Battery percentage is ' + value.getUint8(0));\n      //   })\n      //   .catch(error => {\n      //     console.log('Argh! ' + error);\n      //   });\n      // });\n\n      okButton.addEventListener('click', function () {\n        console.log('read: ' + characteristic);\n        blue.getValue(characteristic).\n        then(function (value) {\n          console.log(value);\n        });\n        // console.log('write: 026683da-7f8b-11e6-ae22-56b6b6499611');\n        // blue.writeValue('026683da-7f8b-11e6-ae22-56b6b6499611', 'ok')\n        //   .then(writeSuccess => {\n        //     console.log(writeSuccess);\n        //   })\n        //   .catch(error => {\n        //     console.log(error);\n        //   });\n      });\n\n      console.log('7');\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/fake_3e9ce187.js\", \"/\");\n  }, { \"./app/device.js\": 1, \"b55mWE\": 5, \"buffer\": 4 }], 3: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n      ;(function (exports) {\n        'use strict';\n\n        var Arr = typeof Uint8Array !== 'undefined' ?\n        Uint8Array :\n        Array;\n\n        var PLUS = '+'.charCodeAt(0);\n        var SLASH = '/'.charCodeAt(0);\n        var NUMBER = '0'.charCodeAt(0);\n        var LOWER = 'a'.charCodeAt(0);\n        var UPPER = 'A'.charCodeAt(0);\n        var PLUS_URL_SAFE = '-'.charCodeAt(0);\n        var SLASH_URL_SAFE = '_'.charCodeAt(0);\n\n        function decode(elt) {\n          var code = elt.charCodeAt(0);\n          if (code === PLUS ||\n          code === PLUS_URL_SAFE)\n          return 62; // '+'\n          if (code === SLASH ||\n          code === SLASH_URL_SAFE)\n          return 63; // '/'\n          if (code < NUMBER)\n          return -1; //no match\n          if (code < NUMBER + 10)\n          return code - NUMBER + 26 + 26;\n          if (code < UPPER + 26)\n          return code - UPPER;\n          if (code < LOWER + 26)\n          return code - LOWER + 26;\n        }\n\n        function b64ToByteArray(b64) {\n          var i, j, l, tmp, placeHolders, arr;\n\n          if (b64.length % 4 > 0) {\n            throw new Error('Invalid string. Length must be a multiple of 4');\n          }\n\n          // the number of equal signs (place holders)\n          // if there are two placeholders, than the two characters before it\n          // represent one byte\n          // if there is only one, then the three characters before it represent 2 bytes\n          // this is just a cheap hack to not do indexOf twice\n          var len = b64.length;\n          placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;\n\n          // base64 is 4/3 + up to two characters of the original data\n          arr = new Arr(b64.length * 3 / 4 - placeHolders);\n\n          // if there are placeholders, only get up to the last complete 4 chars\n          l = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n          var L = 0;\n\n          function push(v) {\n            arr[L++] = v;\n          }\n\n          for (i = 0, j = 0; i < l; i += 4, j += 3) {\n            tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));\n            push((tmp & 0xFF0000) >> 16);\n            push((tmp & 0xFF00) >> 8);\n            push(tmp & 0xFF);\n          }\n\n          if (placeHolders === 2) {\n            tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;\n            push(tmp & 0xFF);\n          } else if (placeHolders === 1) {\n            tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;\n            push(tmp >> 8 & 0xFF);\n            push(tmp & 0xFF);\n          }\n\n          return arr;\n        }\n\n        function uint8ToBase64(uint8) {\n          var i,\n          extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n          output = \"\",\n          temp,length;\n\n          function encode(num) {\n            return lookup.charAt(num);\n          }\n\n          function tripletToBase64(num) {\n            return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);\n          }\n\n          // go through the array every three bytes, we'll deal with trailing stuff later\n          for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n            temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n            output += tripletToBase64(temp);\n          }\n\n          // pad the end with zeros, but make sure to not forget the extra bytes\n          switch (extraBytes) {\n            case 1:\n              temp = uint8[uint8.length - 1];\n              output += encode(temp >> 2);\n              output += encode(temp << 4 & 0x3F);\n              output += '==';\n              break;\n            case 2:\n              temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];\n              output += encode(temp >> 10);\n              output += encode(temp >> 4 & 0x3F);\n              output += encode(temp << 2 & 0x3F);\n              output += '=';\n              break;}\n\n\n          return output;\n        }\n\n        exports.toByteArray = b64ToByteArray;\n        exports.fromByteArray = uint8ToBase64;\n      })(typeof exports === 'undefined' ? this.base64js = {} : exports);\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js\", \"/../../node_modules/gulp-browserify/node_modules/base64-js/lib\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }], 4: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      /*!\n                                                                                                                     * The buffer module from node.js, for the browser.\n                                                                                                                     *\n                                                                                                                     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n                                                                                                                     * @license  MIT\n                                                                                                                     */\n\n      var base64 = require('base64-js');\n      var ieee754 = require('ieee754');\n\n      exports.Buffer = Buffer;\n      exports.SlowBuffer = Buffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      Buffer.poolSize = 8192;\n\n      /**\n                               * If `Buffer._useTypedArrays`:\n                               *   === true    Use Uint8Array implementation (fastest)\n                               *   === false   Use Object implementation (compatible down to IE6)\n                               */\n      Buffer._useTypedArrays = function () {\n        // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,\n        // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding\n        // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support\n        // because we need to be able to add all the node Buffer API methods. This is an issue\n        // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438\n        try {\n          var buf = new ArrayBuffer(0);\n          var arr = new Uint8Array(buf);\n          arr.foo = function () {return 42;};\n          return 42 === arr.foo() &&\n          typeof arr.subarray === 'function'; // Chrome 9-10 lack `subarray`\n        } catch (e) {\n          return false;\n        }\n      }();\n\n      /**\n            * Class: Buffer\n            * =============\n            *\n            * The Buffer constructor returns instances of `Uint8Array` that are augmented\n            * with function properties for all the node `Buffer` API functions. We use\n            * `Uint8Array` so that square bracket notation works as expected -- it returns\n            * a single octet.\n            *\n            * By augmenting the instances, we can avoid modifying the `Uint8Array`\n            * prototype.\n            */\n      function Buffer(subject, encoding, noZero) {\n        if (!(this instanceof Buffer))\n        return new Buffer(subject, encoding, noZero);\n\n        var type = typeof subject === \"undefined\" ? \"undefined\" : _typeof(subject);\n\n        // Workaround: node's base64 implementation allows for non-padded strings\n        // while base64-js does not.\n        if (encoding === 'base64' && type === 'string') {\n          subject = stringtrim(subject);\n          while (subject.length % 4 !== 0) {\n            subject = subject + '=';\n          }\n        }\n\n        // Find the length\n        var length;\n        if (type === 'number')\n        length = coerce(subject);else\n        if (type === 'string')\n        length = Buffer.byteLength(subject, encoding);else\n        if (type === 'object')\n        length = coerce(subject.length); // assume that object is array-like\n        else\n          throw new Error('First argument needs to be a number, array or string.');\n\n        var buf;\n        if (Buffer._useTypedArrays) {\n          // Preferred: Return an augmented `Uint8Array` instance for best performance\n          buf = Buffer._augment(new Uint8Array(length));\n        } else {\n          // Fallback: Return THIS instance of Buffer (created by `new`)\n          buf = this;\n          buf.length = length;\n          buf._isBuffer = true;\n        }\n\n        var i;\n        if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {\n          // Speed optimization -- use set if we're copying from a typed array\n          buf._set(subject);\n        } else if (isArrayish(subject)) {\n          // Treat array-ish objects as a byte array\n          for (i = 0; i < length; i++) {\n            if (Buffer.isBuffer(subject))\n            buf[i] = subject.readUInt8(i);else\n\n            buf[i] = subject[i];\n          }\n        } else if (type === 'string') {\n          buf.write(subject, 0, encoding);\n        } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {\n          for (i = 0; i < length; i++) {\n            buf[i] = 0;\n          }\n        }\n\n        return buf;\n      }\n\n      // STATIC METHODS\n      // ==============\n\n      Buffer.isEncoding = function (encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case 'hex':\n          case 'utf8':\n          case 'utf-8':\n          case 'ascii':\n          case 'binary':\n          case 'base64':\n          case 'raw':\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            return true;\n          default:\n            return false;}\n\n      };\n\n      Buffer.isBuffer = function (b) {\n        return !!(b !== null && b !== undefined && b._isBuffer);\n      };\n\n      Buffer.byteLength = function (str, encoding) {\n        var ret;\n        str = str + '';\n        switch (encoding || 'utf8') {\n          case 'hex':\n            ret = str.length / 2;\n            break;\n          case 'utf8':\n          case 'utf-8':\n            ret = utf8ToBytes(str).length;\n            break;\n          case 'ascii':\n          case 'binary':\n          case 'raw':\n            ret = str.length;\n            break;\n          case 'base64':\n            ret = base64ToBytes(str).length;\n            break;\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            ret = str.length * 2;\n            break;\n          default:\n            throw new Error('Unknown encoding');}\n\n        return ret;\n      };\n\n      Buffer.concat = function (list, totalLength) {\n        assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\\n' +\n        'list should be an Array.');\n\n        if (list.length === 0) {\n          return new Buffer(0);\n        } else if (list.length === 1) {\n          return list[0];\n        }\n\n        var i;\n        if (typeof totalLength !== 'number') {\n          totalLength = 0;\n          for (i = 0; i < list.length; i++) {\n            totalLength += list[i].length;\n          }\n        }\n\n        var buf = new Buffer(totalLength);\n        var pos = 0;\n        for (i = 0; i < list.length; i++) {\n          var item = list[i];\n          item.copy(buf, pos);\n          pos += item.length;\n        }\n        return buf;\n      };\n\n      // BUFFER INSTANCE METHODS\n      // =======================\n\n      function _hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        var remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n\n        // must be an even number of digits\n        var strLen = string.length;\n        assert(strLen % 2 === 0, 'Invalid hex string');\n\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        for (var i = 0; i < length; i++) {\n          var byte = parseInt(string.substr(i * 2, 2), 16);\n          assert(!isNaN(byte), 'Invalid hex string');\n          buf[offset + i] = byte;\n        }\n        Buffer._charsWritten = i * 2;\n        return i;\n      }\n\n      function _utf8Write(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(utf8ToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      function _asciiWrite(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(asciiToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      function _binaryWrite(buf, string, offset, length) {\n        return _asciiWrite(buf, string, offset, length);\n      }\n\n      function _base64Write(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(base64ToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      function _utf16leWrite(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(utf16leToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      Buffer.prototype.write = function (string, offset, length, encoding) {\n        // Support both (string, offset, length, encoding)\n        // and the legacy (string, encoding, offset, length)\n        if (isFinite(offset)) {\n          if (!isFinite(length)) {\n            encoding = length;\n            length = undefined;\n          }\n        } else {// legacy\n          var swap = encoding;\n          encoding = offset;\n          offset = length;\n          length = swap;\n        }\n\n        offset = Number(offset) || 0;\n        var remaining = this.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        encoding = String(encoding || 'utf8').toLowerCase();\n\n        var ret;\n        switch (encoding) {\n          case 'hex':\n            ret = _hexWrite(this, string, offset, length);\n            break;\n          case 'utf8':\n          case 'utf-8':\n            ret = _utf8Write(this, string, offset, length);\n            break;\n          case 'ascii':\n            ret = _asciiWrite(this, string, offset, length);\n            break;\n          case 'binary':\n            ret = _binaryWrite(this, string, offset, length);\n            break;\n          case 'base64':\n            ret = _base64Write(this, string, offset, length);\n            break;\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            ret = _utf16leWrite(this, string, offset, length);\n            break;\n          default:\n            throw new Error('Unknown encoding');}\n\n        return ret;\n      };\n\n      Buffer.prototype.toString = function (encoding, start, end) {\n        var self = this;\n\n        encoding = String(encoding || 'utf8').toLowerCase();\n        start = Number(start) || 0;\n        end = end !== undefined ?\n        Number(end) :\n        end = self.length;\n\n        // Fastpath empty strings\n        if (end === start)\n        return '';\n\n        var ret;\n        switch (encoding) {\n          case 'hex':\n            ret = _hexSlice(self, start, end);\n            break;\n          case 'utf8':\n          case 'utf-8':\n            ret = _utf8Slice(self, start, end);\n            break;\n          case 'ascii':\n            ret = _asciiSlice(self, start, end);\n            break;\n          case 'binary':\n            ret = _binarySlice(self, start, end);\n            break;\n          case 'base64':\n            ret = _base64Slice(self, start, end);\n            break;\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            ret = _utf16leSlice(self, start, end);\n            break;\n          default:\n            throw new Error('Unknown encoding');}\n\n        return ret;\n      };\n\n      Buffer.prototype.toJSON = function () {\n        return {\n          type: 'Buffer',\n          data: Array.prototype.slice.call(this._arr || this, 0) };\n\n      };\n\n      // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n      Buffer.prototype.copy = function (target, target_start, start, end) {\n        var source = this;\n\n        if (!start) start = 0;\n        if (!end && end !== 0) end = this.length;\n        if (!target_start) target_start = 0;\n\n        // Copy 0 bytes; we're done\n        if (end === start) return;\n        if (target.length === 0 || source.length === 0) return;\n\n        // Fatal error conditions\n        assert(end >= start, 'sourceEnd < sourceStart');\n        assert(target_start >= 0 && target_start < target.length,\n        'targetStart out of bounds');\n        assert(start >= 0 && start < source.length, 'sourceStart out of bounds');\n        assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds');\n\n        // Are we oob?\n        if (end > this.length)\n        end = this.length;\n        if (target.length - target_start < end - start)\n        end = target.length - target_start + start;\n\n        var len = end - start;\n\n        if (len < 100 || !Buffer._useTypedArrays) {\n          for (var i = 0; i < len; i++) {\n            target[i + target_start] = this[i + start];}\n        } else {\n          target._set(this.subarray(start, start + len), target_start);\n        }\n      };\n\n      function _base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n\n      function _utf8Slice(buf, start, end) {\n        var res = '';\n        var tmp = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; i++) {\n          if (buf[i] <= 0x7F) {\n            res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);\n            tmp = '';\n          } else {\n            tmp += '%' + buf[i].toString(16);\n          }\n        }\n\n        return res + decodeUtf8Char(tmp);\n      }\n\n      function _asciiSlice(buf, start, end) {\n        var ret = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; i++) {\n          ret += String.fromCharCode(buf[i]);}\n        return ret;\n      }\n\n      function _binarySlice(buf, start, end) {\n        return _asciiSlice(buf, start, end);\n      }\n\n      function _hexSlice(buf, start, end) {\n        var len = buf.length;\n\n        if (!start || start < 0) start = 0;\n        if (!end || end < 0 || end > len) end = len;\n\n        var out = '';\n        for (var i = start; i < end; i++) {\n          out += toHex(buf[i]);\n        }\n        return out;\n      }\n\n      function _utf16leSlice(buf, start, end) {\n        var bytes = buf.slice(start, end);\n        var res = '';\n        for (var i = 0; i < bytes.length; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n\n      Buffer.prototype.slice = function (start, end) {\n        var len = this.length;\n        start = clamp(start, len, 0);\n        end = clamp(end, len, len);\n\n        if (Buffer._useTypedArrays) {\n          return Buffer._augment(this.subarray(start, end));\n        } else {\n          var sliceLen = end - start;\n          var newBuf = new Buffer(sliceLen, undefined, true);\n          for (var i = 0; i < sliceLen; i++) {\n            newBuf[i] = this[i + start];\n          }\n          return newBuf;\n        }\n      };\n\n      // `get` will be removed in Node 0.13+\n      Buffer.prototype.get = function (offset) {\n        console.log('.get() is deprecated. Access using array indexes instead.');\n        return this.readUInt8(offset);\n      };\n\n      // `set` will be removed in Node 0.13+\n      Buffer.prototype.set = function (v, offset) {\n        console.log('.set() is deprecated. Access using array indexes instead.');\n        return this.writeUInt8(v, offset);\n      };\n\n      Buffer.prototype.readUInt8 = function (offset, noAssert) {\n        if (!noAssert) {\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset < this.length, 'Trying to read beyond buffer length');\n        }\n\n        if (offset >= this.length)\n        return;\n\n        return this[offset];\n      };\n\n      function _readUInt16(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val;\n        if (littleEndian) {\n          val = buf[offset];\n          if (offset + 1 < len)\n          val |= buf[offset + 1] << 8;\n        } else {\n          val = buf[offset] << 8;\n          if (offset + 1 < len)\n          val |= buf[offset + 1];\n        }\n        return val;\n      }\n\n      Buffer.prototype.readUInt16LE = function (offset, noAssert) {\n        return _readUInt16(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readUInt16BE = function (offset, noAssert) {\n        return _readUInt16(this, offset, false, noAssert);\n      };\n\n      function _readUInt32(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val;\n        if (littleEndian) {\n          if (offset + 2 < len)\n          val = buf[offset + 2] << 16;\n          if (offset + 1 < len)\n          val |= buf[offset + 1] << 8;\n          val |= buf[offset];\n          if (offset + 3 < len)\n          val = val + (buf[offset + 3] << 24 >>> 0);\n        } else {\n          if (offset + 1 < len)\n          val = buf[offset + 1] << 16;\n          if (offset + 2 < len)\n          val |= buf[offset + 2] << 8;\n          if (offset + 3 < len)\n          val |= buf[offset + 3];\n          val = val + (buf[offset] << 24 >>> 0);\n        }\n        return val;\n      }\n\n      Buffer.prototype.readUInt32LE = function (offset, noAssert) {\n        return _readUInt32(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readUInt32BE = function (offset, noAssert) {\n        return _readUInt32(this, offset, false, noAssert);\n      };\n\n      Buffer.prototype.readInt8 = function (offset, noAssert) {\n        if (!noAssert) {\n          assert(offset !== undefined && offset !== null,\n          'missing offset');\n          assert(offset < this.length, 'Trying to read beyond buffer length');\n        }\n\n        if (offset >= this.length)\n        return;\n\n        var neg = this[offset] & 0x80;\n        if (neg)\n        return (0xff - this[offset] + 1) * -1;else\n\n        return this[offset];\n      };\n\n      function _readInt16(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val = _readUInt16(buf, offset, littleEndian, true);\n        var neg = val & 0x8000;\n        if (neg)\n        return (0xffff - val + 1) * -1;else\n\n        return val;\n      }\n\n      Buffer.prototype.readInt16LE = function (offset, noAssert) {\n        return _readInt16(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readInt16BE = function (offset, noAssert) {\n        return _readInt16(this, offset, false, noAssert);\n      };\n\n      function _readInt32(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val = _readUInt32(buf, offset, littleEndian, true);\n        var neg = val & 0x80000000;\n        if (neg)\n        return (0xffffffff - val + 1) * -1;else\n\n        return val;\n      }\n\n      Buffer.prototype.readInt32LE = function (offset, noAssert) {\n        return _readInt32(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readInt32BE = function (offset, noAssert) {\n        return _readInt32(this, offset, false, noAssert);\n      };\n\n      function _readFloat(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        return ieee754.read(buf, offset, littleEndian, 23, 4);\n      }\n\n      Buffer.prototype.readFloatLE = function (offset, noAssert) {\n        return _readFloat(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readFloatBE = function (offset, noAssert) {\n        return _readFloat(this, offset, false, noAssert);\n      };\n\n      function _readDouble(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset + 7 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        return ieee754.read(buf, offset, littleEndian, 52, 8);\n      }\n\n      Buffer.prototype.readDoubleLE = function (offset, noAssert) {\n        return _readDouble(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readDoubleBE = function (offset, noAssert) {\n        return _readDouble(this, offset, false, noAssert);\n      };\n\n      Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset < this.length, 'trying to write beyond buffer length');\n          verifuint(value, 0xff);\n        }\n\n        if (offset >= this.length) return;\n\n        this[offset] = value;\n      };\n\n      function _writeUInt16(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'trying to write beyond buffer length');\n          verifuint(value, 0xffff);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {\n          buf[offset + i] =\n          (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>>\n          (littleEndian ? i : 1 - i) * 8;\n        }\n      }\n\n      Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n        _writeUInt16(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n        _writeUInt16(this, value, offset, false, noAssert);\n      };\n\n      function _writeUInt32(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'trying to write beyond buffer length');\n          verifuint(value, 0xffffffff);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {\n          buf[offset + i] =\n          value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n        }\n      }\n\n      Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n        _writeUInt32(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n        _writeUInt32(this, value, offset, false, noAssert);\n      };\n\n      Buffer.prototype.writeInt8 = function (value, offset, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset < this.length, 'Trying to write beyond buffer length');\n          verifsint(value, 0x7f, -0x80);\n        }\n\n        if (offset >= this.length)\n        return;\n\n        if (value >= 0)\n        this.writeUInt8(value, offset, noAssert);else\n\n        this.writeUInt8(0xff + value + 1, offset, noAssert);\n      };\n\n      function _writeInt16(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'Trying to write beyond buffer length');\n          verifsint(value, 0x7fff, -0x8000);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        if (value >= 0)\n        _writeUInt16(buf, value, offset, littleEndian, noAssert);else\n\n        _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert);\n      }\n\n      Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n        _writeInt16(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n        _writeInt16(this, value, offset, false, noAssert);\n      };\n\n      function _writeInt32(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');\n          verifsint(value, 0x7fffffff, -0x80000000);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        if (value >= 0)\n        _writeUInt32(buf, value, offset, littleEndian, noAssert);else\n\n        _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert);\n      }\n\n      Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n        _writeInt32(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n        _writeInt32(this, value, offset, false, noAssert);\n      };\n\n      function _writeFloat(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');\n          verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n      }\n\n      Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n        _writeFloat(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n        _writeFloat(this, value, offset, false, noAssert);\n      };\n\n      function _writeDouble(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 7 < buf.length,\n          'Trying to write beyond buffer length');\n          verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n      }\n\n      Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n        _writeDouble(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n        _writeDouble(this, value, offset, false, noAssert);\n      };\n\n      // fill(value, start=0, end=buffer.length)\n      Buffer.prototype.fill = function (value, start, end) {\n        if (!value) value = 0;\n        if (!start) start = 0;\n        if (!end) end = this.length;\n\n        if (typeof value === 'string') {\n          value = value.charCodeAt(0);\n        }\n\n        assert(typeof value === 'number' && !isNaN(value), 'value is not a number');\n        assert(end >= start, 'end < start');\n\n        // Fill 0 bytes; we're done\n        if (end === start) return;\n        if (this.length === 0) return;\n\n        assert(start >= 0 && start < this.length, 'start out of bounds');\n        assert(end >= 0 && end <= this.length, 'end out of bounds');\n\n        for (var i = start; i < end; i++) {\n          this[i] = value;\n        }\n      };\n\n      Buffer.prototype.inspect = function () {\n        var out = [];\n        var len = this.length;\n        for (var i = 0; i < len; i++) {\n          out[i] = toHex(this[i]);\n          if (i === exports.INSPECT_MAX_BYTES) {\n            out[i + 1] = '...';\n            break;\n          }\n        }\n        return '<Buffer ' + out.join(' ') + '>';\n      };\n\n      /**\n          * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n          * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n          */\n      Buffer.prototype.toArrayBuffer = function () {\n        if (typeof Uint8Array !== 'undefined') {\n          if (Buffer._useTypedArrays) {\n            return new Buffer(this).buffer;\n          } else {\n            var buf = new Uint8Array(this.length);\n            for (var i = 0, len = buf.length; i < len; i += 1) {\n              buf[i] = this[i];}\n            return buf.buffer;\n          }\n        } else {\n          throw new Error('Buffer.toArrayBuffer not supported in this browser');\n        }\n      };\n\n      // HELPER FUNCTIONS\n      // ================\n\n      function stringtrim(str) {\n        if (str.trim) return str.trim();\n        return str.replace(/^\\s+|\\s+$/g, '');\n      }\n\n      var BP = Buffer.prototype;\n\n      /**\n                                  * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n                                  */\n      Buffer._augment = function (arr) {\n        arr._isBuffer = true;\n\n        // save reference to original Uint8Array get/set methods before overwriting\n        arr._get = arr.get;\n        arr._set = arr.set;\n\n        // deprecated, will be removed in node 0.13+\n        arr.get = BP.get;\n        arr.set = BP.set;\n\n        arr.write = BP.write;\n        arr.toString = BP.toString;\n        arr.toLocaleString = BP.toString;\n        arr.toJSON = BP.toJSON;\n        arr.copy = BP.copy;\n        arr.slice = BP.slice;\n        arr.readUInt8 = BP.readUInt8;\n        arr.readUInt16LE = BP.readUInt16LE;\n        arr.readUInt16BE = BP.readUInt16BE;\n        arr.readUInt32LE = BP.readUInt32LE;\n        arr.readUInt32BE = BP.readUInt32BE;\n        arr.readInt8 = BP.readInt8;\n        arr.readInt16LE = BP.readInt16LE;\n        arr.readInt16BE = BP.readInt16BE;\n        arr.readInt32LE = BP.readInt32LE;\n        arr.readInt32BE = BP.readInt32BE;\n        arr.readFloatLE = BP.readFloatLE;\n        arr.readFloatBE = BP.readFloatBE;\n        arr.readDoubleLE = BP.readDoubleLE;\n        arr.readDoubleBE = BP.readDoubleBE;\n        arr.writeUInt8 = BP.writeUInt8;\n        arr.writeUInt16LE = BP.writeUInt16LE;\n        arr.writeUInt16BE = BP.writeUInt16BE;\n        arr.writeUInt32LE = BP.writeUInt32LE;\n        arr.writeUInt32BE = BP.writeUInt32BE;\n        arr.writeInt8 = BP.writeInt8;\n        arr.writeInt16LE = BP.writeInt16LE;\n        arr.writeInt16BE = BP.writeInt16BE;\n        arr.writeInt32LE = BP.writeInt32LE;\n        arr.writeInt32BE = BP.writeInt32BE;\n        arr.writeFloatLE = BP.writeFloatLE;\n        arr.writeFloatBE = BP.writeFloatBE;\n        arr.writeDoubleLE = BP.writeDoubleLE;\n        arr.writeDoubleBE = BP.writeDoubleBE;\n        arr.fill = BP.fill;\n        arr.inspect = BP.inspect;\n        arr.toArrayBuffer = BP.toArrayBuffer;\n\n        return arr;\n      };\n\n      // slice(start, end)\n      function clamp(index, len, defaultValue) {\n        if (typeof index !== 'number') return defaultValue;\n        index = ~~index; // Coerce to integer.\n        if (index >= len) return len;\n        if (index >= 0) return index;\n        index += len;\n        if (index >= 0) return index;\n        return 0;\n      }\n\n      function coerce(length) {\n        // Coerce length to a number (possibly NaN), round up\n        // in case it's fractional (e.g. 123.456) then do a\n        // double negate to coerce a NaN to 0. Easy, right?\n        length = ~~Math.ceil(+length);\n        return length < 0 ? 0 : length;\n      }\n\n      function isArray(subject) {\n        return (Array.isArray || function (subject) {\n          return Object.prototype.toString.call(subject) === '[object Array]';\n        })(subject);\n      }\n\n      function isArrayish(subject) {\n        return isArray(subject) || Buffer.isBuffer(subject) ||\n        subject && (typeof subject === \"undefined\" ? \"undefined\" : _typeof(subject)) === 'object' &&\n        typeof subject.length === 'number';\n      }\n\n      function toHex(n) {\n        if (n < 16) return '0' + n.toString(16);\n        return n.toString(16);\n      }\n\n      function utf8ToBytes(str) {\n        var byteArray = [];\n        for (var i = 0; i < str.length; i++) {\n          var b = str.charCodeAt(i);\n          if (b <= 0x7F)\n          byteArray.push(str.charCodeAt(i));else\n          {\n            var start = i;\n            if (b >= 0xD800 && b <= 0xDFFF) i++;\n            var h = encodeURIComponent(str.slice(start, i + 1)).substr(1).split('%');\n            for (var j = 0; j < h.length; j++) {\n              byteArray.push(parseInt(h[j], 16));}\n          }\n        }\n        return byteArray;\n      }\n\n      function asciiToBytes(str) {\n        var byteArray = [];\n        for (var i = 0; i < str.length; i++) {\n          // Node's code seems to be doing this and not & 0x7F..\n          byteArray.push(str.charCodeAt(i) & 0xFF);\n        }\n        return byteArray;\n      }\n\n      function utf16leToBytes(str) {\n        var c, hi, lo;\n        var byteArray = [];\n        for (var i = 0; i < str.length; i++) {\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n\n        return byteArray;\n      }\n\n      function base64ToBytes(str) {\n        return base64.toByteArray(str);\n      }\n\n      function blitBuffer(src, dst, offset, length) {\n        var pos;\n        for (var i = 0; i < length; i++) {\n          if (i + offset >= dst.length || i >= src.length)\n          break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n\n      function decodeUtf8Char(str) {\n        try {\n          return decodeURIComponent(str);\n        } catch (err) {\n          return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n        }\n      }\n\n      /*\n         * We have to make sure that the value is a valid integer. This means that it\n         * is non-negative. It has no fractional component and that it does not\n         * exceed the maximum allowed value.\n         */\n      function verifuint(value, max) {\n        assert(typeof value === 'number', 'cannot write a non-number as a number');\n        assert(value >= 0, 'specified a negative value for writing an unsigned value');\n        assert(value <= max, 'value is larger than maximum value for type');\n        assert(Math.floor(value) === value, 'value has a fractional component');\n      }\n\n      function verifsint(value, max, min) {\n        assert(typeof value === 'number', 'cannot write a non-number as a number');\n        assert(value <= max, 'value larger than maximum allowed value');\n        assert(value >= min, 'value smaller than minimum allowed value');\n        assert(Math.floor(value) === value, 'value has a fractional component');\n      }\n\n      function verifIEEE754(value, max, min) {\n        assert(typeof value === 'number', 'cannot write a non-number as a number');\n        assert(value <= max, 'value larger than maximum allowed value');\n        assert(value >= min, 'value smaller than minimum allowed value');\n      }\n\n      function assert(test, message) {\n        if (!test) throw new Error(message || 'Failed assertion');\n      }\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/gulp-browserify/node_modules/buffer/index.js\", \"/../../node_modules/gulp-browserify/node_modules/buffer\");\n  }, { \"b55mWE\": 5, \"base64-js\": 3, \"buffer\": 4, \"ieee754\": 6 }], 5: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      // shim for using process in browser\n\n      var process = module.exports = {};\n\n      process.nextTick = function () {\n        var canSetImmediate = typeof window !== 'undefined' &&\n        window.setImmediate;\n        var canPost = typeof window !== 'undefined' &&\n        window.postMessage && window.addEventListener;\n\n\n        if (canSetImmediate) {\n          return function (f) {return window.setImmediate(f);};\n        }\n\n        if (canPost) {\n          var queue = [];\n          window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n              ev.stopPropagation();\n              if (queue.length > 0) {\n                var fn = queue.shift();\n                fn();\n              }\n            }\n          }, true);\n\n          return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n          };\n        }\n\n        return function nextTick(fn) {\n          setTimeout(fn, 0);\n        };\n      }();\n\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      // TODO(shtylman)\n      process.cwd = function () {return '/';};\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/gulp-browserify/node_modules/process/browser.js\", \"/../../node_modules/gulp-browserify/node_modules/process\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }], 6: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s = buffer[offset + i];\n\n        i += d;\n\n        e = s & (1 << -nBits) - 1;\n        s >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n\n      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n\n        value = Math.abs(value);\n\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n        buffer[offset + i - d] |= s * 128;\n      };\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/ieee754/index.js\", \"/../../node_modules/ieee754\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }] }, {}, [2]);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qLnZhbGxlbHVuZ2EvV29ya3NwYWNlcy90ZXNpcy9zZWFtbGVzcy1wb3N0ZXItY29udHJvbC9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvai52YWxsZWx1bmdhL1dvcmtzcGFjZXMvdGVzaXMvc2VhbWxlc3MtcG9zdGVyLWNvbnRyb2wvYXBwL3NjcmlwdHMvYXBwL2RldmljZS5qcyIsIi9Vc2Vycy9qLnZhbGxlbHVuZ2EvV29ya3NwYWNlcy90ZXNpcy9zZWFtbGVzcy1wb3N0ZXItY29udHJvbC9hcHAvc2NyaXB0cy9mYWtlXzNlOWNlMTg3LmpzIiwiL1VzZXJzL2oudmFsbGVsdW5nYS9Xb3Jrc3BhY2VzL3Rlc2lzL3NlYW1sZXNzLXBvc3Rlci1jb250cm9sL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwiL1VzZXJzL2oudmFsbGVsdW5nYS9Xb3Jrc3BhY2VzL3Rlc2lzL3NlYW1sZXNzLXBvc3Rlci1jb250cm9sL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi9Vc2Vycy9qLnZhbGxlbHVuZ2EvV29ya3NwYWNlcy90ZXNpcy9zZWFtbGVzcy1wb3N0ZXItY29udHJvbC9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvai52YWxsZWx1bmdhL1dvcmtzcGFjZXMvdGVzaXMvc2VhbWxlc3MtcG9zdGVyLWNvbnRyb2wvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQ0FBO0FBRUEsQUFDQTs7Z0NBQ0E7d0JBQ0E7eURBQ0E7QUFDQSxBQUNBLFNBUEE7O0FBUUE7d0JBQ0E7MEJBQ0E7d0JBQ0E7c0JBQ0EsQUFDQTs7aUNBQ0EsQUFDQTs7cURBQ0E7bUNBQ0E7NkJBQ0E7NEVBQ0E7cUJBQ0E7QUFDQTtBQUNBLEFBQ0E7O0FBQ0E7d0JBQ0E7NkJBQ0E7c0NBQ0E7QUFDQTtrQ0FDQTtBQUNBLEFBQ0E7O2dCQUNBO3dCQUNBO3NEQUNBO3NFQUNBOzZFQUNBO0FBQ0EsQUFDQTs7QUFDQTt3QkFDQTtzREFDQTtzRUFDQTtrRUFDQTtBQUNBLEFBQ0E7O0FBQ0E7d0JBQ0E7NkJBQ0E7c0NBQ0E7QUFDQTtrQ0FDQTtBQUNBLEFBQ0E7O0FBQ0E7d0JBQ0E7d0JBQ0E7QUFDQSxBQUNBOzs7QUFDQTtBQUNBLHVCQUNBLEFBQ0E7Ozs7QUMvREE7QUFDQTtBQUNBO0FBQ0EsaUNBQ0E7O0FBQ0E7QUFDQSwyQkFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQ0E7O0FBQ0E7QUFDQSxBQUNBOztBQUNBLDZDQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEFBQ0E7O0FBQ0EsMERBQ0E7cUJBQ0E7OENBQ0E7eUJBQ0E7OEJBQ0E7QUFDQTs2QkFDQTtzQkFDQTtBQUNBOytCQUNBO3NCQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEFBQ0E7O0FBQ0EscURBQ0E7K0JBQ0E7c0JBQ0E7OEJBQ0E7c0JBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxrQkFDQSxBQUNBOzs7O0FDakhBO0FB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RkFDQTtpQkFDQTtvQ0FDQTsrQkFDQTtBQUNBO0FBQ0E7QUFDQTthQUNBLEFBQ0E7O3VDQUNBO3VCQUNBOytDQUNBO0FBQ0E7QUFDQSxBQUNBOztxQ0FDQTt5QkFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQ0E7O0FBQ0EsdUJBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQ0E7O0FBQ0Esd0NBQ0E7d0JBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EscUNBQ0E7d0JBQ0E7QUFDQSxBQUNBOzs7O0FDakVBO0FBQ0EsbUVBQ0E7ZUFDQTt1Q0FDQTtpQ0FDQTs0QkFDQTtxQkFDQTtvQ0FDQTs0QkFDQTtnQ0FDQSxBQUNBOzthQUNBLEFBQ0E7O2dDQUNBO2VBQ0E7aUJBQ0E7aUZBQ0EsQUFDQTs7Z0NBQ0E7ZUFDQTtpQkFDQTtpRkFDQSxBQUNBOztxQkFDQTtrQkFDQTsrQkFDQTswQ0FDQTtlQUNBOzhCQUNBO2tCQUNBO0FBQ0E7a0RBQ0E7QUFDQTs7QUFDQSwyRUFDQTtrQkFDQTt1Q0FDQTtpQ0FDQTs0QkFDQTtxRUFDQTtvQ0FDQTs0QkFDQTtnRUFDQSxBQUNBOzt5QkFDQSxBQUNBOztnREFDQTtpQ0FDQTtjQUNBO2VBQ0E7Z0RBQ0E7aURBQ0E7QUFDQTtpQkFDQTtBQUNBOzhCQUNBOzBCQUNBO2lCQUNBOzBDQUNBO0FBQ0E7OEJBQ0E7QUFDQTtpQkFDQTtBQUNBLEFBQ0E7O2lDQUNBO2dCQUNBO2dCQUNBO3FDQUNBOzhDQUNBO29CQUNBO2lCQUNBOzZEQUNBO2dCQUNBO0FBQ0E7QUFDQSxBQUNBOzt1RkFDQSxBQUNBOzt3QkFDQTtnQkFDQTtzRkFDQSxBQUNBOztzQ0FDQTtBQUNBLEFBQ0E7OztvQ050RkEiLCJmaWxlIjoiYXBwLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5jbGFzcyBQb3N0ZXJEZXZpY2Uge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGV2aWNlID0gbnVsbDtcbiAgICB0aGlzLm9uRGlzY29ubmVjdGVkID0gdGhpcy5vbkRpc2Nvbm5lY3RlZC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgcmVxdWVzdCgpIHtcbiAgICBjb25zb2xlLmxvZygncmVxdWVzdCcpO1xuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgZmlsdGVyczogW3tcbiAgICAgICAgbmFtZTogJ2NvbW1TZXJ2aWNlJ1xuICAgICAgfV0sXG4gICAgICBvcHRpb25hbFNlcnZpY2VzOiBbMHgxMmFiXVxuICAgIH07XG4gICAgcmV0dXJuIG5hdmlnYXRvci5ibHVldG9vdGgucmVxdWVzdERldmljZShvcHRpb25zKVxuICAgIC50aGVuKGRldmljZSA9PiB7XG4gICAgICB0aGlzLmRldmljZSA9IGRldmljZTtcbiAgICAgIHRoaXMuZGV2aWNlLmFkZEV2ZW50TGlzdGVuZXIoJ2dhdHRzZXJ2ZXJkaXNjb25uZWN0ZWQnLCB0aGlzLm9uRGlzY29ubmVjdGVkKTtcbiAgICAgIHJldHVybiBkZXZpY2U7XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0KCkge1xuICAgIGNvbnNvbGUubG9nKCdjb25uZWN0Jyk7XG4gICAgaWYgKHRoaXMuZGV2aWNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXZpY2UuZ2F0dC5jb25uZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnRGV2aWNlIGlzIG5vdCBjb25uZWN0ZWQuJyk7XG4gIH1cblxuICB3cml0ZURhdGEoZGF0YSkge1xuICAgIGNvbnNvbGUubG9nKCd3cml0ZURhdGEnKTtcbiAgICByZXR1cm4gdGhpcy5kZXZpY2UuZ2F0dC5nZXRQcmltYXJ5U2VydmljZSgweDEyYWIpXG4gICAgLnRoZW4oc2VydmljZSA9PiBzZXJ2aWNlLmdldENoYXJhY3RlcmlzdGljKDB4MzRjZCkpXG4gICAgLnRoZW4oY2hhcmFjdGVyaXN0aWMgPT4gY2hhcmFjdGVyaXN0aWMud3JpdGVWYWx1ZShkYXRhKSk7XG4gIH1cblxuICByZWFkRGF0YSgpIHtcbiAgICBjb25zb2xlLmxvZygncmVhZERhdGEnKTtcbiAgICByZXR1cm4gdGhpcy5kZXZpY2UuZ2F0dC5nZXRQcmltYXJ5U2VydmljZSgweDEyYWIpXG4gICAgLnRoZW4oc2VydmljZSA9PiBzZXJ2aWNlLmdldENoYXJhY3RlcmlzdGljKDB4MzRjZCkpXG4gICAgLnRoZW4oY2hhcmFjdGVyaXN0aWMgPT4gY2hhcmFjdGVyaXN0aWMucmVhZFZhbHVlKCkpO1xuICB9XG5cbiAgZGlzY29ubmVjdCgpIHtcbiAgICBjb25zb2xlLmxvZygnZGlzY29ubmVjdCcpO1xuICAgIGlmICh0aGlzLmRldmljZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGV2aWNlLmdhdHQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0RldmljZSBpcyBub3QgY29ubmVjdGVkLicpO1xuICB9XG5cbiAgb25EaXNjb25uZWN0ZWQoKSB7XG4gICAgY29uc29sZS5sb2coJ29uRGlzY29ubmVjdGVkJyk7XG4gICAgY29uc29sZS5sb2coJ0RldmljZSBpcyBkaXNjb25uZWN0ZWQuJyk7XG4gIH1cbn1cblxuY29uc3QgcG9zdGVyRGV2aWNlID0gbmV3IFBvc3RlckRldmljZSgpO1xubW9kdWxlLmV4cG9ydHMgPSBwb3N0ZXJEZXZpY2U7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYjU1bVdFXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvYXBwL2RldmljZS5qc1wiLFwiL2FwcFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIGNvbnN0IEJsdWV0b290aERldmljZSA9IHJlcXVpcmUoJ3dlYi1ibHVldG9vdGgnKTtcbi8vIGNvbnN0IHN0YXRlTWFuYWdlciA9IHJlcXVpcmUoJy4vYXBwL3N0YXRlLmpzJyk7XG5jb25zdCBwb3N0ZXJEZXZpY2UgPSByZXF1aXJlKCcuL2FwcC9kZXZpY2UuanMnKTtcblxuLy8gY29uc3Qgc2VydmljZSA9ICcxZWNjZTRmMi03ZjllLTExZTYtYWUyMi01NmI2YjY0OTk2MTEnO1xuY29uc3QgY2hhcmFjdGVyaXN0aWMgPSAnNDg4ZDc5NTAtN2Y5ZS0xMWU2LWFlMjItNTZiNmI2NDk5NjExJztcblxuLy8gY29uc3QgZmlsdGVyID0ge1xuLy8gICBuYW1lOiAnTXlEZXZpY2UnLFxuLy8gICBzZXJ2aWNlOiBbc2VydmljZV1cbi8vIH07XG5sZXQgYmx1ZTtcblxuY29uc3QgY29ubmVjdEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdqcy1jb25uZWN0Jyk7XG4vLyBjb25zdCBkaXNjb25uZWN0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2pzLWRpc2Nvbm5lY3QnKTtcblxuY29uc3Qgb2tCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnanMtb2snKTtcblxuLy8gY29ubmVjdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbi8vICAgY29ubmVjdEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4vLyAgIHN0YXRlTWFuYWdlci5jaGFuZ2UoJ2Nvbm5lY3RpbmcnKTtcbi8vXG4vLyAgIGJsdWUgPSBuZXcgQmx1ZXRvb3RoRGV2aWNlKGZpbHRlcik7XG4vLyAgIGJsdWUuY29ubmVjdCgpXG4vLyAgICAgLnRoZW4oZGV2aWNlID0+IHtcbi8vICAgICAgIGNvbnNvbGUubG9nKGRldmljZSk7XG4vLyAgICAgICBzdGF0ZU1hbmFnZXIuY2hhbmdlKCdjb25uZWN0ZWQnKTtcbi8vICAgICAgIGNvbm5lY3RCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbi8vICAgICB9KVxuLy8gICAgIC5jYXRjaChlcnJvciA9PiB7XG4vLyAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4vLyAgICAgICBzdGF0ZU1hbmFnZXIuY2hhbmdlKCdpbml0Jyk7XG4vLyAgICAgICBjb25uZWN0QnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4vLyAgICAgfSk7XG4vLyB9KTtcbi8vXG4vLyBkaXNjb25uZWN0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuLy8gICBpZiAoYmx1ZS5kaXNjb25uZWN0KCkpIHtcbi8vICAgICBzdGF0ZU1hbmFnZXIuY2hhbmdlKCdpbml0Jyk7XG4vLyAgIH0gZWxzZSB7XG4vLyAgICAgY29uc29sZS5sb2coJ2Vycm9yIHdoaWxlIGRpc2Nvbm5lY3QnKTtcbi8vICAgfVxuLy8gfSk7XG5cbmNvbm5lY3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIHBvc3RlckRldmljZS5yZXF1ZXN0KClcbiAgLnRoZW4oKCkgPT4gcG9zdGVyRGV2aWNlLmNvbm5lY3QoKSlcbiAgLnRoZW4oKCkgPT4ge1xuICAgIHJldHVybiBwb3N0ZXJEZXZpY2UucmVhZERhdGEoKTtcbiAgfSlcbiAgLnRoZW4oZGF0YSA9PiB7XG4gICAgY29uc29sZS5sb2coZGF0YSk7XG4gIH0pXG4gIC5jYXRjaChlcnJvciA9PiB7XG4gICAgY29uc29sZS5sb2coZXJyb3IpO1xuICB9KTtcbn0pO1xuLy8gY29ubmVjdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbi8vICAgY29uc29sZS5sb2coJ1JlcXVlc3RpbmcgQmx1ZXRvb3RoIERldmljZS4uLicpO1xuLy8gICBuYXZpZ2F0b3IuYmx1ZXRvb3RoLnJlcXVlc3REZXZpY2Uoe1xuLy8gICAgIGZpbHRlcnM6IFt7c2VydmljZXM6IFtzZXJ2aWNlXX1dXG4vLyAgIH0pXG4vLyAgIC50aGVuKGRldmljZSA9PiB7XG4vLyAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3RpbmcgdG8gR0FUVCBTZXJ2ZXIuLi4nKTtcbi8vICAgICByZXR1cm4gZGV2aWNlLmdhdHQuY29ubmVjdCgpO1xuLy8gICB9KVxuLy8gICAudGhlbihzZXJ2ZXIgPT4ge1xuLy8gICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIFNlcnZpY2UuLi4nKTtcbi8vICAgICByZXR1cm4gc2VydmVyLmdldFByaW1hcnlTZXJ2aWNlKHNlcnZpY2UpO1xuLy8gICB9KVxuLy8gICAudGhlbihzZXJ2aWNlID0+IHtcbi8vICAgICBjb25zb2xlLmxvZygnR2V0dGluZyBDaGFyYWN0ZXJpc3RpY3MuLi4nKTtcbi8vICAgICAvLyBpZiAoY2hhcmFjdGVyaXN0aWMpIHtcbi8vICAgICAvLyAgIC8vIEdldCBhbGwgY2hhcmFjdGVyaXN0aWNzIHRoYXQgbWF0Y2ggdGhpcyBVVUlELlxuLy8gICAgIC8vICAgcmV0dXJuIHNlcnZpY2UuZ2V0Q2hhcmFjdGVyaXN0aWNzKGNoYXJhY3RlcmlzdGljKTtcbi8vICAgICAvLyB9XG4vLyAgICAgLy8gR2V0IGFsbCBjaGFyYWN0ZXJpc3RpY3MuXG4vLyAgICAgcmV0dXJuIHNlcnZpY2UuZ2V0Q2hhcmFjdGVyaXN0aWMoY2hhcmFjdGVyaXN0aWMpO1xuLy8gICAgIC8vIHJldHVybiBzZXJ2aWNlLmdldENoYXJhY3RlcmlzdGljcygpO1xuLy8gICB9KVxuLy8gICAudGhlbihjaGFyYWN0ZXJpc3RpY3MgPT4ge1xuLy8gICAgIC8vIGNvbnNvbGUubG9nKCc+IENoYXJhY3RlcmlzdGljczogJyArXG4vLyAgICAgLy8gICBjaGFyYWN0ZXJpc3RpY3MubWFwKGMgPT4gYy51dWlkKS5qb2luKCdcXG4nICsgJyAnLnJlcGVhdCgxOSkpKTtcbi8vXG4vLyAgICAgcmV0dXJuIGNoYXJhY3RlcmlzdGljc1swXS5yZWFkVmFsdWUoKTtcbi8vICAgfSlcbi8vICAgLnRoZW4odmFsdWUgPT4ge1xuLy8gICAgIGNvbnNvbGUubG9nKCdCYXR0ZXJ5IHBlcmNlbnRhZ2UgaXMgJyArIHZhbHVlLmdldFVpbnQ4KDApKTtcbi8vICAgfSlcbi8vICAgLmNhdGNoKGVycm9yID0+IHtcbi8vICAgICBjb25zb2xlLmxvZygnQXJnaCEgJyArIGVycm9yKTtcbi8vICAgfSk7XG4vLyB9KTtcblxub2tCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIGNvbnNvbGUubG9nKCdyZWFkOiAnICsgY2hhcmFjdGVyaXN0aWMpO1xuICBibHVlLmdldFZhbHVlKGNoYXJhY3RlcmlzdGljKVxuICAgIC50aGVuKHZhbHVlID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICB9KTtcbiAgLy8gY29uc29sZS5sb2coJ3dyaXRlOiAwMjY2ODNkYS03ZjhiLTExZTYtYWUyMi01NmI2YjY0OTk2MTEnKTtcbiAgLy8gYmx1ZS53cml0ZVZhbHVlKCcwMjY2ODNkYS03ZjhiLTExZTYtYWUyMi01NmI2YjY0OTk2MTEnLCAnb2snKVxuICAvLyAgIC50aGVuKHdyaXRlU3VjY2VzcyA9PiB7XG4gIC8vICAgICBjb25zb2xlLmxvZyh3cml0ZVN1Y2Nlc3MpO1xuICAvLyAgIH0pXG4gIC8vICAgLmNhdGNoKGVycm9yID0+IHtcbiAgLy8gICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgLy8gICB9KTtcbn0pO1xuXG5jb25zb2xlLmxvZygnNycpO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImI1NW1XRVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2Zha2VfM2U5Y2UxODcuanNcIixcIi9cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJiNTVtV0VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5fdXNlVHlwZWRBcnJheXNgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAoY29tcGF0aWJsZSBkb3duIHRvIElFNilcbiAqL1xuQnVmZmVyLl91c2VUeXBlZEFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCBpZiBicm93c2VyIHN1cHBvcnRzIFR5cGVkIEFycmF5cy4gU3VwcG9ydGVkIGJyb3dzZXJzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssXG4gIC8vIENocm9tZSA3KywgU2FmYXJpIDUuMSssIE9wZXJhIDExLjYrLCBpT1MgNC4yKy4gSWYgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhZGRpbmdcbiAgLy8gcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLCB0aGVuIHRoYXQncyB0aGUgc2FtZSBhcyBubyBgVWludDhBcnJheWAgc3VwcG9ydFxuICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBhZGQgYWxsIHRoZSBub2RlIEJ1ZmZlciBBUEkgbWV0aG9kcy4gVGhpcyBpcyBhbiBpc3N1ZVxuICAvLyBpbiBGaXJlZm94IDQtMjkuIE5vdyBmaXhlZDogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4XG4gIHRyeSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigwKVxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gNDIgPT09IGFyci5mb28oKSAmJlxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nIC8vIENocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBXb3JrYXJvdW5kOiBub2RlJ3MgYmFzZTY0IGltcGxlbWVudGF0aW9uIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBzdHJpbmdzXG4gIC8vIHdoaWxlIGJhc2U2NC1qcyBkb2VzIG5vdC5cbiAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JyAmJiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHN1YmplY3QgPSBzdHJpbmd0cmltKHN1YmplY3QpXG4gICAgd2hpbGUgKHN1YmplY3QubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgc3ViamVjdCA9IHN1YmplY3QgKyAnPSdcbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKVxuICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKVxuICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpIC8vIGFzc3VtZSB0aGF0IG9iamVjdCBpcyBhcnJheS1saWtlXG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgdHlwZW9mIHN1YmplY3QuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBTcGVlZCBvcHRpbWl6YXRpb24gLS0gdXNlIHNldCBpZiB3ZSdyZSBjb3B5aW5nIGZyb20gYSB0eXBlZCBhcnJheVxuICAgIGJ1Zi5fc2V0KHN1YmplY3QpXG4gIH0gZWxzZSBpZiAoaXNBcnJheWlzaChzdWJqZWN0KSkge1xuICAgIC8vIFRyZWF0IGFycmF5LWlzaCBvYmplY3RzIGFzIGEgYnl0ZSBhcnJheVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSlcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSlcbiAgICAgIGVsc2VcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdFtpXVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGJ1Zi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBTVEFUSUMgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9PSBudWxsICYmIGIgIT09IHVuZGVmaW5lZCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggLyAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgYXNzZXJ0KGlzQXJyYXkobGlzdCksICdVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbicgK1xuICAgICAgJ2xpc3Qgc2hvdWxkIGJlIGFuIEFycmF5LicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHRvdGFsTGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbi8vIEJVRkZFUiBJTlNUQU5DRSBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBfaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBhc3NlcnQoc3RyTGVuICUgMiA9PT0gMCwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGFzc2VydCghaXNOYU4oYnl0ZSksICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyXG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIF91dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gX2FzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBfYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF91dGYxNmxlV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBfaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gX3V0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBfYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gX2JpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBfYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IF91dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuICBzdGFydCA9IE51bWJlcihzdGFydCkgfHwgMFxuICBlbmQgPSAoZW5kICE9PSB1bmRlZmluZWQpXG4gICAgPyBOdW1iZXIoZW5kKVxuICAgIDogZW5kID0gc2VsZi5sZW5ndGhcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmIChlbmQgPT09IHN0YXJ0KVxuICAgIHJldHVybiAnJ1xuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBfaGV4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gX3V0ZjhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBfYXNjaWlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gX2JpbmFyeVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBfYmFzZTY0U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IF91dGYxNmxlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ3NvdXJjZUVuZCA8IHNvdXJjZVN0YXJ0JylcbiAgYXNzZXJ0KHRhcmdldF9zdGFydCA+PSAwICYmIHRhcmdldF9zdGFydCA8IHRhcmdldC5sZW5ndGgsXG4gICAgICAndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgc291cmNlLmxlbmd0aCwgJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMCB8fCAhQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldF9zdGFydClcbiAgfVxufVxuXG5mdW5jdGlvbiBfYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIF91dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gX2FzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKVxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBfYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gX2FzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKVxufVxuXG5mdW5jdGlvbiBfaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBfdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpKzFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IGNsYW1wKHN0YXJ0LCBsZW4sIDApXG4gIGVuZCA9IGNsYW1wKGVuZCwgbGVuLCBsZW4pXG5cbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRVSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmW29mZnNldF0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMl0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICAgIHZhbCB8PSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXQgKyAzXSA8PCAyNCA+Pj4gMClcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAxXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAyXSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDNdXG4gICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXRdIDw8IDI0ID4+PiAwKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHZhciBuZWcgPSB0aGlzW29mZnNldF0gJiAweDgwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiBfcmVhZEludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IF9yZWFkVUludDE2KGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQzMihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwMDAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRGbG9hdCAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRmxvYXQodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZERvdWJsZSAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmYpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm5cblxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxufVxuXG5mdW5jdGlvbiBfd3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZiwgLTB4ODApXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHRoaXMud3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHRoaXMud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmYsIC0weDgwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICBfd3JpdGVVSW50MTYoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDMyKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQzMihidWYsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLmNoYXJDb2RlQXQoMClcbiAgfVxuXG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSksICd2YWx1ZSBpcyBub3QgYSBudW1iZXInKVxuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLmxlbmd0aCwgJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHRoaXMubGVuZ3RoLCAnZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdGhpc1tpXSA9IHZhbHVlXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3V0ID0gW11cbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKVxuICAgIGlmIChpID09PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLidcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+J1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSlcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBnZXQvc2V0IG1ldGhvZHMgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fZ2V0ID0gYXJyLmdldFxuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuZnVuY3Rpb24gY2xhbXAgKGluZGV4LCBsZW4sIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykgcmV0dXJuIGRlZmF1bHRWYWx1ZVxuICBpbmRleCA9IH5+aW5kZXg7ICAvLyBDb2VyY2UgdG8gaW50ZWdlci5cbiAgaWYgKGluZGV4ID49IGxlbikgcmV0dXJuIGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIGluZGV4ICs9IGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGNvZXJjZSAobGVuZ3RoKSB7XG4gIC8vIENvZXJjZSBsZW5ndGggdG8gYSBudW1iZXIgKHBvc3NpYmx5IE5hTiksIHJvdW5kIHVwXG4gIC8vIGluIGNhc2UgaXQncyBmcmFjdGlvbmFsIChlLmcuIDEyMy40NTYpIHRoZW4gZG8gYVxuICAvLyBkb3VibGUgbmVnYXRlIHRvIGNvZXJjZSBhIE5hTiB0byAwLiBFYXN5LCByaWdodD9cbiAgbGVuZ3RoID0gfn5NYXRoLmNlaWwoK2xlbmd0aClcbiAgcmV0dXJuIGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkgKHN1YmplY3QpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChzdWJqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdWJqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICB9KShzdWJqZWN0KVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKVxuICAgICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBwb3NcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG5cbi8qXG4gKiBXZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGludGVnZXIuIFRoaXMgbWVhbnMgdGhhdCBpdFxuICogaXMgbm9uLW5lZ2F0aXZlLiBJdCBoYXMgbm8gZnJhY3Rpb25hbCBjb21wb25lbnQgYW5kIHRoYXQgaXQgZG9lcyBub3RcbiAqIGV4Y2VlZCB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlLlxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQgKHZhbHVlLCBtYXgpIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlID49IDAsICdzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHZhbHVlIGZvciB0eXBlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZzaW50ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZJRUVFNzU0ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbn1cblxuZnVuY3Rpb24gYXNzZXJ0ICh0ZXN0LCBtZXNzYWdlKSB7XG4gIGlmICghdGVzdCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0ZhaWxlZCBhc3NlcnRpb24nKVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImI1NW1XRVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlclwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImI1NW1XRVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3NcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJiNTVtV0VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9pZWVlNzU0XCIpIl19\n","/*!\n *\n *  Web Starter Kit\n *  Copyright 2015 Google Inc. All rights reserved.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *    https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License\n *\n */\n/* eslint-env browser */\n(function() {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  var isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n      // [::1] is the IPv6 localhost address.\n      window.location.hostname === '[::1]' ||\n      // 127.0.0.1/8 is considered localhost for IPv4.\n      window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n      )\n    );\n\n  if ('serviceWorker' in navigator &&\n      (window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js')\n    .then(function(registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function() {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {\n          // The updatefound event implies that registration.installing is set:\n          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n          var installingWorker = registration.installing;\n\n          installingWorker.onstatechange = function() {\n            switch (installingWorker.state) {\n              case 'installed':\n                // At this point, the old content will have been purged and the\n                // fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in the page's interface.\n                break;\n\n              case 'redundant':\n                throw new Error('The installing ' +\n                                'service worker became redundant.');\n\n              default:\n                // Ignore\n            }\n          };\n        }\n      };\n    }).catch(function(e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nclass PosterDevice {\n\n  constructor() {\n    this.device = null;\n    this.onDisconnected = this.onDisconnected.bind(this);\n  }\n\n  request() {\n    console.log('request');\n    let options = {\n      filters: [{\n        name: 'commService'\n      }],\n      optionalServices: [0x12ab]\n    };\n    return navigator.bluetooth.requestDevice(options)\n    .then(device => {\n      this.device = device;\n      this.device.addEventListener('gattserverdisconnected', this.onDisconnected);\n      return device;\n    });\n  }\n\n  connect() {\n    console.log('connect');\n    if (this.device) {\n      return this.device.gatt.connect();\n    }\n    return Promise.reject('Device is not connected.');\n  }\n\n  writeData(data) {\n    console.log('writeData');\n    return this.device.gatt.getPrimaryService(0x12ab)\n    .then(service => service.getCharacteristic(0x34cd))\n    .then(characteristic => characteristic.writeValue(data));\n  }\n\n  readData() {\n    console.log('readData');\n    return this.device.gatt.getPrimaryService(0x12ab)\n    .then(service => service.getCharacteristic(0x34cd))\n    .then(characteristic => characteristic.readValue());\n  }\n\n  disconnect() {\n    console.log('disconnect');\n    if (this.device) {\n      return this.device.gatt.disconnect();\n    }\n    return Promise.reject('Device is not connected.');\n  }\n\n  onDisconnected() {\n    console.log('onDisconnected');\n    console.log('Device is disconnected.');\n  }\n}\n\nconst posterDevice = new PosterDevice();\nmodule.exports = posterDevice;\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/app/device.js\",\"/app\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n// const BluetoothDevice = require('web-bluetooth');\n// const stateManager = require('./app/state.js');\nconst posterDevice = require('./app/device.js');\n\n// const service = '1ecce4f2-7f9e-11e6-ae22-56b6b6499611';\nconst characteristic = '488d7950-7f9e-11e6-ae22-56b6b6499611';\n\n// const filter = {\n//   name: 'MyDevice',\n//   service: [service]\n// };\nlet blue;\n\nconst connectButton = document.getElementById('js-connect');\n// const disconnectButton = document.getElementById('js-disconnect');\n\nconst okButton = document.getElementById('js-ok');\n\n// connectButton.addEventListener('click', () => {\n//   connectButton.disabled = true;\n//   stateManager.change('connecting');\n//\n//   blue = new BluetoothDevice(filter);\n//   blue.connect()\n//     .then(device => {\n//       console.log(device);\n//       stateManager.change('connected');\n//       connectButton.disabled = false;\n//     })\n//     .catch(error => {\n//       console.log(error);\n//       stateManager.change('init');\n//       connectButton.disabled = false;\n//     });\n// });\n//\n// disconnectButton.addEventListener('click', () => {\n//   if (blue.disconnect()) {\n//     stateManager.change('init');\n//   } else {\n//     console.log('error while disconnect');\n//   }\n// });\n\nconnectButton.addEventListener('click', () => {\n  posterDevice.request()\n  .then(() => posterDevice.connect())\n  .then(() => {\n    return posterDevice.readData();\n  })\n  .then(data => {\n    console.log(data);\n  })\n  .catch(error => {\n    console.log(error);\n  });\n});\n// connectButton.addEventListener('click', () => {\n//   console.log('Requesting Bluetooth Device...');\n//   navigator.bluetooth.requestDevice({\n//     filters: [{services: [service]}]\n//   })\n//   .then(device => {\n//     console.log('Connecting to GATT Server...');\n//     return device.gatt.connect();\n//   })\n//   .then(server => {\n//     console.log('Getting Service...');\n//     return server.getPrimaryService(service);\n//   })\n//   .then(service => {\n//     console.log('Getting Characteristics...');\n//     // if (characteristic) {\n//     //   // Get all characteristics that match this UUID.\n//     //   return service.getCharacteristics(characteristic);\n//     // }\n//     // Get all characteristics.\n//     return service.getCharacteristic(characteristic);\n//     // return service.getCharacteristics();\n//   })\n//   .then(characteristics => {\n//     // console.log('> Characteristics: ' +\n//     //   characteristics.map(c => c.uuid).join('\\n' + ' '.repeat(19)));\n//\n//     return characteristics[0].readValue();\n//   })\n//   .then(value => {\n//     console.log('Battery percentage is ' + value.getUint8(0));\n//   })\n//   .catch(error => {\n//     console.log('Argh! ' + error);\n//   });\n// });\n\nokButton.addEventListener('click', () => {\n  console.log('read: ' + characteristic);\n  blue.getValue(characteristic)\n    .then(value => {\n      console.log(value);\n    });\n  // console.log('write: 026683da-7f8b-11e6-ae22-56b6b6499611');\n  // blue.writeValue('026683da-7f8b-11e6-ae22-56b6b6499611', 'ok')\n  //   .then(writeSuccess => {\n  //     console.log(writeSuccess);\n  //   })\n  //   .catch(error => {\n  //     console.log(error);\n  //   });\n});\n\nconsole.log('7');\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/fake_3e9ce187.js\",\"/\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js\",\"/../../node_modules/gulp-browserify/node_modules/base64-js/lib\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = Buffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192\n\n/**\n * If `Buffer._useTypedArrays`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (compatible down to IE6)\n */\nBuffer._useTypedArrays = (function () {\n  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,\n  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding\n  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support\n  // because we need to be able to add all the node Buffer API methods. This is an issue\n  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438\n  try {\n    var buf = new ArrayBuffer(0)\n    var arr = new Uint8Array(buf)\n    arr.foo = function () { return 42 }\n    return 42 === arr.foo() &&\n        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`\n  } catch (e) {\n    return false\n  }\n})()\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (subject, encoding, noZero) {\n  if (!(this instanceof Buffer))\n    return new Buffer(subject, encoding, noZero)\n\n  var type = typeof subject\n\n  // Workaround: node's base64 implementation allows for non-padded strings\n  // while base64-js does not.\n  if (encoding === 'base64' && type === 'string') {\n    subject = stringtrim(subject)\n    while (subject.length % 4 !== 0) {\n      subject = subject + '='\n    }\n  }\n\n  // Find the length\n  var length\n  if (type === 'number')\n    length = coerce(subject)\n  else if (type === 'string')\n    length = Buffer.byteLength(subject, encoding)\n  else if (type === 'object')\n    length = coerce(subject.length) // assume that object is array-like\n  else\n    throw new Error('First argument needs to be a number, array or string.')\n\n  var buf\n  if (Buffer._useTypedArrays) {\n    // Preferred: Return an augmented `Uint8Array` instance for best performance\n    buf = Buffer._augment(new Uint8Array(length))\n  } else {\n    // Fallback: Return THIS instance of Buffer (created by `new`)\n    buf = this\n    buf.length = length\n    buf._isBuffer = true\n  }\n\n  var i\n  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {\n    // Speed optimization -- use set if we're copying from a typed array\n    buf._set(subject)\n  } else if (isArrayish(subject)) {\n    // Treat array-ish objects as a byte array\n    for (i = 0; i < length; i++) {\n      if (Buffer.isBuffer(subject))\n        buf[i] = subject.readUInt8(i)\n      else\n        buf[i] = subject[i]\n    }\n  } else if (type === 'string') {\n    buf.write(subject, 0, encoding)\n  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {\n    for (i = 0; i < length; i++) {\n      buf[i] = 0\n    }\n  }\n\n  return buf\n}\n\n// STATIC METHODS\n// ==============\n\nBuffer.isEncoding = function (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.isBuffer = function (b) {\n  return !!(b !== null && b !== undefined && b._isBuffer)\n}\n\nBuffer.byteLength = function (str, encoding) {\n  var ret\n  str = str + ''\n  switch (encoding || 'utf8') {\n    case 'hex':\n      ret = str.length / 2\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8ToBytes(str).length\n      break\n    case 'ascii':\n    case 'binary':\n    case 'raw':\n      ret = str.length\n      break\n    case 'base64':\n      ret = base64ToBytes(str).length\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = str.length * 2\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.concat = function (list, totalLength) {\n  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\\n' +\n      'list should be an Array.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  } else if (list.length === 1) {\n    return list[0]\n  }\n\n  var i\n  if (typeof totalLength !== 'number') {\n    totalLength = 0\n    for (i = 0; i < list.length; i++) {\n      totalLength += list[i].length\n    }\n  }\n\n  var buf = new Buffer(totalLength)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\n// BUFFER INSTANCE METHODS\n// =======================\n\nfunction _hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  assert(strLen % 2 === 0, 'Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16)\n    assert(!isNaN(byte), 'Invalid hex string')\n    buf[offset + i] = byte\n  }\n  Buffer._charsWritten = i * 2\n  return i\n}\n\nfunction _utf8Write (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(utf8ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _asciiWrite (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(asciiToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _binaryWrite (buf, string, offset, length) {\n  return _asciiWrite(buf, string, offset, length)\n}\n\nfunction _base64Write (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(base64ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _utf16leWrite (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(utf16leToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nBuffer.prototype.write = function (string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length\n      length = undefined\n    }\n  } else {  // legacy\n    var swap = encoding\n    encoding = offset\n    offset = length\n    length = swap\n  }\n\n  offset = Number(offset) || 0\n  var remaining = this.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase()\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = _hexWrite(this, string, offset, length)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = _utf8Write(this, string, offset, length)\n      break\n    case 'ascii':\n      ret = _asciiWrite(this, string, offset, length)\n      break\n    case 'binary':\n      ret = _binaryWrite(this, string, offset, length)\n      break\n    case 'base64':\n      ret = _base64Write(this, string, offset, length)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = _utf16leWrite(this, string, offset, length)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toString = function (encoding, start, end) {\n  var self = this\n\n  encoding = String(encoding || 'utf8').toLowerCase()\n  start = Number(start) || 0\n  end = (end !== undefined)\n    ? Number(end)\n    : end = self.length\n\n  // Fastpath empty strings\n  if (end === start)\n    return ''\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = _hexSlice(self, start, end)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = _utf8Slice(self, start, end)\n      break\n    case 'ascii':\n      ret = _asciiSlice(self, start, end)\n      break\n    case 'binary':\n      ret = _binarySlice(self, start, end)\n      break\n    case 'base64':\n      ret = _base64Slice(self, start, end)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = _utf16leSlice(self, start, end)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toJSON = function () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function (target, target_start, start, end) {\n  var source = this\n\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (!target_start) target_start = 0\n\n  // Copy 0 bytes; we're done\n  if (end === start) return\n  if (target.length === 0 || source.length === 0) return\n\n  // Fatal error conditions\n  assert(end >= start, 'sourceEnd < sourceStart')\n  assert(target_start >= 0 && target_start < target.length,\n      'targetStart out of bounds')\n  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')\n  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length)\n    end = this.length\n  if (target.length - target_start < end - start)\n    end = target.length - target_start + start\n\n  var len = end - start\n\n  if (len < 100 || !Buffer._useTypedArrays) {\n    for (var i = 0; i < len; i++)\n      target[i + target_start] = this[i + start]\n  } else {\n    target._set(this.subarray(start, start + len), target_start)\n  }\n}\n\nfunction _base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction _utf8Slice (buf, start, end) {\n  var res = ''\n  var tmp = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    if (buf[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])\n      tmp = ''\n    } else {\n      tmp += '%' + buf[i].toString(16)\n    }\n  }\n\n  return res + decodeUtf8Char(tmp)\n}\n\nfunction _asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++)\n    ret += String.fromCharCode(buf[i])\n  return ret\n}\n\nfunction _binarySlice (buf, start, end) {\n  return _asciiSlice(buf, start, end)\n}\n\nfunction _hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction _utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function (start, end) {\n  var len = this.length\n  start = clamp(start, len, 0)\n  end = clamp(end, len, len)\n\n  if (Buffer._useTypedArrays) {\n    return Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    var newBuf = new Buffer(sliceLen, undefined, true)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n    return newBuf\n  }\n}\n\n// `get` will be removed in Node 0.13+\nBuffer.prototype.get = function (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` will be removed in Node 0.13+\nBuffer.prototype.set = function (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nBuffer.prototype.readUInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  return this[offset]\n}\n\nfunction _readUInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    val = buf[offset]\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n  } else {\n    val = buf[offset] << 8\n    if (offset + 1 < len)\n      val |= buf[offset + 1]\n  }\n  return val\n}\n\nBuffer.prototype.readUInt16LE = function (offset, noAssert) {\n  return _readUInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt16BE = function (offset, noAssert) {\n  return _readUInt16(this, offset, false, noAssert)\n}\n\nfunction _readUInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    if (offset + 2 < len)\n      val = buf[offset + 2] << 16\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n    val |= buf[offset]\n    if (offset + 3 < len)\n      val = val + (buf[offset + 3] << 24 >>> 0)\n  } else {\n    if (offset + 1 < len)\n      val = buf[offset + 1] << 16\n    if (offset + 2 < len)\n      val |= buf[offset + 2] << 8\n    if (offset + 3 < len)\n      val |= buf[offset + 3]\n    val = val + (buf[offset] << 24 >>> 0)\n  }\n  return val\n}\n\nBuffer.prototype.readUInt32LE = function (offset, noAssert) {\n  return _readUInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt32BE = function (offset, noAssert) {\n  return _readUInt32(this, offset, false, noAssert)\n}\n\nBuffer.prototype.readInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null,\n        'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  var neg = this[offset] & 0x80\n  if (neg)\n    return (0xff - this[offset] + 1) * -1\n  else\n    return this[offset]\n}\n\nfunction _readInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = _readUInt16(buf, offset, littleEndian, true)\n  var neg = val & 0x8000\n  if (neg)\n    return (0xffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt16LE = function (offset, noAssert) {\n  return _readInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt16BE = function (offset, noAssert) {\n  return _readInt16(this, offset, false, noAssert)\n}\n\nfunction _readInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = _readUInt32(buf, offset, littleEndian, true)\n  var neg = val & 0x80000000\n  if (neg)\n    return (0xffffffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt32LE = function (offset, noAssert) {\n  return _readInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt32BE = function (offset, noAssert) {\n  return _readInt32(this, offset, false, noAssert)\n}\n\nfunction _readFloat (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 23, 4)\n}\n\nBuffer.prototype.readFloatLE = function (offset, noAssert) {\n  return _readFloat(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readFloatBE = function (offset, noAssert) {\n  return _readFloat(this, offset, false, noAssert)\n}\n\nfunction _readDouble (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 52, 8)\n}\n\nBuffer.prototype.readDoubleLE = function (offset, noAssert) {\n  return _readDouble(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readDoubleBE = function (offset, noAssert) {\n  return _readDouble(this, offset, false, noAssert)\n}\n\nBuffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xff)\n  }\n\n  if (offset >= this.length) return\n\n  this[offset] = value\n}\n\nfunction _writeUInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {\n    buf[offset + i] =\n        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n            (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n  _writeUInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n  _writeUInt16(this, value, offset, false, noAssert)\n}\n\nfunction _writeUInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffffffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {\n    buf[offset + i] =\n        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n  _writeUInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n  _writeUInt32(this, value, offset, false, noAssert)\n}\n\nBuffer.prototype.writeInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7f, -0x80)\n  }\n\n  if (offset >= this.length)\n    return\n\n  if (value >= 0)\n    this.writeUInt8(value, offset, noAssert)\n  else\n    this.writeUInt8(0xff + value + 1, offset, noAssert)\n}\n\nfunction _writeInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fff, -0x8000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    _writeUInt16(buf, value, offset, littleEndian, noAssert)\n  else\n    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)\n}\n\nBuffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n  _writeInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n  _writeInt16(this, value, offset, false, noAssert)\n}\n\nfunction _writeInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fffffff, -0x80000000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    _writeUInt32(buf, value, offset, littleEndian, noAssert)\n  else\n    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)\n}\n\nBuffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n  _writeInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n  _writeInt32(this, value, offset, false, noAssert)\n}\n\nfunction _writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n}\n\nBuffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n  _writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n  _writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction _writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 7 < buf.length,\n        'Trying to write beyond buffer length')\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n}\n\nBuffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n  _writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n  _writeDouble(this, value, offset, false, noAssert)\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (typeof value === 'string') {\n    value = value.charCodeAt(0)\n  }\n\n  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')\n  assert(end >= start, 'end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  assert(start >= 0 && start < this.length, 'start out of bounds')\n  assert(end >= 0 && end <= this.length, 'end out of bounds')\n\n  for (var i = start; i < end; i++) {\n    this[i] = value\n  }\n}\n\nBuffer.prototype.inspect = function () {\n  var out = []\n  var len = this.length\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i])\n    if (i === exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...'\n      break\n    }\n  }\n  return '<Buffer ' + out.join(' ') + '>'\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer._useTypedArrays) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1)\n        buf[i] = this[i]\n      return buf.buffer\n    }\n  } else {\n    throw new Error('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function (arr) {\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array get/set methods before overwriting\n  arr._get = arr.get\n  arr._set = arr.set\n\n  // deprecated, will be removed in node 0.13+\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\n// slice(start, end)\nfunction clamp (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index;  // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\n\nfunction coerce (length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it's fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length)\n  return length < 0 ? 0 : length\n}\n\nfunction isArray (subject) {\n  return (Array.isArray || function (subject) {\n    return Object.prototype.toString.call(subject) === '[object Array]'\n  })(subject)\n}\n\nfunction isArrayish (subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n      subject && typeof subject === 'object' &&\n      typeof subject.length === 'number'\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    var b = str.charCodeAt(i)\n    if (b <= 0x7F)\n      byteArray.push(str.charCodeAt(i))\n    else {\n      var start = i\n      if (b >= 0xD800 && b <= 0xDFFF) i++\n      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16))\n    }\n  }\n  return byteArray\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(str)\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  var pos\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length))\n      break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction decodeUtf8Char (str) {\n  try {\n    return decodeURIComponent(str)\n  } catch (err) {\n    return String.fromCharCode(0xFFFD) // UTF 8 invalid char\n  }\n}\n\n/*\n * We have to make sure that the value is a valid integer. This means that it\n * is non-negative. It has no fractional component and that it does not\n * exceed the maximum allowed value.\n */\nfunction verifuint (value, max) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value >= 0, 'specified a negative value for writing an unsigned value')\n  assert(value <= max, 'value is larger than maximum value for type')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifsint (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifIEEE754 (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n}\n\nfunction assert (test, message) {\n  if (!test) throw new Error(message || 'Failed assertion')\n}\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/gulp-browserify/node_modules/buffer/index.js\",\"/../../node_modules/gulp-browserify/node_modules/buffer\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/gulp-browserify/node_modules/process/browser.js\",\"/../../node_modules/gulp-browserify/node_modules/process\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/ieee754/index.js\",\"/../../node_modules/ieee754\")","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})"],"sourceRoot":"/source/"}
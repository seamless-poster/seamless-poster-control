{"version":3,"sources":["main.min.js","/source/main.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/app/scripts/app/device.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/app/scripts/fake_e5f40b29.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/buffer/index.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/process/browser.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/ieee754/index.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/browser-pack/_prelude.js"],"names":["_classCallCheck","instance","Constructor","TypeError","isLocalhost","Boolean","window","location","hostname","match","navigator","protocol","serviceWorker","register","then","registration","onupdatefound","controller","installingWorker","installing","onstatechange","state","Error","e","console","error","_typeof","Symbol","iterator","obj","constructor","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","t","n","r","s","o","u","a","require","f","exports","call","1","module","process","global","Buffer","__argument0","__argument1","__argument2","__argument3","__filename","__dirname","PosterDevice","this","device","onDisconnected","bind","value","_this","log","options","filters","name","bluetooth","requestDevice","addEventListener","gatt","connect","Promise","reject","data","getPrimaryService","service","getCharacteristic","characteristic","writeValue","disconnect","posterDevice","self","arguments","b55mWE","buffer","2","blue","connectButton","document","getElementById","okButton","request","writeColor","getValue","./app/device.js","3","lookup","decode","elt","code","charCodeAt","PLUS","PLUS_URL_SAFE","SLASH","SLASH_URL_SAFE","NUMBER","UPPER","LOWER","b64ToByteArray","b64","push","v","arr","L","j","l","tmp","placeHolders","len","charAt","Arr","uint8ToBase64","uint8","encode","num","tripletToBase64","temp","extraBytes","output","Uint8Array","Array","toByteArray","fromByteArray","base64js","4","subject","encoding","noZero","type","stringtrim","coerce","byteLength","buf","_useTypedArrays","_augment","_isBuffer","_set","isArrayish","isBuffer","readUInt8","write","_hexWrite","string","offset","Number","remaining","strLen","assert","byte","parseInt","substr","isNaN","_charsWritten","_utf8Write","charsWritten","blitBuffer","utf8ToBytes","_asciiWrite","asciiToBytes","_binaryWrite","_base64Write","base64ToBytes","_utf16leWrite","utf16leToBytes","_base64Slice","start","end","base64","slice","_utf8Slice","res","Math","min","decodeUtf8Char","String","fromCharCode","toString","_asciiSlice","ret","_binarySlice","_hexSlice","out","toHex","_utf16leSlice","bytes","_readUInt16","littleEndian","noAssert","undefined","val","_readUInt32","_readInt16","neg","_readInt32","_readFloat","ieee754","read","_readDouble","_writeUInt16","verifuint","_writeUInt32","_writeInt16","verifsint","_writeInt32","_writeFloat","verifIEEE754","_writeDouble","str","trim","replace","clamp","index","defaultValue","ceil","isArray","byteArray","b","h","encodeURIComponent","split","c","hi","lo","src","dst","decodeURIComponent","err","max","floor","test","message","SlowBuffer","INSPECT_MAX_BYTES","poolSize","ArrayBuffer","foo","subarray","isEncoding","toLowerCase","concat","list","totalLength","pos","item","copy","isFinite","swap","toJSON","_arr","target_start","source","sliceLen","newBuf","get","set","writeUInt8","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","fill","inspect","join","toArrayBuffer","BP","_get","toLocaleString","base64-js","5","noop","nextTick","canSetImmediate","setImmediate","canPost","postMessage","queue","ev","stopPropagation","fn","shift","setTimeout","title","browser","env","argv","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","6","isLE","mLen","nBytes","m","eLen","eMax","eBias","nBits","d","NaN","Infinity","pow","rt","abs","LN2"],"mappings":"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AA,aACAqK,EAAArK,EACA,UACAE,GAAAM,OAAAA,EACAN,EAAAuM,WAAAjM,EACAN,EAAAwM,kBAAA,GACAlM,EAAAmM,SACA,KAMAnM,EAAA+F,gBAAA,WL8XQ,IACE,GAAID,GAAM,GAAIsG,aKvXxB,GLwXcpI,EAAM,GAAIiB,YKvXxBa,ELyXU,OADA9B,GAAIqI,IAAM,WAAa,MAAO,KACvB,KAAOrI,EKvXxBqI,OLwXkC,kBAAjBrI,GAAIsI,SACX,MAAO7O,GACP,OKvXV,MA8EAuC,EAAAuM,WAAA,SAAA/G,GLyXQ,OAAQgD,OAAOhD,GKvXvBgH,eLwXU,IKvXV,MLwXU,IKvXV,OLwXU,IKvXV,QLwXU,IKvXV,QLwXU,IKvXV,SLwXU,IKvXV,SLwXU,IKvXV,MLwXU,IKvXV,OLwXU,IKvXV,QLwXU,IKvXV,ULwXU,IKvXV,WLwXY,OKvXZ,CACA,SLwXY,OKvXZ,IAGAxM,EAAAoG,SAAA,SAAA8E,GLyXQ,QAAgB,OAANA,GAAoB5B,SAAN4B,IAAmBA,EKvXnDjF,YAEAjG,EAAA6F,WAAA,SAAA4E,EAAAjF,GLyXQ,GKvXRoD,ELyXQ,QADA6B,GKvXR,GLwXgBjF,GKvXhB,QLwXU,IKvXV,MLwXYoD,EAAM6B,EAAInM,OKvXtB,CACA,MLwXU,KKvXV,OLwXU,IKvXV,QLwXYsK,EAAMtB,EAAYmD,GKvX9BnM,MACA,MLwXU,KKvXV,QLwXU,IKvXV,SLwXU,IKvXV,MLwXYsK,EAAM6B,EKvXlBnM,MACA,MLwXU,KKvXV,SLwXYsK,EAAMjB,EAAc8C,GKvXhCnM,MACA,MLwXU,KKvXV,OLwXU,IKvXV,QLwXU,IKvXV,ULwXU,IKvXV,WLwXYsK,EKvXZ,ELuXkB6B,EAAInM,MKtXtB,MACA,SLwXY,KAAM,IAAId,OKvXtB,oBLyXQ,MKvXRoL,IAEA5I,EAAAyM,OAAA,SAAAC,EAAAC,GL4XQ,GAHA9F,EAAOmE,EAAQ0B,GKvXvB,uEL0X4B,IAAhBA,EAAKpO,OACP,MAAO,IAAI0B,GKvXrB,ELwXe,IAAoB,IAAhB0M,EAAKpO,OACd,MAAOoO,GKvXjB,EL0XQ,IKvXRrO,ELwXQ,IAA2B,gBAAhBsO,G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A,GAAIiC,WKvXZ,EL0XQjC,EAAIyL,KAAOzL,EKvXnBuJ,ILwXQvJ,EAAIkC,KAAOlC,EKvXnBwJ,IL0XQxJ,EAAIuJ,IAAMiC,EKvXlBjC,ILwXQvJ,EAAIwJ,IAAMgC,EKvXlBhC,ILyXQxJ,EAAIsC,MAAQkJ,EKvXpBlJ,MLwXQtC,EAAI0E,SAAW8G,EKvXvB9G,SLwXQ1E,EAAI0L,eAAiBF,EKvX7B9G,SLwXQ1E,EAAIiJ,OAASuC,EKvXrBvC,OLwXQjJ,EAAI8I,KAAO0C,EKvXnB1C,KLwXQ9I,EAAIkE,MAAQsH,EKvXpBtH,MLwXQlE,EAAIqC,UAAYmJ,EKvXxBnJ,ULwXQrC,EAAI0J,aAAe8B,EKvX3B9B,aLwXQ1J,EAAI2J,aAAe6B,EKvX3B7B,aLwXQ3J,EAAI4J,aAAe4B,EKvX3B5B,aLwXQ5J,EAAI6J,aAAe2B,EKvX3B3B,aLwXQ7J,EAAI8J,SAAW0B,EKvXvB1B,SLwXQ9J,EAAI+J,YAAcyB,EKvX1BzB,YLwXQ/J,EAAIgK,YAAcwB,EKvX1BxB,YLwXQhK,EAAIiK,YAAcuB,EKvX1BvB,YLwXQjK,EAAIkK,YAAcsB,EKvX1BtB,YLwXQlK,EAAImK,YAAcqB,EKvX1BrB,YLwXQnK,EAAIoK,YAAcoB,EKvX1BpB,YLwXQpK,EAAIqK,aAAemB,EKvX3BnB,aLwXQrK,EAAIsK,aAAekB,EKvX3BlB,aLwXQtK,EAAIyJ,WAAa+B,EKvXzB/B,WLwXQzJ,EAAIuK,cAAgBiB,EKvX5BjB,cLwXQvK,EAAIwK,cAAgBgB,EKvX5BhB,cLwXQxK,EAAIyK,cAAgBe,EKvX5Bf,cLwXQzK,EAAI0K,cAAgBc,EKvX5Bd,cLwXQ1K,EAAI2K,UAAYa,EKvXxBb,ULwXQ3K,EAAI4K,aAAeY,EKvX3BZ,aLwXQ5K,EAAI6K,aAAeW,EKvX3BX,aLwXQ7K,EAAI8K,aAAeU,EKvX3BV,aLwXQ9K,EAAI+K,aAAeS,EKvX3BT,aLwXQ/K,EAAIgL,aAAeQ,EKvX3BR,aLwXQhL,EAAIiL,aAAeO,EKvX3BP,aLwXQjL,EAAIkL,cAAgBM,EKvX5BN,cLwXQlL,EAAImL,cAAgBK,EKvX5BL,cLwXQnL,EAAIoL,KAAOI,EK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","file":"main.min.js","sourcesContent":["'use strict'; /*!\n               *\n               *  Web Starter Kit\n               *  Copyright 2015 Google Inc. All rights reserved.\n               *\n               *  Licensed under the Apache License, Version 2.0 (the \"License\");\n               *  you may not use this file except in compliance with the License.\n               *  You may obtain a copy of the License at\n               *\n               *    https://www.apache.org/licenses/LICENSE-2.0\n               *\n               *  Unless required by applicable law or agreed to in writing, software\n               *  distributed under the License is distributed on an \"AS IS\" BASIS,\n               *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n               *  See the License for the specific language governing permissions and\n               *  limitations under the License\n               *\n               */\n/* eslint-env browser */\n(function () {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  var isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.1/8 is considered localhost for IPv4.\n  window.location.hostname.match(\n  /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));\n\n\n\n  if ('serviceWorker' in navigator && (\n  window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js').\n    then(function (registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function () {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {\n          // The updatefound event implies that registration.installing is set:\n          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n          var installingWorker = registration.installing;\n\n          installingWorker.onstatechange = function () {\n            switch (installingWorker.state) {\n              case 'installed':\n                // At this point, the old content will have been purged and the\n                // fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in the page's interface.\n                break;\n\n              case 'redundant':\n                throw new Error('The installing ' +\n                'service worker became redundant.');\n\n              default:\n              // Ignore\n            }\n          };\n        }\n      };\n    }).catch(function (e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uanMiXSwibmFtZXMiOlsiaXNMb2NhbGhvc3QiLCJCb29sZWFuIiwid2luZG93IiwibG9jYXRpb24iLCJob3N0bmFtZSIsIm1hdGNoIiwibmF2aWdhdG9yIiwicHJvdG9jb2wiLCJzZXJ2aWNlV29ya2VyIiwicmVnaXN0ZXIiLCJ0aGVuIiwicmVnaXN0cmF0aW9uIiwib251cGRhdGVmb3VuZCIsImNvbnRyb2xsZXIiLCJpbnN0YWxsaW5nV29ya2VyIiwiaW5zdGFsbGluZyIsIm9uc3RhdGVjaGFuZ2UiLCJzdGF0ZSIsIkVycm9yIiwiY2F0Y2giLCJlIiwiY29uc29sZSIsImVycm9yIl0sIm1hcHBpbmdzIjoiY0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBO0FBQ0EsQ0FBQyxZQUFXO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJQSxjQUFjQyxRQUFRQyxPQUFPQyxRQUFQLENBQWdCQyxRQUFoQixLQUE2QixXQUE3QjtBQUN0QjtBQUNBRixTQUFPQyxRQUFQLENBQWdCQyxRQUFoQixLQUE2QixPQUZQO0FBR3RCO0FBQ0FGLFNBQU9DLFFBQVAsQ0FBZ0JDLFFBQWhCLENBQXlCQyxLQUF6QjtBQUNFLDBEQURGLENBSmMsQ0FBbEI7Ozs7QUFTQSxNQUFJLG1CQUFtQkMsU0FBbkI7QUFDQ0osU0FBT0MsUUFBUCxDQUFnQkksUUFBaEIsS0FBNkIsUUFBN0IsSUFBeUNQLFdBRDFDLENBQUosRUFDNEQ7QUFDMURNLGNBQVVFLGFBQVYsQ0FBd0JDLFFBQXhCLENBQWlDLG1CQUFqQztBQUNDQyxRQURELENBQ00sVUFBU0MsWUFBVCxFQUF1QjtBQUMzQjtBQUNBQSxtQkFBYUMsYUFBYixHQUE2QixZQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSU4sVUFBVUUsYUFBVixDQUF3QkssVUFBNUIsRUFBd0M7QUFDdEM7QUFDQTtBQUNBLGNBQUlDLG1CQUFtQkgsYUFBYUksVUFBcEM7O0FBRUFELDJCQUFpQkUsYUFBakIsR0FBaUMsWUFBVztBQUMxQyxvQkFBUUYsaUJBQWlCRyxLQUF6QjtBQUNFLG1CQUFLLFdBQUw7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVGLG1CQUFLLFdBQUw7QUFDRSxzQkFBTSxJQUFJQyxLQUFKLENBQVU7QUFDQSxrREFEVixDQUFOOztBQUdGO0FBQ0U7QUFiSjtBQWVELFdBaEJEO0FBaUJEO0FBQ0YsT0E1QkQ7QUE2QkQsS0FoQ0QsRUFnQ0dDLEtBaENILENBZ0NTLFVBQVNDLENBQVQsRUFBWTtBQUNuQkMsY0FBUUMsS0FBUixDQUFjLDJDQUFkLEVBQTJERixDQUEzRDtBQUNELEtBbENEO0FBbUNEOztBQUVEO0FBQ0QsQ0F4REQiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICpcbiAqICBXZWIgU3RhcnRlciBLaXRcbiAqICBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlXG4gKlxuICovXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENoZWNrIHRvIG1ha2Ugc3VyZSBzZXJ2aWNlIHdvcmtlcnMgYXJlIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyLFxuICAvLyBhbmQgdGhhdCB0aGUgY3VycmVudCBwYWdlIGlzIGFjY2Vzc2VkIGZyb20gYSBzZWN1cmUgb3JpZ2luLiBVc2luZyBhXG4gIC8vIHNlcnZpY2Ugd29ya2VyIGZyb20gYW4gaW5zZWN1cmUgb3JpZ2luIHdpbGwgdHJpZ2dlciBKUyBjb25zb2xlIGVycm9ycy4gU2VlXG4gIC8vIGh0dHA6Ly93d3cuY2hyb21pdW0ub3JnL0hvbWUvY2hyb21pdW0tc2VjdXJpdHkvcHJlZmVyLXNlY3VyZS1vcmlnaW5zLWZvci1wb3dlcmZ1bC1uZXctZmVhdHVyZXNcbiAgdmFyIGlzTG9jYWxob3N0ID0gQm9vbGVhbih3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnIHx8XG4gICAgICAvLyBbOjoxXSBpcyB0aGUgSVB2NiBsb2NhbGhvc3QgYWRkcmVzcy5cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gJ1s6OjFdJyB8fFxuICAgICAgLy8gMTI3LjAuMC4xLzggaXMgY29uc2lkZXJlZCBsb2NhbGhvc3QgZm9yIElQdjQuXG4gICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUubWF0Y2goXG4gICAgICAgIC9eMTI3KD86XFwuKD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSl7M30kL1xuICAgICAgKVxuICAgICk7XG5cbiAgaWYgKCdzZXJ2aWNlV29ya2VyJyBpbiBuYXZpZ2F0b3IgJiZcbiAgICAgICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonIHx8IGlzTG9jYWxob3N0KSkge1xuICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKCdzZXJ2aWNlLXdvcmtlci5qcycpXG4gICAgLnRoZW4oZnVuY3Rpb24ocmVnaXN0cmF0aW9uKSB7XG4gICAgICAvLyB1cGRhdGVmb3VuZCBpcyBmaXJlZCBpZiBzZXJ2aWNlLXdvcmtlci5qcyBjaGFuZ2VzLlxuICAgICAgcmVnaXN0cmF0aW9uLm9udXBkYXRlZm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gdXBkYXRlZm91bmQgaXMgYWxzbyBmaXJlZCB0aGUgdmVyeSBmaXJzdCB0aW1lIHRoZSBTVyBpcyBpbnN0YWxsZWQsXG4gICAgICAgIC8vIGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gcHJvbXB0IGZvciBhIHJlbG9hZCBhdCB0aGF0IHBvaW50LlxuICAgICAgICAvLyBTbyBjaGVjayBoZXJlIHRvIHNlZSBpZiB0aGUgcGFnZSBpcyBhbHJlYWR5IGNvbnRyb2xsZWQsXG4gICAgICAgIC8vIGkuZS4gd2hldGhlciB0aGVyZSdzIGFuIGV4aXN0aW5nIHNlcnZpY2Ugd29ya2VyLlxuICAgICAgICBpZiAobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xuICAgICAgICAgIC8vIFRoZSB1cGRhdGVmb3VuZCBldmVudCBpbXBsaWVzIHRoYXQgcmVnaXN0cmF0aW9uLmluc3RhbGxpbmcgaXMgc2V0OlxuICAgICAgICAgIC8vIGh0dHBzOi8vc2xpZ2h0bHlvZmYuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvc3BlYy9zZXJ2aWNlX3dvcmtlci9pbmRleC5odG1sI3NlcnZpY2Utd29ya2VyLWNvbnRhaW5lci11cGRhdGVmb3VuZC1ldmVudFxuICAgICAgICAgIHZhciBpbnN0YWxsaW5nV29ya2VyID0gcmVnaXN0cmF0aW9uLmluc3RhbGxpbmc7XG5cbiAgICAgICAgICBpbnN0YWxsaW5nV29ya2VyLm9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5zdGFsbGluZ1dvcmtlci5zdGF0ZSkge1xuICAgICAgICAgICAgICBjYXNlICdpbnN0YWxsZWQnOlxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBvbGQgY29udGVudCB3aWxsIGhhdmUgYmVlbiBwdXJnZWQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGZyZXNoIGNvbnRlbnQgd2lsbCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgIC8vIEl0J3MgdGhlIHBlcmZlY3QgdGltZSB0byBkaXNwbGF5IGEgXCJOZXcgY29udGVudCBpc1xuICAgICAgICAgICAgICAgIC8vIGF2YWlsYWJsZTsgcGxlYXNlIHJlZnJlc2guXCIgbWVzc2FnZSBpbiB0aGUgcGFnZSdzIGludGVyZmFjZS5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdyZWR1bmRhbnQnOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluc3RhbGxpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZXJ2aWNlIHdvcmtlciBiZWNhbWUgcmVkdW5kYW50LicpO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uOicsIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gWW91ciBjdXN0b20gSmF2YVNjcmlwdCBnb2VzIGhlcmVcbn0pKCk7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=\n\n\"use strict\";var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {return typeof obj;} : function (obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;};var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}(function e(t, n, r) {function s(o, u) {if (!n[o]) {if (!t[o]) {var a = typeof require == \"function\" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);throw new Error(\"Cannot find module '\" + o + \"'\");}var f = n[o] = { exports: {} };t[o][0].call(f.exports, function (e) {var n = t[o][1][e];return s(n ? n : e);}, f, f.exports, e, t, n, r);}return n[o].exports;}var i = typeof require == \"function\" && require;for (var o = 0; o < r.length; o++) {s(r[o]);}return s;})({ 1: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {var\n      PosterDevice = function () {\n\n        function PosterDevice() {_classCallCheck(this, PosterDevice);\n          this.device = null;\n          this.onDisconnected = this.onDisconnected.bind(this);\n        }_createClass(PosterDevice, [{ key: \"request\", value: function request()\n\n          {var _this = this;\n            console.log('request');\n            var options = {\n              filters: [{\n                name: 'test' }] };\n\n\n            return navigator.bluetooth.requestDevice(options).\n            then(function (device) {\n              _this.device = device;\n              _this.device.addEventListener('gattserverdisconnected', _this.onDisconnected);\n              return device;\n            });\n          } }, { key: \"connect\", value: function connect()\n\n          {\n            console.log('connect');\n            if (this.device) {\n              return this.device.gatt.connect();\n            }\n            return Promise.reject('Device is not connected.');\n          } }, { key: \"writeColor\", value: function writeColor(\n\n          data) {\n            console.log('writeColor');\n            return this.device.gatt.getPrimaryService(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0).\n            then(function (service) {return service.getCharacteristic(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4);}).\n            then(function (characteristic) {return characteristic.writeValue(data);});\n          } }, { key: \"disconnect\", value: function disconnect()\n\n          {\n            console.log('disconnect');\n            if (this.device) {\n              return this.device.gatt.disconnect();\n            }\n            return Promise.reject('Device is not connected.');\n          } }, { key: \"onDisconnected\", value: function onDisconnected()\n\n          {\n            console.log('onDisconnected');\n            console.log('Device is disconnected.');\n          } }]);return PosterDevice;}();\n\n\n      var posterDevice = new PosterDevice();\n      module.exports = posterDevice;\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/app/device.js\", \"/app\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }], 2: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      // const BluetoothDevice = require('web-bluetooth');\n      // const stateManager = require('./app/state.js');\n      var posterDevice = require('./app/device.js');\n\n      // const service = '1ecce4f2-7f9e-11e6-ae22-56b6b6499611';\n      var characteristic = '488d7950-7f9e-11e6-ae22-56b6b6499611';\n\n      // const filter = {\n      //   name: 'MyDevice',\n      //   service: [service]\n      // };\n      var blue = void 0;\n\n      var connectButton = document.getElementById('js-connect');\n      // const disconnectButton = document.getElementById('js-disconnect');\n\n      var okButton = document.getElementById('js-ok');\n\n      // connectButton.addEventListener('click', () => {\n      //   connectButton.disabled = true;\n      //   stateManager.change('connecting');\n      //\n      //   blue = new BluetoothDevice(filter);\n      //   blue.connect()\n      //     .then(device => {\n      //       console.log(device);\n      //       stateManager.change('connected');\n      //       connectButton.disabled = false;\n      //     })\n      //     .catch(error => {\n      //       console.log(error);\n      //       stateManager.change('init');\n      //       connectButton.disabled = false;\n      //     });\n      // });\n      //\n      // disconnectButton.addEventListener('click', () => {\n      //   if (blue.disconnect()) {\n      //     stateManager.change('init');\n      //   } else {\n      //     console.log('error while disconnect');\n      //   }\n      // });\n\n      connectButton.addEventListener('click', function () {\n        posterDevice.request().\n        then(function () {return posterDevice.connect();}).\n        then(function () {\n          posterDevice.writeColor('001122');\n        }).\n        catch(function (error) {\n          console.log(error);\n        });\n      });\n      // connectButton.addEventListener('click', () => {\n      //   console.log('Requesting Bluetooth Device...');\n      //   navigator.bluetooth.requestDevice({\n      //     filters: [{services: [service]}]\n      //   })\n      //   .then(device => {\n      //     console.log('Connecting to GATT Server...');\n      //     return device.gatt.connect();\n      //   })\n      //   .then(server => {\n      //     console.log('Getting Service...');\n      //     return server.getPrimaryService(service);\n      //   })\n      //   .then(service => {\n      //     console.log('Getting Characteristics...');\n      //     // if (characteristic) {\n      //     //   // Get all characteristics that match this UUID.\n      //     //   return service.getCharacteristics(characteristic);\n      //     // }\n      //     // Get all characteristics.\n      //     return service.getCharacteristic(characteristic);\n      //     // return service.getCharacteristics();\n      //   })\n      //   .then(characteristics => {\n      //     // console.log('> Characteristics: ' +\n      //     //   characteristics.map(c => c.uuid).join('\\n' + ' '.repeat(19)));\n      //\n      //     return characteristics[0].readValue();\n      //   })\n      //   .then(value => {\n      //     console.log('Battery percentage is ' + value.getUint8(0));\n      //   })\n      //   .catch(error => {\n      //     console.log('Argh! ' + error);\n      //   });\n      // });\n\n      okButton.addEventListener('click', function () {\n        console.log('read: ' + characteristic);\n        blue.getValue(characteristic).\n        then(function (value) {\n          console.log(value);\n        });\n        // console.log('write: 026683da-7f8b-11e6-ae22-56b6b6499611');\n        // blue.writeValue('026683da-7f8b-11e6-ae22-56b6b6499611', 'ok')\n        //   .then(writeSuccess => {\n        //     console.log(writeSuccess);\n        //   })\n        //   .catch(error => {\n        //     console.log(error);\n        //   });\n      });\n\n      console.log('3');\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/fake_e5f40b29.js\", \"/\");\n  }, { \"./app/device.js\": 1, \"b55mWE\": 5, \"buffer\": 4 }], 3: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n      ;(function (exports) {\n        'use strict';\n\n        var Arr = typeof Uint8Array !== 'undefined' ?\n        Uint8Array :\n        Array;\n\n        var PLUS = '+'.charCodeAt(0);\n        var SLASH = '/'.charCodeAt(0);\n        var NUMBER = '0'.charCodeAt(0);\n        var LOWER = 'a'.charCodeAt(0);\n        var UPPER = 'A'.charCodeAt(0);\n        var PLUS_URL_SAFE = '-'.charCodeAt(0);\n        var SLASH_URL_SAFE = '_'.charCodeAt(0);\n\n        function decode(elt) {\n          var code = elt.charCodeAt(0);\n          if (code === PLUS ||\n          code === PLUS_URL_SAFE)\n          return 62; // '+'\n          if (code === SLASH ||\n          code === SLASH_URL_SAFE)\n          return 63; // '/'\n          if (code < NUMBER)\n          return -1; //no match\n          if (code < NUMBER + 10)\n          return code - NUMBER + 26 + 26;\n          if (code < UPPER + 26)\n          return code - UPPER;\n          if (code < LOWER + 26)\n          return code - LOWER + 26;\n        }\n\n        function b64ToByteArray(b64) {\n          var i, j, l, tmp, placeHolders, arr;\n\n          if (b64.length % 4 > 0) {\n            throw new Error('Invalid string. Length must be a multiple of 4');\n          }\n\n          // the number of equal signs (place holders)\n          // if there are two placeholders, than the two characters before it\n          // represent one byte\n          // if there is only one, then the three characters before it represent 2 bytes\n          // this is just a cheap hack to not do indexOf twice\n          var len = b64.length;\n          placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;\n\n          // base64 is 4/3 + up to two characters of the original data\n          arr = new Arr(b64.length * 3 / 4 - placeHolders);\n\n          // if there are placeholders, only get up to the last complete 4 chars\n          l = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n          var L = 0;\n\n          function push(v) {\n            arr[L++] = v;\n          }\n\n          for (i = 0, j = 0; i < l; i += 4, j += 3) {\n            tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));\n            push((tmp & 0xFF0000) >> 16);\n            push((tmp & 0xFF00) >> 8);\n            push(tmp & 0xFF);\n          }\n\n          if (placeHolders === 2) {\n            tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;\n            push(tmp & 0xFF);\n          } else if (placeHolders === 1) {\n            tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;\n            push(tmp >> 8 & 0xFF);\n            push(tmp & 0xFF);\n          }\n\n          return arr;\n        }\n\n        function uint8ToBase64(uint8) {\n          var i,\n          extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n          output = \"\",\n          temp,length;\n\n          function encode(num) {\n            return lookup.charAt(num);\n          }\n\n          function tripletToBase64(num) {\n            return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);\n          }\n\n          // go through the array every three bytes, we'll deal with trailing stuff later\n          for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n            temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n            output += tripletToBase64(temp);\n          }\n\n          // pad the end with zeros, but make sure to not forget the extra bytes\n          switch (extraBytes) {\n            case 1:\n              temp = uint8[uint8.length - 1];\n              output += encode(temp >> 2);\n              output += encode(temp << 4 & 0x3F);\n              output += '==';\n              break;\n            case 2:\n              temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];\n              output += encode(temp >> 10);\n              output += encode(temp >> 4 & 0x3F);\n              output += encode(temp << 2 & 0x3F);\n              output += '=';\n              break;}\n\n\n          return output;\n        }\n\n        exports.toByteArray = b64ToByteArray;\n        exports.fromByteArray = uint8ToBase64;\n      })(typeof exports === 'undefined' ? this.base64js = {} : exports);\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js\", \"/../../node_modules/gulp-browserify/node_modules/base64-js/lib\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }], 4: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      /*!\n                                                                                                                     * The buffer module from node.js, for the browser.\n                                                                                                                     *\n                                                                                                                     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n                                                                                                                     * @license  MIT\n                                                                                                                     */\n\n      var base64 = require('base64-js');\n      var ieee754 = require('ieee754');\n\n      exports.Buffer = Buffer;\n      exports.SlowBuffer = Buffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      Buffer.poolSize = 8192;\n\n      /**\n                               * If `Buffer._useTypedArrays`:\n                               *   === true    Use Uint8Array implementation (fastest)\n                               *   === false   Use Object implementation (compatible down to IE6)\n                               */\n      Buffer._useTypedArrays = function () {\n        // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,\n        // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding\n        // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support\n        // because we need to be able to add all the node Buffer API methods. This is an issue\n        // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438\n        try {\n          var buf = new ArrayBuffer(0);\n          var arr = new Uint8Array(buf);\n          arr.foo = function () {return 42;};\n          return 42 === arr.foo() &&\n          typeof arr.subarray === 'function'; // Chrome 9-10 lack `subarray`\n        } catch (e) {\n          return false;\n        }\n      }();\n\n      /**\n            * Class: Buffer\n            * =============\n            *\n            * The Buffer constructor returns instances of `Uint8Array` that are augmented\n            * with function properties for all the node `Buffer` API functions. We use\n            * `Uint8Array` so that square bracket notation works as expected -- it returns\n            * a single octet.\n            *\n            * By augmenting the instances, we can avoid modifying the `Uint8Array`\n            * prototype.\n            */\n      function Buffer(subject, encoding, noZero) {\n        if (!(this instanceof Buffer))\n        return new Buffer(subject, encoding, noZero);\n\n        var type = typeof subject === \"undefined\" ? \"undefined\" : _typeof(subject);\n\n        // Workaround: node's base64 implementation allows for non-padded strings\n        // while base64-js does not.\n        if (encoding === 'base64' && type === 'string') {\n          subject = stringtrim(subject);\n          while (subject.length % 4 !== 0) {\n            subject = subject + '=';\n          }\n        }\n\n        // Find the length\n        var length;\n        if (type === 'number')\n        length = coerce(subject);else\n        if (type === 'string')\n        length = Buffer.byteLength(subject, encoding);else\n        if (type === 'object')\n        length = coerce(subject.length); // assume that object is array-like\n        else\n          throw new Error('First argument needs to be a number, array or string.');\n\n        var buf;\n        if (Buffer._useTypedArrays) {\n          // Preferred: Return an augmented `Uint8Array` instance for best performance\n          buf = Buffer._augment(new Uint8Array(length));\n        } else {\n          // Fallback: Return THIS instance of Buffer (created by `new`)\n          buf = this;\n          buf.length = length;\n          buf._isBuffer = true;\n        }\n\n        var i;\n        if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {\n          // Speed optimization -- use set if we're copying from a typed array\n          buf._set(subject);\n        } else if (isArrayish(subject)) {\n          // Treat array-ish objects as a byte array\n          for (i = 0; i < length; i++) {\n            if (Buffer.isBuffer(subject))\n            buf[i] = subject.readUInt8(i);else\n\n            buf[i] = subject[i];\n          }\n        } else if (type === 'string') {\n          buf.write(subject, 0, encoding);\n        } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {\n          for (i = 0; i < length; i++) {\n            buf[i] = 0;\n          }\n        }\n\n        return buf;\n      }\n\n      // STATIC METHODS\n      // ==============\n\n      Buffer.isEncoding = function (encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case 'hex':\n          case 'utf8':\n          case 'utf-8':\n          case 'ascii':\n          case 'binary':\n          case 'base64':\n          case 'raw':\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            return true;\n          default:\n            return false;}\n\n      };\n\n      Buffer.isBuffer = function (b) {\n        return !!(b !== null && b !== undefined && b._isBuffer);\n      };\n\n      Buffer.byteLength = function (str, encoding) {\n        var ret;\n        str = str + '';\n        switch (encoding || 'utf8') {\n          case 'hex':\n            ret = str.length / 2;\n            break;\n          case 'utf8':\n          case 'utf-8':\n            ret = utf8ToBytes(str).length;\n            break;\n          case 'ascii':\n          case 'binary':\n          case 'raw':\n            ret = str.length;\n            break;\n          case 'base64':\n            ret = base64ToBytes(str).length;\n            break;\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            ret = str.length * 2;\n            break;\n          default:\n            throw new Error('Unknown encoding');}\n\n        return ret;\n      };\n\n      Buffer.concat = function (list, totalLength) {\n        assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\\n' +\n        'list should be an Array.');\n\n        if (list.length === 0) {\n          return new Buffer(0);\n        } else if (list.length === 1) {\n          return list[0];\n        }\n\n        var i;\n        if (typeof totalLength !== 'number') {\n          totalLength = 0;\n          for (i = 0; i < list.length; i++) {\n            totalLength += list[i].length;\n          }\n        }\n\n        var buf = new Buffer(totalLength);\n        var pos = 0;\n        for (i = 0; i < list.length; i++) {\n          var item = list[i];\n          item.copy(buf, pos);\n          pos += item.length;\n        }\n        return buf;\n      };\n\n      // BUFFER INSTANCE METHODS\n      // =======================\n\n      function _hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        var remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n\n        // must be an even number of digits\n        var strLen = string.length;\n        assert(strLen % 2 === 0, 'Invalid hex string');\n\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        for (var i = 0; i < length; i++) {\n          var byte = parseInt(string.substr(i * 2, 2), 16);\n          assert(!isNaN(byte), 'Invalid hex string');\n          buf[offset + i] = byte;\n        }\n        Buffer._charsWritten = i * 2;\n        return i;\n      }\n\n      function _utf8Write(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(utf8ToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      function _asciiWrite(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(asciiToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      function _binaryWrite(buf, string, offset, length) {\n        return _asciiWrite(buf, string, offset, length);\n      }\n\n      function _base64Write(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(base64ToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      function _utf16leWrite(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(utf16leToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      Buffer.prototype.write = function (string, offset, length, encoding) {\n        // Support both (string, offset, length, encoding)\n        // and the legacy (string, encoding, offset, length)\n        if (isFinite(offset)) {\n          if (!isFinite(length)) {\n            encoding = length;\n            length = undefined;\n          }\n        } else {// legacy\n          var swap = encoding;\n          encoding = offset;\n          offset = length;\n          length = swap;\n        }\n\n        offset = Number(offset) || 0;\n        var remaining = this.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        encoding = String(encoding || 'utf8').toLowerCase();\n\n        var ret;\n        switch (encoding) {\n          case 'hex':\n            ret = _hexWrite(this, string, offset, length);\n            break;\n          case 'utf8':\n          case 'utf-8':\n            ret = _utf8Write(this, string, offset, length);\n            break;\n          case 'ascii':\n            ret = _asciiWrite(this, string, offset, length);\n            break;\n          case 'binary':\n            ret = _binaryWrite(this, string, offset, length);\n            break;\n          case 'base64':\n            ret = _base64Write(this, string, offset, length);\n            break;\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            ret = _utf16leWrite(this, string, offset, length);\n            break;\n          default:\n            throw new Error('Unknown encoding');}\n\n        return ret;\n      };\n\n      Buffer.prototype.toString = function (encoding, start, end) {\n        var self = this;\n\n        encoding = String(encoding || 'utf8').toLowerCase();\n        start = Number(start) || 0;\n        end = end !== undefined ?\n        Number(end) :\n        end = self.length;\n\n        // Fastpath empty strings\n        if (end === start)\n        return '';\n\n        var ret;\n        switch (encoding) {\n          case 'hex':\n            ret = _hexSlice(self, start, end);\n            break;\n          case 'utf8':\n          case 'utf-8':\n            ret = _utf8Slice(self, start, end);\n            break;\n          case 'ascii':\n            ret = _asciiSlice(self, start, end);\n            break;\n          case 'binary':\n            ret = _binarySlice(self, start, end);\n            break;\n          case 'base64':\n            ret = _base64Slice(self, start, end);\n            break;\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            ret = _utf16leSlice(self, start, end);\n            break;\n          default:\n            throw new Error('Unknown encoding');}\n\n        return ret;\n      };\n\n      Buffer.prototype.toJSON = function () {\n        return {\n          type: 'Buffer',\n          data: Array.prototype.slice.call(this._arr || this, 0) };\n\n      };\n\n      // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n      Buffer.prototype.copy = function (target, target_start, start, end) {\n        var source = this;\n\n        if (!start) start = 0;\n        if (!end && end !== 0) end = this.length;\n        if (!target_start) target_start = 0;\n\n        // Copy 0 bytes; we're done\n        if (end === start) return;\n        if (target.length === 0 || source.length === 0) return;\n\n        // Fatal error conditions\n        assert(end >= start, 'sourceEnd < sourceStart');\n        assert(target_start >= 0 && target_start < target.length,\n        'targetStart out of bounds');\n        assert(start >= 0 && start < source.length, 'sourceStart out of bounds');\n        assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds');\n\n        // Are we oob?\n        if (end > this.length)\n        end = this.length;\n        if (target.length - target_start < end - start)\n        end = target.length - target_start + start;\n\n        var len = end - start;\n\n        if (len < 100 || !Buffer._useTypedArrays) {\n          for (var i = 0; i < len; i++) {\n            target[i + target_start] = this[i + start];}\n        } else {\n          target._set(this.subarray(start, start + len), target_start);\n        }\n      };\n\n      function _base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n\n      function _utf8Slice(buf, start, end) {\n        var res = '';\n        var tmp = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; i++) {\n          if (buf[i] <= 0x7F) {\n            res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);\n            tmp = '';\n          } else {\n            tmp += '%' + buf[i].toString(16);\n          }\n        }\n\n        return res + decodeUtf8Char(tmp);\n      }\n\n      function _asciiSlice(buf, start, end) {\n        var ret = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; i++) {\n          ret += String.fromCharCode(buf[i]);}\n        return ret;\n      }\n\n      function _binarySlice(buf, start, end) {\n        return _asciiSlice(buf, start, end);\n      }\n\n      function _hexSlice(buf, start, end) {\n        var len = buf.length;\n\n        if (!start || start < 0) start = 0;\n        if (!end || end < 0 || end > len) end = len;\n\n        var out = '';\n        for (var i = start; i < end; i++) {\n          out += toHex(buf[i]);\n        }\n        return out;\n      }\n\n      function _utf16leSlice(buf, start, end) {\n        var bytes = buf.slice(start, end);\n        var res = '';\n        for (var i = 0; i < bytes.length; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n\n      Buffer.prototype.slice = function (start, end) {\n        var len = this.length;\n        start = clamp(start, len, 0);\n        end = clamp(end, len, len);\n\n        if (Buffer._useTypedArrays) {\n          return Buffer._augment(this.subarray(start, end));\n        } else {\n          var sliceLen = end - start;\n          var newBuf = new Buffer(sliceLen, undefined, true);\n          for (var i = 0; i < sliceLen; i++) {\n            newBuf[i] = this[i + start];\n          }\n          return newBuf;\n        }\n      };\n\n      // `get` will be removed in Node 0.13+\n      Buffer.prototype.get = function (offset) {\n        console.log('.get() is deprecated. Access using array indexes instead.');\n        return this.readUInt8(offset);\n      };\n\n      // `set` will be removed in Node 0.13+\n      Buffer.prototype.set = function (v, offset) {\n        console.log('.set() is deprecated. Access using array indexes instead.');\n        return this.writeUInt8(v, offset);\n      };\n\n      Buffer.prototype.readUInt8 = function (offset, noAssert) {\n        if (!noAssert) {\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset < this.length, 'Trying to read beyond buffer length');\n        }\n\n        if (offset >= this.length)\n        return;\n\n        return this[offset];\n      };\n\n      function _readUInt16(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val;\n        if (littleEndian) {\n          val = buf[offset];\n          if (offset + 1 < len)\n          val |= buf[offset + 1] << 8;\n        } else {\n          val = buf[offset] << 8;\n          if (offset + 1 < len)\n          val |= buf[offset + 1];\n        }\n        return val;\n      }\n\n      Buffer.prototype.readUInt16LE = function (offset, noAssert) {\n        return _readUInt16(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readUInt16BE = function (offset, noAssert) {\n        return _readUInt16(this, offset, false, noAssert);\n      };\n\n      function _readUInt32(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val;\n        if (littleEndian) {\n          if (offset + 2 < len)\n          val = buf[offset + 2] << 16;\n          if (offset + 1 < len)\n          val |= buf[offset + 1] << 8;\n          val |= buf[offset];\n          if (offset + 3 < len)\n          val = val + (buf[offset + 3] << 24 >>> 0);\n        } else {\n          if (offset + 1 < len)\n          val = buf[offset + 1] << 16;\n          if (offset + 2 < len)\n          val |= buf[offset + 2] << 8;\n          if (offset + 3 < len)\n          val |= buf[offset + 3];\n          val = val + (buf[offset] << 24 >>> 0);\n        }\n        return val;\n      }\n\n      Buffer.prototype.readUInt32LE = function (offset, noAssert) {\n        return _readUInt32(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readUInt32BE = function (offset, noAssert) {\n        return _readUInt32(this, offset, false, noAssert);\n      };\n\n      Buffer.prototype.readInt8 = function (offset, noAssert) {\n        if (!noAssert) {\n          assert(offset !== undefined && offset !== null,\n          'missing offset');\n          assert(offset < this.length, 'Trying to read beyond buffer length');\n        }\n\n        if (offset >= this.length)\n        return;\n\n        var neg = this[offset] & 0x80;\n        if (neg)\n        return (0xff - this[offset] + 1) * -1;else\n\n        return this[offset];\n      };\n\n      function _readInt16(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val = _readUInt16(buf, offset, littleEndian, true);\n        var neg = val & 0x8000;\n        if (neg)\n        return (0xffff - val + 1) * -1;else\n\n        return val;\n      }\n\n      Buffer.prototype.readInt16LE = function (offset, noAssert) {\n        return _readInt16(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readInt16BE = function (offset, noAssert) {\n        return _readInt16(this, offset, false, noAssert);\n      };\n\n      function _readInt32(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val = _readUInt32(buf, offset, littleEndian, true);\n        var neg = val & 0x80000000;\n        if (neg)\n        return (0xffffffff - val + 1) * -1;else\n\n        return val;\n      }\n\n      Buffer.prototype.readInt32LE = function (offset, noAssert) {\n        return _readInt32(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readInt32BE = function (offset, noAssert) {\n        return _readInt32(this, offset, false, noAssert);\n      };\n\n      function _readFloat(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        return ieee754.read(buf, offset, littleEndian, 23, 4);\n      }\n\n      Buffer.prototype.readFloatLE = function (offset, noAssert) {\n        return _readFloat(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readFloatBE = function (offset, noAssert) {\n        return _readFloat(this, offset, false, noAssert);\n      };\n\n      function _readDouble(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset + 7 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        return ieee754.read(buf, offset, littleEndian, 52, 8);\n      }\n\n      Buffer.prototype.readDoubleLE = function (offset, noAssert) {\n        return _readDouble(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readDoubleBE = function (offset, noAssert) {\n        return _readDouble(this, offset, false, noAssert);\n      };\n\n      Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset < this.length, 'trying to write beyond buffer length');\n          verifuint(value, 0xff);\n        }\n\n        if (offset >= this.length) return;\n\n        this[offset] = value;\n      };\n\n      function _writeUInt16(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'trying to write beyond buffer length');\n          verifuint(value, 0xffff);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {\n          buf[offset + i] =\n          (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>>\n          (littleEndian ? i : 1 - i) * 8;\n        }\n      }\n\n      Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n        _writeUInt16(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n        _writeUInt16(this, value, offset, false, noAssert);\n      };\n\n      function _writeUInt32(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'trying to write beyond buffer length');\n          verifuint(value, 0xffffffff);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {\n          buf[offset + i] =\n          value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n        }\n      }\n\n      Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n        _writeUInt32(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n        _writeUInt32(this, value, offset, false, noAssert);\n      };\n\n      Buffer.prototype.writeInt8 = function (value, offset, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset < this.length, 'Trying to write beyond buffer length');\n          verifsint(value, 0x7f, -0x80);\n        }\n\n        if (offset >= this.length)\n        return;\n\n        if (value >= 0)\n        this.writeUInt8(value, offset, noAssert);else\n\n        this.writeUInt8(0xff + value + 1, offset, noAssert);\n      };\n\n      function _writeInt16(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'Trying to write beyond buffer length');\n          verifsint(value, 0x7fff, -0x8000);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        if (value >= 0)\n        _writeUInt16(buf, value, offset, littleEndian, noAssert);else\n\n        _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert);\n      }\n\n      Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n        _writeInt16(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n        _writeInt16(this, value, offset, false, noAssert);\n      };\n\n      function _writeInt32(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');\n          verifsint(value, 0x7fffffff, -0x80000000);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        if (value >= 0)\n        _writeUInt32(buf, value, offset, littleEndian, noAssert);else\n\n        _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert);\n      }\n\n      Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n        _writeInt32(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n        _writeInt32(this, value, offset, false, noAssert);\n      };\n\n      function _writeFloat(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');\n          verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n      }\n\n      Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n        _writeFloat(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n        _writeFloat(this, value, offset, false, noAssert);\n      };\n\n      function _writeDouble(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 7 < buf.length,\n          'Trying to write beyond buffer length');\n          verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n      }\n\n      Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n        _writeDouble(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n        _writeDouble(this, value, offset, false, noAssert);\n      };\n\n      // fill(value, start=0, end=buffer.length)\n      Buffer.prototype.fill = function (value, start, end) {\n        if (!value) value = 0;\n        if (!start) start = 0;\n        if (!end) end = this.length;\n\n        if (typeof value === 'string') {\n          value = value.charCodeAt(0);\n        }\n\n        assert(typeof value === 'number' && !isNaN(value), 'value is not a number');\n        assert(end >= start, 'end < start');\n\n        // Fill 0 bytes; we're done\n        if (end === start) return;\n        if (this.length === 0) return;\n\n        assert(start >= 0 && start < this.length, 'start out of bounds');\n        assert(end >= 0 && end <= this.length, 'end out of bounds');\n\n        for (var i = start; i < end; i++) {\n          this[i] = value;\n        }\n      };\n\n      Buffer.prototype.inspect = function () {\n        var out = [];\n        var len = this.length;\n        for (var i = 0; i < len; i++) {\n          out[i] = toHex(this[i]);\n          if (i === exports.INSPECT_MAX_BYTES) {\n            out[i + 1] = '...';\n            break;\n          }\n        }\n        return '<Buffer ' + out.join(' ') + '>';\n      };\n\n      /**\n          * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n          * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n          */\n      Buffer.prototype.toArrayBuffer = function () {\n        if (typeof Uint8Array !== 'undefined') {\n          if (Buffer._useTypedArrays) {\n            return new Buffer(this).buffer;\n          } else {\n            var buf = new Uint8Array(this.length);\n            for (var i = 0, len = buf.length; i < len; i += 1) {\n              buf[i] = this[i];}\n            return buf.buffer;\n          }\n        } else {\n          throw new Error('Buffer.toArrayBuffer not supported in this browser');\n        }\n      };\n\n      // HELPER FUNCTIONS\n      // ================\n\n      function stringtrim(str) {\n        if (str.trim) return str.trim();\n        return str.replace(/^\\s+|\\s+$/g, '');\n      }\n\n      var BP = Buffer.prototype;\n\n      /**\n                                  * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n                                  */\n      Buffer._augment = function (arr) {\n        arr._isBuffer = true;\n\n        // save reference to original Uint8Array get/set methods before overwriting\n        arr._get = arr.get;\n        arr._set = arr.set;\n\n        // deprecated, will be removed in node 0.13+\n        arr.get = BP.get;\n        arr.set = BP.set;\n\n        arr.write = BP.write;\n        arr.toString = BP.toString;\n        arr.toLocaleString = BP.toString;\n        arr.toJSON = BP.toJSON;\n        arr.copy = BP.copy;\n        arr.slice = BP.slice;\n        arr.readUInt8 = BP.readUInt8;\n        arr.readUInt16LE = BP.readUInt16LE;\n        arr.readUInt16BE = BP.readUInt16BE;\n        arr.readUInt32LE = BP.readUInt32LE;\n        arr.readUInt32BE = BP.readUInt32BE;\n        arr.readInt8 = BP.readInt8;\n        arr.readInt16LE = BP.readInt16LE;\n        arr.readInt16BE = BP.readInt16BE;\n        arr.readInt32LE = BP.readInt32LE;\n        arr.readInt32BE = BP.readInt32BE;\n        arr.readFloatLE = BP.readFloatLE;\n        arr.readFloatBE = BP.readFloatBE;\n        arr.readDoubleLE = BP.readDoubleLE;\n        arr.readDoubleBE = BP.readDoubleBE;\n        arr.writeUInt8 = BP.writeUInt8;\n        arr.writeUInt16LE = BP.writeUInt16LE;\n        arr.writeUInt16BE = BP.writeUInt16BE;\n        arr.writeUInt32LE = BP.writeUInt32LE;\n        arr.writeUInt32BE = BP.writeUInt32BE;\n        arr.writeInt8 = BP.writeInt8;\n        arr.writeInt16LE = BP.writeInt16LE;\n        arr.writeInt16BE = BP.writeInt16BE;\n        arr.writeInt32LE = BP.writeInt32LE;\n        arr.writeInt32BE = BP.writeInt32BE;\n        arr.writeFloatLE = BP.writeFloatLE;\n        arr.writeFloatBE = BP.writeFloatBE;\n        arr.writeDoubleLE = BP.writeDoubleLE;\n        arr.writeDoubleBE = BP.writeDoubleBE;\n        arr.fill = BP.fill;\n        arr.inspect = BP.inspect;\n        arr.toArrayBuffer = BP.toArrayBuffer;\n\n        return arr;\n      };\n\n      // slice(start, end)\n      function clamp(index, len, defaultValue) {\n        if (typeof index !== 'number') return defaultValue;\n        index = ~~index; // Coerce to integer.\n        if (index >= len) return len;\n        if (index >= 0) return index;\n        index += len;\n        if (index >= 0) return index;\n        return 0;\n      }\n\n      function coerce(length) {\n        // Coerce length to a number (possibly NaN), round up\n        // in case it's fractional (e.g. 123.456) then do a\n        // double negate to coerce a NaN to 0. Easy, right?\n        length = ~~Math.ceil(+length);\n        return length < 0 ? 0 : length;\n      }\n\n      function isArray(subject) {\n        return (Array.isArray || function (subject) {\n          return Object.prototype.toString.call(subject) === '[object Array]';\n        })(subject);\n      }\n\n      function isArrayish(subject) {\n        return isArray(subject) || Buffer.isBuffer(subject) ||\n        subject && (typeof subject === \"undefined\" ? \"undefined\" : _typeof(subject)) === 'object' &&\n        typeof subject.length === 'number';\n      }\n\n      function toHex(n) {\n        if (n < 16) return '0' + n.toString(16);\n        return n.toString(16);\n      }\n\n      function utf8ToBytes(str) {\n        var byteArray = [];\n        for (var i = 0; i < str.length; i++) {\n          var b = str.charCodeAt(i);\n          if (b <= 0x7F)\n          byteArray.push(str.charCodeAt(i));else\n          {\n            var start = i;\n            if (b >= 0xD800 && b <= 0xDFFF) i++;\n            var h = encodeURIComponent(str.slice(start, i + 1)).substr(1).split('%');\n            for (var j = 0; j < h.length; j++) {\n              byteArray.push(parseInt(h[j], 16));}\n          }\n        }\n        return byteArray;\n      }\n\n      function asciiToBytes(str) {\n        var byteArray = [];\n        for (var i = 0; i < str.length; i++) {\n          // Node's code seems to be doing this and not & 0x7F..\n          byteArray.push(str.charCodeAt(i) & 0xFF);\n        }\n        return byteArray;\n      }\n\n      function utf16leToBytes(str) {\n        var c, hi, lo;\n        var byteArray = [];\n        for (var i = 0; i < str.length; i++) {\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n\n        return byteArray;\n      }\n\n      function base64ToBytes(str) {\n        return base64.toByteArray(str);\n      }\n\n      function blitBuffer(src, dst, offset, length) {\n        var pos;\n        for (var i = 0; i < length; i++) {\n          if (i + offset >= dst.length || i >= src.length)\n          break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n\n      function decodeUtf8Char(str) {\n        try {\n          return decodeURIComponent(str);\n        } catch (err) {\n          return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n        }\n      }\n\n      /*\n         * We have to make sure that the value is a valid integer. This means that it\n         * is non-negative. It has no fractional component and that it does not\n         * exceed the maximum allowed value.\n         */\n      function verifuint(value, max) {\n        assert(typeof value === 'number', 'cannot write a non-number as a number');\n        assert(value >= 0, 'specified a negative value for writing an unsigned value');\n        assert(value <= max, 'value is larger than maximum value for type');\n        assert(Math.floor(value) === value, 'value has a fractional component');\n      }\n\n      function verifsint(value, max, min) {\n        assert(typeof value === 'number', 'cannot write a non-number as a number');\n        assert(value <= max, 'value larger than maximum allowed value');\n        assert(value >= min, 'value smaller than minimum allowed value');\n        assert(Math.floor(value) === value, 'value has a fractional component');\n      }\n\n      function verifIEEE754(value, max, min) {\n        assert(typeof value === 'number', 'cannot write a non-number as a number');\n        assert(value <= max, 'value larger than maximum allowed value');\n        assert(value >= min, 'value smaller than minimum allowed value');\n      }\n\n      function assert(test, message) {\n        if (!test) throw new Error(message || 'Failed assertion');\n      }\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/gulp-browserify/node_modules/buffer/index.js\", \"/../../node_modules/gulp-browserify/node_modules/buffer\");\n  }, { \"b55mWE\": 5, \"base64-js\": 3, \"buffer\": 4, \"ieee754\": 6 }], 5: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      // shim for using process in browser\n\n      var process = module.exports = {};\n\n      process.nextTick = function () {\n        var canSetImmediate = typeof window !== 'undefined' &&\n        window.setImmediate;\n        var canPost = typeof window !== 'undefined' &&\n        window.postMessage && window.addEventListener;\n\n\n        if (canSetImmediate) {\n          return function (f) {return window.setImmediate(f);};\n        }\n\n        if (canPost) {\n          var queue = [];\n          window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n              ev.stopPropagation();\n              if (queue.length > 0) {\n                var fn = queue.shift();\n                fn();\n              }\n            }\n          }, true);\n\n          return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n          };\n        }\n\n        return function nextTick(fn) {\n          setTimeout(fn, 0);\n        };\n      }();\n\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      // TODO(shtylman)\n      process.cwd = function () {return '/';};\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/gulp-browserify/node_modules/process/browser.js\", \"/../../node_modules/gulp-browserify/node_modules/process\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }], 6: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s = buffer[offset + i];\n\n        i += d;\n\n        e = s & (1 << -nBits) - 1;\n        s >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n\n      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n\n        value = Math.abs(value);\n\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n        buffer[offset + i - d] |= s * 128;\n      };\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/ieee754/index.js\", \"/../../node_modules/ieee754\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }] }, {}, [2]);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qLnZhbGxlbHVuZ2EvV29ya3NwYWNlcy90ZXNpcy9zZWFtbGVzcy1wb3N0ZXItY29udHJvbC9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvai52YWxsZWx1bmdhL1dvcmtzcGFjZXMvdGVzaXMvc2VhbWxlc3MtcG9zdGVyLWNvbnRyb2wvYXBwL3NjcmlwdHMvYXBwL2RldmljZS5qcyIsIi9Vc2Vycy9qLnZhbGxlbHVuZ2EvV29ya3NwYWNlcy90ZXNpcy9zZWFtbGVzcy1wb3N0ZXItY29udHJvbC9hcHAvc2NyaXB0cy9mYWtlX2U1ZjQwYjI5LmpzIiwiL1VzZXJzL2oudmFsbGVsdW5nYS9Xb3Jrc3BhY2VzL3Rlc2lzL3NlYW1sZXNzLXBvc3Rlci1jb250cm9sL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwiL1VzZXJzL2oudmFsbGVsdW5nYS9Xb3Jrc3BhY2VzL3Rlc2lzL3NlYW1sZXNzLXBvc3Rlci1jb250cm9sL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi9Vc2Vycy9qLnZhbGxlbHVuZ2EvV29ya3NwYWNlcy90ZXNpcy9zZWFtbGVzcy1wb3N0ZXItY29udHJvbC9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvai52YWxsZWx1bmdhL1dvcmtzcGFjZXMvdGVzaXMvc2VhbWxlc3MtcG9zdGVyLWNvbnRyb2wvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQ0FBO0FBRUEsQUFDQTs7Z0NBQ0E7d0JBQ0E7eURBQ0E7QUFDQSxBQUNBLFNBUEE7O0FBUUE7d0JBQ0E7MEJBQ0E7d0JBQ0E7c0JBQ0EsQUFDQSxBQUNBOzs7cURBQ0E7bUNBQ0E7NkJBQ0E7NEVBQ0E7cUJBQ0E7QUFDQTtBQUNBLEFBQ0E7O0FBQ0E7d0JBQ0E7NkJBQ0E7c0NBQ0E7QUFDQTtrQ0FDQTtBQUNBLEFBQ0E7O2dCQUNBO3dCQUNBO3NEQUNBO3NFQUNBOzZFQUNBO0FBQ0EsQUFDQTs7QUFDQTt3QkFDQTs2QkFDQTtzQ0FDQTtBQUNBO2tDQUNBO0FBQ0EsQUFDQTs7QUFDQTt3QkFDQTt3QkFDQTtBQUNBLEFBQ0E7OztBQUNBO0FBQ0EsdUJBQ0EsQUFDQTs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQSxpQ0FDQTs7QUFDQTtBQUNBLDJCQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFDQTs7QUFDQTtBQUNBLEFBQ0E7O0FBQ0EsNkNBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQUFDQTs7QUFDQSwwREFDQTtxQkFDQTs4Q0FDQTt5QkFDQTtrQ0FDQTtBQUNBOytCQUNBO3NCQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEFBQ0E7O0FBQ0EscURBQ0E7K0JBQ0E7c0JBQ0E7OEJBQ0E7c0JBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxrQkFDQSxBQUNBOzs7O0FDOUdBO0FBQ0EsbUJBQ0E7O0FBQ0EsMkJBQ0E7QUFDQSxBQUNBOzt3Q0FDQTtBQUNBO0FBQ0EsQUFDQTs7a0NBQ0E7bUNBQ0E7b0NBQ0E7bUNBQ0E7bUNBQ0E7MkNBQ0E7NENBQ0EsQUFDQTs7O29DQUVBO3VCQUNBO21CQUNBO29CQUhBLENBSUE7dUJBQ0E7bUJBQ0E7cUJBQ0E7cUJBQ0E7cUJBQ0E7OEJBQ0E7c0NBQ0E7NkJBQ0E7d0JBQ0E7NkJBQ0E7Z0NBQ0E7QUFDQSxBQUNBOztxQ0FDQTswQ0FDQSxBQUNBOztrQ0FDQTs0QkFDQTtBQUNBLEFBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTt3QkFDQTs2RkFDQSxBQUNBOztBQUNBOzZDQUNBLEFBQ0E7O0FBQ0E7c0RBQ0EsQUFDQTs7a0JBQ0EsQUFDQTs7MkJBQ0E7dUJBQ0E7QUFDQSxBQUNBOztvREFDQTt5SUFDQTtxQ0FDQTttQ0FDQTt1QkFDQTtBQUNBLEFBQ0E7O2tDQUNBOzRFQUNBO3VCQUNBO3lDQUNBOzhHQUNBOzRCQUNBO3VCQUNBO0FBQ0EsQUFDQTs7aUJBQ0E7QUFDQSxBQUNBOztzQ0FDQTtjQUNBO3lDQUNBO21CQUNBO2VBQ0EsQUFDQTs7K0JBQ0E7aUNBQ0E7QUFDQSxBQUNBOzt3Q0FDQTtnSEFDQTtBQUNBLEFBQ0E7O0FBQ0E7OEVBQ0E7c0VBQ0E7c0NBQ0E7QUFDQSxBQUNBOztBQUNBO2tCQUNBO2lCQUNBOzBDQUNBO3VDQUNBOzJDQUNBO3dCQUNBO0FBQ0E7aUJBQ0E7MkVBQ0E7dUNBQ0E7MkNBQ0E7MkNBQ0E7d0JBQ0E7QUFDQSxBQUNBLEFBQ0E7OztpQkFDQTtBQUNBLEFBQ0E7OzhCQUNBO2dDQUNBOytEQUNBLEFBQ0E7Ozs7QUM5SEE7QUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQTs7Ozs7OztBQUNBO0FBQ0EsNEJBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQ0E7O0FBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQTs7Ozs7QUFDQSwyQ0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7WUFDQTtvQ0FDQTttQ0FDQTsyQ0FDQTs0QkFDQTs4Q0FDQTtvQkFDQTtpQkFDQTtBQUNBO0FBQ0E7O0FBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBOzs7Ozs7Ozs7Ozs7QUFDQSxpREFDQTs4QkFDQTs2Q0FDQSxBQUNBOzswQkFDQSxBQUNBOztBQUNBO0FBQ0E7d0RBQ0E7K0JBQ0E7MkNBQ0E7Z0NBQ0E7QUFDQTtBQUNBLEFBQ0E7O0FBQ0E7WUFDQTtxQkFDQTt3QkFDQTtxQkFDQTs0Q0FDQTtxQkFDQTt5Q0FDQSxBQUNBOzswQkFDQSxBQUNBOztZQUNBO29DQUNBO0FBQ0E7K0NBQ0E7ZUFDQTtBQUNBO2dCQUNBO3VCQUNBOzBCQUNBO0FBQ0EsQUFDQTs7WUFDQTs4RUFDQTtBQUNBO21CQUNBO3dDQUNBO0FBQ0E7dUNBQ0E7Z0NBQ0E7dUNBQ0EsQUFDQTs7NkJBQ0E7QUFDQTtzQ0FDQTtnQ0FDQTs0RUFDQTt1Q0FDQTtxQkFDQTtBQUNBO0FBQ0EsQUFDQTs7ZUFDQTtBQUNBOztBQUNBO0FBQ0EsQUFDQTs7QUFDQSw4Q0FDQTtpQ0FDQTtlQUNBO2VBQ0E7ZUFDQTtlQUNBO2VBQ0E7ZUFDQTtlQUNBO2VBQ0E7ZUFDQTtlQUNBO2VBQ0E7bUJBQ0E7QUFDQTttQkFDQSxBQUNBOztBQUNBOztBQUNBLHFDQUNBO3FEQUNBO0FBQ0E7O0FBQ0EsbURBQ0E7WUFDQTtvQkFDQTs0QkFDQTtlQUNBOytCQUNBO0FBQ0E7ZUFDQTtlQUNBO21DQUNBO0FBQ0E7ZUFDQTtlQUNBO2VBQ0E7c0JBQ0E7QUFDQTtlQUNBO3FDQUNBO0FBQ0E7ZUFDQTtlQUNBO2VBQ0E7ZUFDQTsrQkFDQTtBQUNBO0FBQ0E7NEJBQ0EsQUFDQTs7ZUFDQTtBQUNBOztBQUNBLG1EQUNBOzhCQUNBO0FBQ0EsQUFDQTs7K0JBQ0E7NEJBQ0E7c0NBQ0E7c0JBQ0E7QUFDQSxBQUNBOztZQUNBOzZDQUNBO3dCQUNBOzRDQUNBO21DQUNBO0FBQ0E7QUFDQSxBQUNBOzs2QkFDQTtrQkFDQTswQ0FDQTswQkFDQTt5QkFDQTtzQkFDQTtBQUNBO2VBQ0E7QUFDQTs7QUFDQTtBQUNBLEFBQ0E7O0FBQ0Esc0RBQ0E7bUNBQ0E7cUNBQ0E7cUJBQ0E7bUJBQ0E7ZUFDQTswQkFDQTtrQ0FDQTtxQkFDQTtBQUNBO0FBQ0EsQUFDQTs7QUFDQTs0QkFDQTtpQ0FDQSxBQUNBOztpQ0FDQTs0QkFDQTtBQUNBO3lDQUNBO3VEQUNBOytCQUNBOzRCQUNBO0FBQ0E7bUNBQ0E7ZUFDQTtBQUNBOztBQUNBLHVEQUNBO2tDQUNBO3FEQUNBO2VBQ0E7QUFDQTs7QUFDQSx3REFDQTtrQ0FDQTtzREFDQTtlQUNBO0FBQ0E7O0FBQ0EseURBQ0E7Z0RBQ0E7QUFDQTs7QUFDQSx5REFDQTtrQ0FDQTt1REFDQTtlQUNBO0FBQ0E7O0FBQ0EsMERBQ0E7a0NBQ0E7d0RBQ0E7ZUFDQTtBQUNBOztBQUNBLDJFQUNBO0FBQ0E7QUFDQTs4QkFDQTtpQ0FDQTt1QkFDQTtxQkFDQTtBQUNBO2dCQUNBO3FCQUNBO3FCQUNBO21CQUNBO21CQUNBO0FBQ0EsQUFDQTs7bUNBQ0E7c0NBQ0E7cUJBQ0E7bUJBQ0E7ZUFDQTswQkFDQTtrQ0FDQTtxQkFDQTtBQUNBO0FBQ0E7OENBQ0EsQUFDQTs7WUFDQTtnQkFDQTtlQUNBO2tEQUNBO0FBQ0E7ZUFDQTtlQUNBO21EQUNBO0FBQ0E7ZUFDQTtvREFDQTtBQUNBO2VBQ0E7cURBQ0E7QUFDQTtlQUNBO3FEQUNBO0FBQ0E7ZUFDQTtlQUNBO2VBQ0E7ZUFDQTtzREFDQTtBQUNBO0FBQ0E7NEJBQ0EsQUFDQTs7ZUFDQTtBQUNBOztBQUNBLGtFQUNBO21CQUNBLEFBQ0E7OzhDQUNBO2lDQUNBO3NCQUNBO2VBQ0E7bUJBQ0EsQUFDQTs7QUFDQTtvQkFDQTtlQUNBLEFBQ0E7O1lBQ0E7Z0JBQ0E7ZUFDQTt5Q0FDQTtBQUNBO2VBQ0E7ZUFDQTswQ0FDQTtBQUNBO2VBQ0E7MkNBQ0E7QUFDQTtlQUNBOzRDQUNBO0FBQ0E7ZUFDQTs0Q0FDQTtBQUNBO2VBQ0E7ZUFDQTtlQUNBO2VBQ0E7NkNBQ0E7QUFDQTtBQUNBOzRCQUNBLEFBQ0E7O2VBQ0E7QUFDQTs7QUFDQSw0Q0FDQTtlQUNBO2dCQUNBOzhEQUNBLEFBQ0E7O0FBQ0E7O0FBQ0E7QUFDQSwwRUFDQTtxQkFDQSxBQUNBOzs0QkFDQTswQ0FDQTswQ0FDQSxBQUNBOztBQUNBOzJCQUNBO3dEQUNBLEFBQ0E7O0FBQ0E7NkJBQ0E7MERBQ0E7QUFDQTtvREFDQTtpREFDQSxBQUNBOztBQUNBO3VCQUNBO21CQUNBO2lEQUNBOzZDQUNBLEFBQ0E7O3dCQUNBLEFBQ0E7O2tEQUNBO21DQUNBO2dEQUNBO2VBQ0E7eURBQ0E7QUFDQTtBQUNBOztBQUNBLDZDQUNBOytDQUNBO3NDQUNBO2VBQ0E7dURBQ0E7QUFDQTtBQUNBOztBQUNBLDJDQUNBO2tCQUNBO2tCQUNBO21DQUNBLEFBQ0E7OzBDQUNBOzhCQUNBO2lFQUNBO2tCQUNBO2lCQUNBO3lDQUNBO0FBQ0E7QUFDQSxBQUNBOztvQ0FDQTtBQUNBOztBQUNBLDRDQUNBO2tCQUNBO21DQUNBLEFBQ0E7O3FDQUNBO3lDQUNBO2VBQ0E7QUFDQTs7QUFDQSw2Q0FDQTt1Q0FDQTtBQUNBOztBQUNBLDBDQUNBO3NCQUNBLEFBQ0E7O3lDQUNBO2dEQUNBLEFBQ0E7O2tCQUNBOzBDQUNBOzJCQUNBO0FBQ0E7ZUFDQTtBQUNBOztBQUNBLDhDQUNBO3FDQUNBO2tCQUNBO2tEQUNBOytEQUNBO0FBQ0E7ZUFDQTtBQUNBOztBQUNBLHFEQUNBO3VCQUNBO2tDQUNBOzhCQUNBLEFBQ0E7O29DQUNBO3NEQUNBO2VBQ0E7K0JBQ0E7dURBQ0E7NkNBQ0E7aUNBQ0E7QUFDQTtpQkFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSwrQ0FDQTtvQkFDQTs4QkFDQTtBQUNBOztBQUNBO0FBQ0Esa0RBQ0E7b0JBQ0E7a0NBQ0E7QUFDQTs7QUFDQSwrREFDQTt1QkFDQTswREFDQTt1Q0FDQTtBQUNBLEFBQ0E7OzJCQUNBO0FBQ0EsQUFDQTs7b0JBQ0E7QUFDQTs7QUFDQSxnRUFDQTt1QkFDQTtvREFDQTswREFDQTswQ0FDQTtBQUNBLEFBQ0E7O3NCQUNBO3NCQUNBO0FBQ0EsQUFDQTs7WUFDQTswQkFDQTtvQkFDQTsyQkFDQTtvQ0FDQTtlQUNBOytCQUNBOzJCQUNBOzhCQUNBO0FBQ0E7ZUFDQTtBQUNBOztBQUNBLGtFQUNBOytDQUNBO0FBQ0E7O0FBQ0Esa0VBQ0E7Z0RBQ0E7QUFDQTs7QUFDQSxnRUFDQTt1QkFDQTtvREFDQTswREFDQTswQ0FDQTtBQUNBLEFBQ0E7O3NCQUNBO3NCQUNBO0FBQ0EsQUFDQTs7WUFDQTswQkFDQTsyQkFDQTttQ0FDQTsyQkFDQTtvQ0FDQTtxQkFDQTsyQkFDQTtpREFDQTtlQUNBOzJCQUNBO21DQUNBOzJCQUNBO29DQUNBOzJCQUNBOzhCQUNBOzZDQUNBO0FBQ0E7ZUFDQTtBQUNBOztBQUNBLGtFQUNBOytDQUNBO0FBQ0E7O0FBQ0Esa0VBQ0E7Z0RBQ0E7QUFDQTs7QUFDQSw4REFDQTt1QkFDQTtvREFDQTtBQUNBO3VDQUNBO0FBQ0EsQUFDQTs7MkJBQ0E7QUFDQSxBQUNBOztpQ0FDQTtZQUNBOzRDQUNBLEFBQ0E7O29CQUNBO0FBQ0E7O0FBQ0EsK0RBQ0E7dUJBQ0E7b0RBQ0E7MERBQ0E7MENBQ0E7QUFDQSxBQUNBOztzQkFDQTtzQkFDQTtBQUNBLEFBQ0E7O3lEQUNBO3dCQUNBO1lBQ0E7cUNBQ0EsQUFDQTs7ZUFDQTtBQUNBOztBQUNBLGlFQUNBOzhDQUNBO0FBQ0E7O0FBQ0EsaUVBQ0E7K0NBQ0E7QUFDQTs7QUFDQSwrREFDQTt1QkFDQTtvREFDQTswREFDQTswQ0FDQTtBQUNBLEFBQ0E7O3NCQUNBO3NCQUNBO0FBQ0EsQUFDQTs7eURBQ0E7d0JBQ0E7WUFDQTt5Q0FDQSxBQUNBOztlQUNBO0FBQ0E7O0FBQ0EsaUVBQ0E7OENBQ0E7QUFDQTs7QUFDQSxpRUFDQTsrQ0FDQTtBQUNBOztBQUNBLCtEQUNBO3VCQUNBO29EQUNBOzBDQUNBO0FBQ0EsQUFDQTs7MkRBQ0E7QUFDQTs7QUFDQSxpRUFDQTs4Q0FDQTtBQUNBOztBQUNBLGlFQUNBOytDQUNBO0FBQ0E7O0FBQ0EsZ0VBQ0E7dUJBQ0E7b0RBQ0E7MENBQ0E7QUFDQSxBQUNBOzsyREFDQTtBQUNBOztBQUNBLGtFQUNBOytDQUNBO0FBQ0E7O0FBQ0Esa0VBQ0E7Z0RBQ0E7QUFDQTs7QUFDQSx1RUFDQTt1QkFDQTt3REFDQTswREFDQTt1Q0FDQTsyQkFDQTtBQUNBLEFBQ0E7O21DQUNBLEFBQ0E7O3VCQUNBO0FBQ0E7O0FBQ0Esd0VBQ0E7dUJBQ0E7d0RBQ0E7b0RBQ0E7MERBQ0E7MENBQ0E7MkJBQ0E7QUFDQSxBQUNBOztzQkFDQTtzQkFDQTtBQUNBLEFBQ0E7O21FQUNBO3VCQUNBO3VEQUNBO3VDQUNBO0FBQ0E7QUFDQTs7QUFDQSwwRUFDQTtnREFDQTtBQUNBOztBQUNBLDBFQUNBO2lEQUNBO0FBQ0E7O0FBQ0Esd0VBQ0E7dUJBQ0E7d0RBQ0E7b0RBQ0E7MERBQ0E7MENBQ0E7MkJBQ0E7QUFDQSxBQUNBOztzQkFDQTtzQkFDQTtBQUNBLEFBQ0E7O21FQUNBO3VCQUNBO3FEQUNBO0FBQ0E7QUFDQTs7QUFDQSwwRUFDQTtnREFDQTtBQUNBOztBQUNBLDBFQUNBO2lEQUNBO0FBQ0E7O0FBQ0Esc0VBQ0E7dUJBQ0E7d0RBQ0E7MERBQ0E7dUNBQ0E7a0NBQ0E7QUFDQSxBQUNBOzsyQkFDQTtBQUNBLEFBQ0E7O3FCQUNBO3VDQUNBLEFBQ0E7O2tEQUNBO0FBQ0E7O0FBQ0EsdUVBQ0E7dUJBQ0E7d0RBQ0E7b0RBQ0E7MERBQ0E7MENBQ0E7b0NBQ0E7QUFDQSxBQUNBOztzQkFDQTtzQkFDQTtBQUNBLEFBQ0E7O3FCQUNBO3VEQUNBLEFBQ0E7O29FQUNBO0FBQ0E7O0FBQ0EseUVBQ0E7K0NBQ0E7QUFDQTs7QUFDQSx5RUFDQTtnREFDQTtBQUNBOztBQUNBLHVFQUNBO3VCQUNBO3dEQUNBO29EQUNBOzBEQUNBOzBDQUNBO3dDQUNBO0FBQ0EsQUFDQTs7c0JBQ0E7c0JBQ0E7QUFDQSxBQUNBOztxQkFDQTt1REFDQSxBQUNBOzt3RUFDQTtBQUNBOztBQUNBLHlFQUNBOytDQUNBO0FBQ0E7O0FBQ0EseUVBQ0E7Z0RBQ0E7QUFDQTs7QUFDQSx1RUFDQTt1QkFDQTt3REFDQTtvREFDQTswREFDQTswQ0FDQTt1REFDQTtBQUNBLEFBQ0E7O3NCQUNBO3NCQUNBO0FBQ0EsQUFDQTs7NERBQ0E7QUFDQTs7QUFDQSx5RUFDQTsrQ0FDQTtBQUNBOztBQUNBLHlFQUNBO2dEQUNBO0FBQ0E7O0FBQ0Esd0VBQ0E7dUJBQ0E7d0RBQ0E7b0RBQ0E7MERBQ0E7a0NBQ0E7QUFDQTt3REFDQTtBQUNBLEFBQ0E7O3NCQUNBO3NCQUNBO0FBQ0EsQUFDQTs7NERBQ0E7QUFDQTs7QUFDQSwwRUFDQTtnREFDQTtBQUNBOztBQUNBLDBFQUNBO2lEQUNBO0FBQ0E7O0FBQ0E7QUFDQSwyREFDQTs0QkFDQTs0QkFDQTs2QkFDQSxBQUNBOzt1Q0FDQTttQ0FDQTtBQUNBLEFBQ0E7OzJEQUNBOzZCQUNBLEFBQ0E7O0FBQ0E7MkJBQ0E7K0JBQ0EsQUFDQTs7a0RBQ0E7K0NBQ0EsQUFDQTs7MENBQ0E7b0JBQ0E7QUFDQTtBQUNBOztBQUNBLDZDQUNBO2tCQUNBO3VCQUNBO3NDQUNBOzhCQUNBOytDQUNBO3lCQUNBO0FBQ0E7QUFDQTtBQUNBOzRDQUNBO0FBQ0E7O0FBQ0EsQUFDQSxBQUNBLEFBQ0E7Ozs7QUFDQSxtREFDQTsrQ0FDQTtzQ0FDQTtvQ0FDQTtpQkFDQTswQ0FDQTs0REFDQTs0QkFDQTt1QkFDQTtBQUNBO2VBQ0E7MEJBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0EsQUFDQTs7QUFDQSwrQkFDQTtpQ0FDQTt5Q0FDQTtBQUNBOztBQUNBLHNCQUNBOztBQUNBLEFBQ0EsQUFDQTs7O0FBQ0EsdUNBQ0E7d0JBQ0EsQUFDQTs7QUFDQTt1QkFDQTt1QkFDQSxBQUNBOztBQUNBO3FCQUNBO3FCQUNBLEFBQ0E7O3VCQUNBOzBCQUNBO2dDQUNBO3dCQUNBO3NCQUNBO3VCQUNBOzJCQUNBOzhCQUNBOzhCQUNBOzhCQUNBOzhCQUNBOzBCQUNBOzZCQUNBOzZCQUNBOzZCQUNBOzZCQUNBOzZCQUNBOzZCQUNBOzhCQUNBOzhCQUNBOzRCQUNBOytCQUNBOytCQUNBOytCQUNBOytCQUNBOzJCQUNBOzhCQUNBOzhCQUNBOzhCQUNBOzhCQUNBOzhCQUNBOzhCQUNBOytCQUNBOytCQUNBO3NCQUNBO3lCQUNBOytCQUNBLEFBQ0E7O2VBQ0E7QUFDQTs7QUFDQTtBQUNBOzhDQUVBO3dCQURBLENBRUE7aUNBQ0E7K0JBQ0E7aUJBQ0E7K0JBQ0E7ZUFDQTtBQUNBOztBQUNBLDhCQUNBO0FBQ0E7QUFDQTtBQUNBOzhCQUNBO2dDQUNBO0FBQ0E7O0FBQ0EsZ0NBQ0E7b0RBQ0E7NkRBQ0E7V0FDQTtBQUNBOztBQUNBLG1DQUNBO21EQUNBO3lGQUNBO2tDQUNBO0FBQ0E7O0FBQ0Esd0JBQ0E7NENBQ0E7MEJBQ0E7QUFDQTs7QUFDQSxnQ0FDQTt3QkFDQTs2Q0FDQTtpQ0FDQTttQkFDQTt3Q0FDQTtBQUNBO3dCQUNBOzRDQUNBO2dGQUNBOzBDQUNBOzRDQUNBO0FBQ0E7QUFDQTtlQUNBO0FBQ0E7O0FBQ0EsaUNBQ0E7d0JBQ0E7NkNBQ0E7QUFDQTs2Q0FDQTtBQUNBO2VBQ0E7QUFDQTs7QUFDQSxtQ0FDQTttQkFDQTt3QkFDQTs2Q0FDQTs2QkFDQTtvQkFDQTttQkFDQTt5QkFDQTt5QkFDQTtBQUNBLEFBQ0E7O2VBQ0E7QUFDQTs7QUFDQSxrQ0FDQTtrQ0FDQTtBQUNBOztBQUNBLG9EQUNBO1lBQ0E7eUNBQ0E7bURBQ0E7QUFDQTtnQ0FDQTtBQUNBO2VBQ0E7QUFDQTs7QUFDQSxtQ0FDQTtZQUNBO29DQUNBO3NCQUNBOzhDQUNBO0FBQ0E7QUFDQTs7QUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBOzs7OztBQUNBLHFDQUNBOzBDQUNBOzJCQUNBOzZCQUNBOzRDQUNBO0FBQ0E7O0FBQ0EsMENBQ0E7MENBQ0E7NkJBQ0E7NkJBQ0E7NENBQ0E7QUFDQTs7QUFDQSw2Q0FDQTswQ0FDQTs2QkFDQTs2QkFDQTtBQUNBOztBQUNBLHFDQUNBOzhDQUNBO0FBQ0EsQUFDQTs7OztBQ3ZsQ0E7QUFDQSxBQUNBOztBQUNBLHFDQUNBOztBQUNBLHFDQUNBO2dEQUNBO2VBQ0E7d0NBQ0E7cUNBQ0EsQUFDQSxBQUNBOzs7NkJBQ0E7NkRBQ0E7QUFDQSxBQUNBOztxQkFDQTtzQkFDQTsyREFDQTs0QkFDQTtzRkFDQTtpQkFDQTtvQ0FDQTsrQkFDQTtBQUNBO0FBQ0E7QUFDQTthQUNBLEFBQ0E7O3VDQUNBO3VCQUNBOytDQUNBO0FBQ0E7QUFDQSxBQUNBOztxQ0FDQTt5QkFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQ0E7O0FBQ0EsdUJBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQ0E7O0FBQ0Esd0NBQ0E7d0JBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EscUNBQ0E7d0JBQ0E7QUFDQSxBQUNBOzs7O0FDakVBO0FBQ0EsbUVBQ0E7ZUFDQTt1Q0FDQTtpQ0FDQTs0QkFDQTtxQkFDQTtvQ0FDQTs0QkFDQTtnQ0FDQSxBQUNBOzthQUNBLEFBQ0E7O2dDQUNBO2VBQ0E7aUJBQ0E7aUZBQ0EsQUFDQTs7Z0NBQ0E7ZUFDQTtpQkFDQTtpRkFDQSxBQUNBOztxQkFDQTtrQkFDQTsrQkFDQTswQ0FDQTtlQUNBOzhCQUNBO2tCQUNBO0FBQ0E7a0RBQ0E7QUFDQTs7QUFDQSwyRUFDQTtrQkFDQTt1Q0FDQTtpQ0FDQTs0QkFDQTtxRUFDQTtvQ0FDQTs0QkFDQTtnRUFDQSxBQUNBOzt5QkFDQSxBQUNBOztnREFDQTtpQ0FDQTtjQUNBO2VBQ0E7Z0RBQ0E7aURBQ0E7QUFDQTtpQkFDQTtBQUNBOzhCQUNBOzBCQUNBO2lCQUNBOzBDQUNBO0FBQ0E7OEJBQ0E7QUFDQTtpQkFDQTtBQUNBLEFBQ0E7O2lDQUNBO2dCQUNBO2dCQUNBO3FDQUNBOzhDQUNBO29CQUNBO2lCQUNBOzZEQUNBO2dCQUNBO0FBQ0E7QUFDQSxBQUNBOzt1RkFDQSxBQUNBOzt3QkFDQTtnQkFDQTtzRkFDQSxBQUNBOztzQ0FDQTtBQUNBLEFBQ0E7OztvQ050RkEiLCJmaWxlIjoiYXBwLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5jbGFzcyBQb3N0ZXJEZXZpY2Uge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGV2aWNlID0gbnVsbDtcbiAgICB0aGlzLm9uRGlzY29ubmVjdGVkID0gdGhpcy5vbkRpc2Nvbm5lY3RlZC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgcmVxdWVzdCgpIHtcbiAgICBjb25zb2xlLmxvZygncmVxdWVzdCcpO1xuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgZmlsdGVyczogW3tcbiAgICAgICAgbmFtZTogJ3Rlc3QnXG4gICAgICB9XVxuICAgIH07XG4gICAgcmV0dXJuIG5hdmlnYXRvci5ibHVldG9vdGgucmVxdWVzdERldmljZShvcHRpb25zKVxuICAgIC50aGVuKGRldmljZSA9PiB7XG4gICAgICB0aGlzLmRldmljZSA9IGRldmljZTtcbiAgICAgIHRoaXMuZGV2aWNlLmFkZEV2ZW50TGlzdGVuZXIoJ2dhdHRzZXJ2ZXJkaXNjb25uZWN0ZWQnLCB0aGlzLm9uRGlzY29ubmVjdGVkKTtcbiAgICAgIHJldHVybiBkZXZpY2U7XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0KCkge1xuICAgIGNvbnNvbGUubG9nKCdjb25uZWN0Jyk7XG4gICAgaWYgKHRoaXMuZGV2aWNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXZpY2UuZ2F0dC5jb25uZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnRGV2aWNlIGlzIG5vdCBjb25uZWN0ZWQuJyk7XG4gIH1cblxuICB3cml0ZUNvbG9yKGRhdGEpIHtcbiAgICBjb25zb2xlLmxvZygnd3JpdGVDb2xvcicpO1xuICAgIHJldHVybiB0aGlzLmRldmljZS5nYXR0LmdldFByaW1hcnlTZXJ2aWNlKDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjApXG4gICAgLnRoZW4oc2VydmljZSA9PiBzZXJ2aWNlLmdldENoYXJhY3RlcmlzdGljKDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjQpKVxuICAgIC50aGVuKGNoYXJhY3RlcmlzdGljID0+IGNoYXJhY3RlcmlzdGljLndyaXRlVmFsdWUoZGF0YSkpO1xuICB9XG5cbiAgZGlzY29ubmVjdCgpIHtcbiAgICBjb25zb2xlLmxvZygnZGlzY29ubmVjdCcpO1xuICAgIGlmICh0aGlzLmRldmljZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGV2aWNlLmdhdHQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0RldmljZSBpcyBub3QgY29ubmVjdGVkLicpO1xuICB9XG5cbiAgb25EaXNjb25uZWN0ZWQoKSB7XG4gICAgY29uc29sZS5sb2coJ29uRGlzY29ubmVjdGVkJyk7XG4gICAgY29uc29sZS5sb2coJ0RldmljZSBpcyBkaXNjb25uZWN0ZWQuJyk7XG4gIH1cbn1cblxuY29uc3QgcG9zdGVyRGV2aWNlID0gbmV3IFBvc3RlckRldmljZSgpO1xubW9kdWxlLmV4cG9ydHMgPSBwb3N0ZXJEZXZpY2U7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYjU1bVdFXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvYXBwL2RldmljZS5qc1wiLFwiL2FwcFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIGNvbnN0IEJsdWV0b290aERldmljZSA9IHJlcXVpcmUoJ3dlYi1ibHVldG9vdGgnKTtcbi8vIGNvbnN0IHN0YXRlTWFuYWdlciA9IHJlcXVpcmUoJy4vYXBwL3N0YXRlLmpzJyk7XG5jb25zdCBwb3N0ZXJEZXZpY2UgPSByZXF1aXJlKCcuL2FwcC9kZXZpY2UuanMnKTtcblxuLy8gY29uc3Qgc2VydmljZSA9ICcxZWNjZTRmMi03ZjllLTExZTYtYWUyMi01NmI2YjY0OTk2MTEnO1xuY29uc3QgY2hhcmFjdGVyaXN0aWMgPSAnNDg4ZDc5NTAtN2Y5ZS0xMWU2LWFlMjItNTZiNmI2NDk5NjExJztcblxuLy8gY29uc3QgZmlsdGVyID0ge1xuLy8gICBuYW1lOiAnTXlEZXZpY2UnLFxuLy8gICBzZXJ2aWNlOiBbc2VydmljZV1cbi8vIH07XG5sZXQgYmx1ZTtcblxuY29uc3QgY29ubmVjdEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdqcy1jb25uZWN0Jyk7XG4vLyBjb25zdCBkaXNjb25uZWN0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2pzLWRpc2Nvbm5lY3QnKTtcblxuY29uc3Qgb2tCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnanMtb2snKTtcblxuLy8gY29ubmVjdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbi8vICAgY29ubmVjdEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4vLyAgIHN0YXRlTWFuYWdlci5jaGFuZ2UoJ2Nvbm5lY3RpbmcnKTtcbi8vXG4vLyAgIGJsdWUgPSBuZXcgQmx1ZXRvb3RoRGV2aWNlKGZpbHRlcik7XG4vLyAgIGJsdWUuY29ubmVjdCgpXG4vLyAgICAgLnRoZW4oZGV2aWNlID0+IHtcbi8vICAgICAgIGNvbnNvbGUubG9nKGRldmljZSk7XG4vLyAgICAgICBzdGF0ZU1hbmFnZXIuY2hhbmdlKCdjb25uZWN0ZWQnKTtcbi8vICAgICAgIGNvbm5lY3RCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbi8vICAgICB9KVxuLy8gICAgIC5jYXRjaChlcnJvciA9PiB7XG4vLyAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4vLyAgICAgICBzdGF0ZU1hbmFnZXIuY2hhbmdlKCdpbml0Jyk7XG4vLyAgICAgICBjb25uZWN0QnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4vLyAgICAgfSk7XG4vLyB9KTtcbi8vXG4vLyBkaXNjb25uZWN0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuLy8gICBpZiAoYmx1ZS5kaXNjb25uZWN0KCkpIHtcbi8vICAgICBzdGF0ZU1hbmFnZXIuY2hhbmdlKCdpbml0Jyk7XG4vLyAgIH0gZWxzZSB7XG4vLyAgICAgY29uc29sZS5sb2coJ2Vycm9yIHdoaWxlIGRpc2Nvbm5lY3QnKTtcbi8vICAgfVxuLy8gfSk7XG5cbmNvbm5lY3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIHBvc3RlckRldmljZS5yZXF1ZXN0KClcbiAgLnRoZW4oKCkgPT4gcG9zdGVyRGV2aWNlLmNvbm5lY3QoKSlcbiAgLnRoZW4oKCkgPT4ge1xuICAgIHBvc3RlckRldmljZS53cml0ZUNvbG9yKCcwMDExMjInKTtcbiAgfSlcbiAgLmNhdGNoKGVycm9yID0+IHtcbiAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gIH0pO1xufSk7XG4vLyBjb25uZWN0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuLy8gICBjb25zb2xlLmxvZygnUmVxdWVzdGluZyBCbHVldG9vdGggRGV2aWNlLi4uJyk7XG4vLyAgIG5hdmlnYXRvci5ibHVldG9vdGgucmVxdWVzdERldmljZSh7XG4vLyAgICAgZmlsdGVyczogW3tzZXJ2aWNlczogW3NlcnZpY2VdfV1cbi8vICAgfSlcbi8vICAgLnRoZW4oZGV2aWNlID0+IHtcbi8vICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGluZyB0byBHQVRUIFNlcnZlci4uLicpO1xuLy8gICAgIHJldHVybiBkZXZpY2UuZ2F0dC5jb25uZWN0KCk7XG4vLyAgIH0pXG4vLyAgIC50aGVuKHNlcnZlciA9PiB7XG4vLyAgICAgY29uc29sZS5sb2coJ0dldHRpbmcgU2VydmljZS4uLicpO1xuLy8gICAgIHJldHVybiBzZXJ2ZXIuZ2V0UHJpbWFyeVNlcnZpY2Uoc2VydmljZSk7XG4vLyAgIH0pXG4vLyAgIC50aGVuKHNlcnZpY2UgPT4ge1xuLy8gICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIENoYXJhY3RlcmlzdGljcy4uLicpO1xuLy8gICAgIC8vIGlmIChjaGFyYWN0ZXJpc3RpYykge1xuLy8gICAgIC8vICAgLy8gR2V0IGFsbCBjaGFyYWN0ZXJpc3RpY3MgdGhhdCBtYXRjaCB0aGlzIFVVSUQuXG4vLyAgICAgLy8gICByZXR1cm4gc2VydmljZS5nZXRDaGFyYWN0ZXJpc3RpY3MoY2hhcmFjdGVyaXN0aWMpO1xuLy8gICAgIC8vIH1cbi8vICAgICAvLyBHZXQgYWxsIGNoYXJhY3RlcmlzdGljcy5cbi8vICAgICByZXR1cm4gc2VydmljZS5nZXRDaGFyYWN0ZXJpc3RpYyhjaGFyYWN0ZXJpc3RpYyk7XG4vLyAgICAgLy8gcmV0dXJuIHNlcnZpY2UuZ2V0Q2hhcmFjdGVyaXN0aWNzKCk7XG4vLyAgIH0pXG4vLyAgIC50aGVuKGNoYXJhY3RlcmlzdGljcyA9PiB7XG4vLyAgICAgLy8gY29uc29sZS5sb2coJz4gQ2hhcmFjdGVyaXN0aWNzOiAnICtcbi8vICAgICAvLyAgIGNoYXJhY3RlcmlzdGljcy5tYXAoYyA9PiBjLnV1aWQpLmpvaW4oJ1xcbicgKyAnICcucmVwZWF0KDE5KSkpO1xuLy9cbi8vICAgICByZXR1cm4gY2hhcmFjdGVyaXN0aWNzWzBdLnJlYWRWYWx1ZSgpO1xuLy8gICB9KVxuLy8gICAudGhlbih2YWx1ZSA9PiB7XG4vLyAgICAgY29uc29sZS5sb2coJ0JhdHRlcnkgcGVyY2VudGFnZSBpcyAnICsgdmFsdWUuZ2V0VWludDgoMCkpO1xuLy8gICB9KVxuLy8gICAuY2F0Y2goZXJyb3IgPT4ge1xuLy8gICAgIGNvbnNvbGUubG9nKCdBcmdoISAnICsgZXJyb3IpO1xuLy8gICB9KTtcbi8vIH0pO1xuXG5va0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgY29uc29sZS5sb2coJ3JlYWQ6ICcgKyBjaGFyYWN0ZXJpc3RpYyk7XG4gIGJsdWUuZ2V0VmFsdWUoY2hhcmFjdGVyaXN0aWMpXG4gICAgLnRoZW4odmFsdWUgPT4ge1xuICAgICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgIH0pO1xuICAvLyBjb25zb2xlLmxvZygnd3JpdGU6IDAyNjY4M2RhLTdmOGItMTFlNi1hZTIyLTU2YjZiNjQ5OTYxMScpO1xuICAvLyBibHVlLndyaXRlVmFsdWUoJzAyNjY4M2RhLTdmOGItMTFlNi1hZTIyLTU2YjZiNjQ5OTYxMScsICdvaycpXG4gIC8vICAgLnRoZW4od3JpdGVTdWNjZXNzID0+IHtcbiAgLy8gICAgIGNvbnNvbGUubG9nKHdyaXRlU3VjY2Vzcyk7XG4gIC8vICAgfSlcbiAgLy8gICAuY2F0Y2goZXJyb3IgPT4ge1xuICAvLyAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAvLyAgIH0pO1xufSk7XG5cbmNvbnNvbGUubG9nKCczJyk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYjU1bVdFXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvZmFrZV9lNWY0MGIyOS5qc1wiLFwiL1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImI1NW1XRVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTJcblxuLyoqXG4gKiBJZiBgQnVmZmVyLl91c2VUeXBlZEFycmF5c2A6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChjb21wYXRpYmxlIGRvd24gdG8gSUU2KVxuICovXG5CdWZmZXIuX3VzZVR5cGVkQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IGlmIGJyb3dzZXIgc3VwcG9ydHMgVHlwZWQgQXJyYXlzLiBTdXBwb3J0ZWQgYnJvd3NlcnMgYXJlIElFIDEwKywgRmlyZWZveCA0KyxcbiAgLy8gQ2hyb21lIDcrLCBTYWZhcmkgNS4xKywgT3BlcmEgMTEuNissIGlPUyA0LjIrLiBJZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGFkZGluZ1xuICAvLyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsIHRoZW4gdGhhdCdzIHRoZSBzYW1lIGFzIG5vIGBVaW50OEFycmF5YCBzdXBwb3J0XG4gIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBhYmxlIHRvIGFkZCBhbGwgdGhlIG5vZGUgQnVmZmVyIEFQSSBtZXRob2RzLiBUaGlzIGlzIGFuIGlzc3VlXG4gIC8vIGluIEZpcmVmb3ggNC0yOS4gTm93IGZpeGVkOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzhcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgLy8gQ2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdFxuXG4gIC8vIFdvcmthcm91bmQ6IG5vZGUncyBiYXNlNjQgaW1wbGVtZW50YXRpb24gYWxsb3dzIGZvciBub24tcGFkZGVkIHN0cmluZ3NcbiAgLy8gd2hpbGUgYmFzZTY0LWpzIGRvZXMgbm90LlxuICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgc3ViamVjdCA9IHN0cmluZ3RyaW0oc3ViamVjdClcbiAgICB3aGlsZSAoc3ViamVjdC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICBzdWJqZWN0ID0gc3ViamVjdCArICc9J1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aFxuICB2YXIgbGVuZ3RoXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdClcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0Lmxlbmd0aCkgLy8gYXNzdW1lIHRoYXQgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsIGFycmF5IG9yIHN0cmluZy4nKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAvLyBQcmVmZXJyZWQ6IFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYnVmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBidWYgPSB0aGlzXG4gICAgYnVmLmxlbmd0aCA9IGxlbmd0aFxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgaVxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgICAgZWxzZVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0W2ldXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbi8vIFNUQVRJQyBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gKGIpIHtcbiAgcmV0dXJuICEhKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHZhciByZXRcbiAgc3RyID0gc3RyICsgJydcbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAvIDJcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBhc3NlcnQoaXNBcnJheShsaXN0KSwgJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuJyArXG4gICAgICAnbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuLy8gQlVGRkVSIElOU1RBTkNFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIF9oZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGFzc2VydChzdHJMZW4gJSAyID09PSAwLCAnSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgYXNzZXJ0KCFpc05hTihieXRlKSwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gYnl0ZVxuICB9XG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gaSAqIDJcbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gX3V0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF9hc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBfYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX3V0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHsgIC8vIGxlZ2FjeVxuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IF9oZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSBfdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IF9hc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBfYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IF9iYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gX3V0ZjE2bGVXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG4gIHN0YXJ0ID0gTnVtYmVyKHN0YXJ0KSB8fCAwXG4gIGVuZCA9IChlbmQgIT09IHVuZGVmaW5lZClcbiAgICA/IE51bWJlcihlbmQpXG4gICAgOiBlbmQgPSBzZWxmLmxlbmd0aFxuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKGVuZCA9PT0gc3RhcnQpXG4gICAgcmV0dXJuICcnXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IF9oZXhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSBfdXRmOFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IF9hc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBfYmluYXJ5U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IF9iYXNlNjRTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gX3V0ZjE2bGVTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpc1xuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBhc3NlcnQodGFyZ2V0X3N0YXJ0ID49IDAgJiYgdGFyZ2V0X3N0YXJ0IDwgdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCBzb3VyY2UubGVuZ3RoLCAnc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gc291cmNlLmxlbmd0aCwgJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydClcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnRcblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAobGVuIDwgMTAwIHx8ICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gX3V0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBfYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBfYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIF9oZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIF91dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2krMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gY2xhbXAoc3RhcnQsIGxlbiwgMClcbiAgZW5kID0gY2xhbXAoZW5kLCBsZW4sIGxlbilcblxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRVSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAyXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gICAgdmFsIHw9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldCArIDNdIDw8IDI0ID4+PiAwKVxuICB9IGVsc2Uge1xuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDFdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDJdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgM11cbiAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldF0gPDwgMjQgPj4+IDApXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgdmFyIG5lZyA9IHRoaXNbb2Zmc2V0XSAmIDB4ODBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MTYoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZEludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IF9yZWFkVUludDMyKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDAwMDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmZmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZEZsb2F0IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRmxvYXQodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRG91YmxlIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZilcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVyblxuXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG59XG5cbmZ1bmN0aW9uIF93cml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MClcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgdGhpcy53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgdGhpcy53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQxNihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MTYoYnVmLCAweGZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICBfd3JpdGVVSW50MzIoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgX3dyaXRlVUludDMyKGJ1ZiwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKVxuICB9XG5cbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSwgJ3ZhbHVlIGlzIG5vdCBhIG51bWJlcicpXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHRoaXMubGVuZ3RoLCAnc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gdGhpcy5sZW5ndGgsICdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdmFsdWVcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvdXQgPSBbXVxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pXG4gICAgaWYgKGkgPT09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJ1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKVxuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5mdW5jdGlvbiBjbGFtcCAoaW5kZXgsIGxlbiwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSByZXR1cm4gZGVmYXVsdFZhbHVlXG4gIGluZGV4ID0gfn5pbmRleDsgIC8vIENvZXJjZSB0byBpbnRlZ2VyLlxuICBpZiAoaW5kZXggPj0gbGVuKSByZXR1cm4gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgaW5kZXggKz0gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gY29lcmNlIChsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKVxuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGhcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBBcnJheV0nXG4gIH0pKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspXG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHBvc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0XG4gKiBpcyBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdFxuICogZXhjZWVkIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmdWludCAodmFsdWUsIG1heCkge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPj0gMCwgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZnNpbnQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKHRlc3QsIG1lc3NhZ2UpIHtcbiAgaWYgKCF0ZXN0KSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnRmFpbGVkIGFzc2VydGlvbicpXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYjU1bVdFXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYjU1bVdFXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImI1NW1XRVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2llZWU3NTRcIikiXX0=\n","/*!\n *\n *  Web Starter Kit\n *  Copyright 2015 Google Inc. All rights reserved.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *    https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License\n *\n */\n/* eslint-env browser */\n(function() {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  var isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n      // [::1] is the IPv6 localhost address.\n      window.location.hostname === '[::1]' ||\n      // 127.0.0.1/8 is considered localhost for IPv4.\n      window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n      )\n    );\n\n  if ('serviceWorker' in navigator &&\n      (window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js')\n    .then(function(registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function() {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {\n          // The updatefound event implies that registration.installing is set:\n          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n          var installingWorker = registration.installing;\n\n          installingWorker.onstatechange = function() {\n            switch (installingWorker.state) {\n              case 'installed':\n                // At this point, the old content will have been purged and the\n                // fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in the page's interface.\n                break;\n\n              case 'redundant':\n                throw new Error('The installing ' +\n                                'service worker became redundant.');\n\n              default:\n                // Ignore\n            }\n          };\n        }\n      };\n    }).catch(function(e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nclass PosterDevice {\n\n  constructor() {\n    this.device = null;\n    this.onDisconnected = this.onDisconnected.bind(this);\n  }\n\n  request() {\n    console.log('request');\n    let options = {\n      filters: [{\n        name: 'test'\n      }]\n    };\n    return navigator.bluetooth.requestDevice(options)\n    .then(device => {\n      this.device = device;\n      this.device.addEventListener('gattserverdisconnected', this.onDisconnected);\n      return device;\n    });\n  }\n\n  connect() {\n    console.log('connect');\n    if (this.device) {\n      return this.device.gatt.connect();\n    }\n    return Promise.reject('Device is not connected.');\n  }\n\n  writeColor(data) {\n    console.log('writeColor');\n    return this.device.gatt.getPrimaryService(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0)\n    .then(service => service.getCharacteristic(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4))\n    .then(characteristic => characteristic.writeValue(data));\n  }\n\n  disconnect() {\n    console.log('disconnect');\n    if (this.device) {\n      return this.device.gatt.disconnect();\n    }\n    return Promise.reject('Device is not connected.');\n  }\n\n  onDisconnected() {\n    console.log('onDisconnected');\n    console.log('Device is disconnected.');\n  }\n}\n\nconst posterDevice = new PosterDevice();\nmodule.exports = posterDevice;\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/app/device.js\",\"/app\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n// const BluetoothDevice = require('web-bluetooth');\n// const stateManager = require('./app/state.js');\nconst posterDevice = require('./app/device.js');\n\n// const service = '1ecce4f2-7f9e-11e6-ae22-56b6b6499611';\nconst characteristic = '488d7950-7f9e-11e6-ae22-56b6b6499611';\n\n// const filter = {\n//   name: 'MyDevice',\n//   service: [service]\n// };\nlet blue;\n\nconst connectButton = document.getElementById('js-connect');\n// const disconnectButton = document.getElementById('js-disconnect');\n\nconst okButton = document.getElementById('js-ok');\n\n// connectButton.addEventListener('click', () => {\n//   connectButton.disabled = true;\n//   stateManager.change('connecting');\n//\n//   blue = new BluetoothDevice(filter);\n//   blue.connect()\n//     .then(device => {\n//       console.log(device);\n//       stateManager.change('connected');\n//       connectButton.disabled = false;\n//     })\n//     .catch(error => {\n//       console.log(error);\n//       stateManager.change('init');\n//       connectButton.disabled = false;\n//     });\n// });\n//\n// disconnectButton.addEventListener('click', () => {\n//   if (blue.disconnect()) {\n//     stateManager.change('init');\n//   } else {\n//     console.log('error while disconnect');\n//   }\n// });\n\nconnectButton.addEventListener('click', () => {\n  posterDevice.request()\n  .then(() => posterDevice.connect())\n  .then(() => {\n    posterDevice.writeColor('001122');\n  })\n  .catch(error => {\n    console.log(error);\n  });\n});\n// connectButton.addEventListener('click', () => {\n//   console.log('Requesting Bluetooth Device...');\n//   navigator.bluetooth.requestDevice({\n//     filters: [{services: [service]}]\n//   })\n//   .then(device => {\n//     console.log('Connecting to GATT Server...');\n//     return device.gatt.connect();\n//   })\n//   .then(server => {\n//     console.log('Getting Service...');\n//     return server.getPrimaryService(service);\n//   })\n//   .then(service => {\n//     console.log('Getting Characteristics...');\n//     // if (characteristic) {\n//     //   // Get all characteristics that match this UUID.\n//     //   return service.getCharacteristics(characteristic);\n//     // }\n//     // Get all characteristics.\n//     return service.getCharacteristic(characteristic);\n//     // return service.getCharacteristics();\n//   })\n//   .then(characteristics => {\n//     // console.log('> Characteristics: ' +\n//     //   characteristics.map(c => c.uuid).join('\\n' + ' '.repeat(19)));\n//\n//     return characteristics[0].readValue();\n//   })\n//   .then(value => {\n//     console.log('Battery percentage is ' + value.getUint8(0));\n//   })\n//   .catch(error => {\n//     console.log('Argh! ' + error);\n//   });\n// });\n\nokButton.addEventListener('click', () => {\n  console.log('read: ' + characteristic);\n  blue.getValue(characteristic)\n    .then(value => {\n      console.log(value);\n    });\n  // console.log('write: 026683da-7f8b-11e6-ae22-56b6b6499611');\n  // blue.writeValue('026683da-7f8b-11e6-ae22-56b6b6499611', 'ok')\n  //   .then(writeSuccess => {\n  //     console.log(writeSuccess);\n  //   })\n  //   .catch(error => {\n  //     console.log(error);\n  //   });\n});\n\nconsole.log('3');\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/fake_e5f40b29.js\",\"/\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js\",\"/../../node_modules/gulp-browserify/node_modules/base64-js/lib\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = Buffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192\n\n/**\n * If `Buffer._useTypedArrays`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (compatible down to IE6)\n */\nBuffer._useTypedArrays = (function () {\n  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,\n  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding\n  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support\n  // because we need to be able to add all the node Buffer API methods. This is an issue\n  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438\n  try {\n    var buf = new ArrayBuffer(0)\n    var arr = new Uint8Array(buf)\n    arr.foo = function () { return 42 }\n    return 42 === arr.foo() &&\n        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`\n  } catch (e) {\n    return false\n  }\n})()\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (subject, encoding, noZero) {\n  if (!(this instanceof Buffer))\n    return new Buffer(subject, encoding, noZero)\n\n  var type = typeof subject\n\n  // Workaround: node's base64 implementation allows for non-padded strings\n  // while base64-js does not.\n  if (encoding === 'base64' && type === 'string') {\n    subject = stringtrim(subject)\n    while (subject.length % 4 !== 0) {\n      subject = subject + '='\n    }\n  }\n\n  // Find the length\n  var length\n  if (type === 'number')\n    length = coerce(subject)\n  else if (type === 'string')\n    length = Buffer.byteLength(subject, encoding)\n  else if (type === 'object')\n    length = coerce(subject.length) // assume that object is array-like\n  else\n    throw new Error('First argument needs to be a number, array or string.')\n\n  var buf\n  if (Buffer._useTypedArrays) {\n    // Preferred: Return an augmented `Uint8Array` instance for best performance\n    buf = Buffer._augment(new Uint8Array(length))\n  } else {\n    // Fallback: Return THIS instance of Buffer (created by `new`)\n    buf = this\n    buf.length = length\n    buf._isBuffer = true\n  }\n\n  var i\n  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {\n    // Speed optimization -- use set if we're copying from a typed array\n    buf._set(subject)\n  } else if (isArrayish(subject)) {\n    // Treat array-ish objects as a byte array\n    for (i = 0; i < length; i++) {\n      if (Buffer.isBuffer(subject))\n        buf[i] = subject.readUInt8(i)\n      else\n        buf[i] = subject[i]\n    }\n  } else if (type === 'string') {\n    buf.write(subject, 0, encoding)\n  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {\n    for (i = 0; i < length; i++) {\n      buf[i] = 0\n    }\n  }\n\n  return buf\n}\n\n// STATIC METHODS\n// ==============\n\nBuffer.isEncoding = function (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.isBuffer = function (b) {\n  return !!(b !== null && b !== undefined && b._isBuffer)\n}\n\nBuffer.byteLength = function (str, encoding) {\n  var ret\n  str = str + ''\n  switch (encoding || 'utf8') {\n    case 'hex':\n      ret = str.length / 2\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8ToBytes(str).length\n      break\n    case 'ascii':\n    case 'binary':\n    case 'raw':\n      ret = str.length\n      break\n    case 'base64':\n      ret = base64ToBytes(str).length\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = str.length * 2\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.concat = function (list, totalLength) {\n  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\\n' +\n      'list should be an Array.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  } else if (list.length === 1) {\n    return list[0]\n  }\n\n  var i\n  if (typeof totalLength !== 'number') {\n    totalLength = 0\n    for (i = 0; i < list.length; i++) {\n      totalLength += list[i].length\n    }\n  }\n\n  var buf = new Buffer(totalLength)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\n// BUFFER INSTANCE METHODS\n// =======================\n\nfunction _hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  assert(strLen % 2 === 0, 'Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16)\n    assert(!isNaN(byte), 'Invalid hex string')\n    buf[offset + i] = byte\n  }\n  Buffer._charsWritten = i * 2\n  return i\n}\n\nfunction _utf8Write (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(utf8ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _asciiWrite (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(asciiToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _binaryWrite (buf, string, offset, length) {\n  return _asciiWrite(buf, string, offset, length)\n}\n\nfunction _base64Write (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(base64ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _utf16leWrite (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(utf16leToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nBuffer.prototype.write = function (string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length\n      length = undefined\n    }\n  } else {  // legacy\n    var swap = encoding\n    encoding = offset\n    offset = length\n    length = swap\n  }\n\n  offset = Number(offset) || 0\n  var remaining = this.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase()\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = _hexWrite(this, string, offset, length)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = _utf8Write(this, string, offset, length)\n      break\n    case 'ascii':\n      ret = _asciiWrite(this, string, offset, length)\n      break\n    case 'binary':\n      ret = _binaryWrite(this, string, offset, length)\n      break\n    case 'base64':\n      ret = _base64Write(this, string, offset, length)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = _utf16leWrite(this, string, offset, length)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toString = function (encoding, start, end) {\n  var self = this\n\n  encoding = String(encoding || 'utf8').toLowerCase()\n  start = Number(start) || 0\n  end = (end !== undefined)\n    ? Number(end)\n    : end = self.length\n\n  // Fastpath empty strings\n  if (end === start)\n    return ''\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = _hexSlice(self, start, end)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = _utf8Slice(self, start, end)\n      break\n    case 'ascii':\n      ret = _asciiSlice(self, start, end)\n      break\n    case 'binary':\n      ret = _binarySlice(self, start, end)\n      break\n    case 'base64':\n      ret = _base64Slice(self, start, end)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = _utf16leSlice(self, start, end)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toJSON = function () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function (target, target_start, start, end) {\n  var source = this\n\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (!target_start) target_start = 0\n\n  // Copy 0 bytes; we're done\n  if (end === start) return\n  if (target.length === 0 || source.length === 0) return\n\n  // Fatal error conditions\n  assert(end >= start, 'sourceEnd < sourceStart')\n  assert(target_start >= 0 && target_start < target.length,\n      'targetStart out of bounds')\n  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')\n  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length)\n    end = this.length\n  if (target.length - target_start < end - start)\n    end = target.length - target_start + start\n\n  var len = end - start\n\n  if (len < 100 || !Buffer._useTypedArrays) {\n    for (var i = 0; i < len; i++)\n      target[i + target_start] = this[i + start]\n  } else {\n    target._set(this.subarray(start, start + len), target_start)\n  }\n}\n\nfunction _base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction _utf8Slice (buf, start, end) {\n  var res = ''\n  var tmp = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    if (buf[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])\n      tmp = ''\n    } else {\n      tmp += '%' + buf[i].toString(16)\n    }\n  }\n\n  return res + decodeUtf8Char(tmp)\n}\n\nfunction _asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++)\n    ret += String.fromCharCode(buf[i])\n  return ret\n}\n\nfunction _binarySlice (buf, start, end) {\n  return _asciiSlice(buf, start, end)\n}\n\nfunction _hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction _utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function (start, end) {\n  var len = this.length\n  start = clamp(start, len, 0)\n  end = clamp(end, len, len)\n\n  if (Buffer._useTypedArrays) {\n    return Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    var newBuf = new Buffer(sliceLen, undefined, true)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n    return newBuf\n  }\n}\n\n// `get` will be removed in Node 0.13+\nBuffer.prototype.get = function (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` will be removed in Node 0.13+\nBuffer.prototype.set = function (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nBuffer.prototype.readUInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  return this[offset]\n}\n\nfunction _readUInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    val = buf[offset]\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n  } else {\n    val = buf[offset] << 8\n    if (offset + 1 < len)\n      val |= buf[offset + 1]\n  }\n  return val\n}\n\nBuffer.prototype.readUInt16LE = function (offset, noAssert) {\n  return _readUInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt16BE = function (offset, noAssert) {\n  return _readUInt16(this, offset, false, noAssert)\n}\n\nfunction _readUInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    if (offset + 2 < len)\n      val = buf[offset + 2] << 16\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n    val |= buf[offset]\n    if (offset + 3 < len)\n      val = val + (buf[offset + 3] << 24 >>> 0)\n  } else {\n    if (offset + 1 < len)\n      val = buf[offset + 1] << 16\n    if (offset + 2 < len)\n      val |= buf[offset + 2] << 8\n    if (offset + 3 < len)\n      val |= buf[offset + 3]\n    val = val + (buf[offset] << 24 >>> 0)\n  }\n  return val\n}\n\nBuffer.prototype.readUInt32LE = function (offset, noAssert) {\n  return _readUInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt32BE = function (offset, noAssert) {\n  return _readUInt32(this, offset, false, noAssert)\n}\n\nBuffer.prototype.readInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null,\n        'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  var neg = this[offset] & 0x80\n  if (neg)\n    return (0xff - this[offset] + 1) * -1\n  else\n    return this[offset]\n}\n\nfunction _readInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = _readUInt16(buf, offset, littleEndian, true)\n  var neg = val & 0x8000\n  if (neg)\n    return (0xffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt16LE = function (offset, noAssert) {\n  return _readInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt16BE = function (offset, noAssert) {\n  return _readInt16(this, offset, false, noAssert)\n}\n\nfunction _readInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = _readUInt32(buf, offset, littleEndian, true)\n  var neg = val & 0x80000000\n  if (neg)\n    return (0xffffffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt32LE = function (offset, noAssert) {\n  return _readInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt32BE = function (offset, noAssert) {\n  return _readInt32(this, offset, false, noAssert)\n}\n\nfunction _readFloat (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 23, 4)\n}\n\nBuffer.prototype.readFloatLE = function (offset, noAssert) {\n  return _readFloat(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readFloatBE = function (offset, noAssert) {\n  return _readFloat(this, offset, false, noAssert)\n}\n\nfunction _readDouble (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 52, 8)\n}\n\nBuffer.prototype.readDoubleLE = function (offset, noAssert) {\n  return _readDouble(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readDoubleBE = function (offset, noAssert) {\n  return _readDouble(this, offset, false, noAssert)\n}\n\nBuffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xff)\n  }\n\n  if (offset >= this.length) return\n\n  this[offset] = value\n}\n\nfunction _writeUInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {\n    buf[offset + i] =\n        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n            (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n  _writeUInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n  _writeUInt16(this, value, offset, false, noAssert)\n}\n\nfunction _writeUInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffffffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {\n    buf[offset + i] =\n        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n  _writeUInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n  _writeUInt32(this, value, offset, false, noAssert)\n}\n\nBuffer.prototype.writeInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7f, -0x80)\n  }\n\n  if (offset >= this.length)\n    return\n\n  if (value >= 0)\n    this.writeUInt8(value, offset, noAssert)\n  else\n    this.writeUInt8(0xff + value + 1, offset, noAssert)\n}\n\nfunction _writeInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fff, -0x8000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    _writeUInt16(buf, value, offset, littleEndian, noAssert)\n  else\n    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)\n}\n\nBuffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n  _writeInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n  _writeInt16(this, value, offset, false, noAssert)\n}\n\nfunction _writeInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fffffff, -0x80000000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    _writeUInt32(buf, value, offset, littleEndian, noAssert)\n  else\n    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)\n}\n\nBuffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n  _writeInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n  _writeInt32(this, value, offset, false, noAssert)\n}\n\nfunction _writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n}\n\nBuffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n  _writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n  _writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction _writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 7 < buf.length,\n        'Trying to write beyond buffer length')\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n}\n\nBuffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n  _writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n  _writeDouble(this, value, offset, false, noAssert)\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (typeof value === 'string') {\n    value = value.charCodeAt(0)\n  }\n\n  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')\n  assert(end >= start, 'end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  assert(start >= 0 && start < this.length, 'start out of bounds')\n  assert(end >= 0 && end <= this.length, 'end out of bounds')\n\n  for (var i = start; i < end; i++) {\n    this[i] = value\n  }\n}\n\nBuffer.prototype.inspect = function () {\n  var out = []\n  var len = this.length\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i])\n    if (i === exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...'\n      break\n    }\n  }\n  return '<Buffer ' + out.join(' ') + '>'\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer._useTypedArrays) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1)\n        buf[i] = this[i]\n      return buf.buffer\n    }\n  } else {\n    throw new Error('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function (arr) {\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array get/set methods before overwriting\n  arr._get = arr.get\n  arr._set = arr.set\n\n  // deprecated, will be removed in node 0.13+\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\n// slice(start, end)\nfunction clamp (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index;  // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\n\nfunction coerce (length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it's fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length)\n  return length < 0 ? 0 : length\n}\n\nfunction isArray (subject) {\n  return (Array.isArray || function (subject) {\n    return Object.prototype.toString.call(subject) === '[object Array]'\n  })(subject)\n}\n\nfunction isArrayish (subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n      subject && typeof subject === 'object' &&\n      typeof subject.length === 'number'\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    var b = str.charCodeAt(i)\n    if (b <= 0x7F)\n      byteArray.push(str.charCodeAt(i))\n    else {\n      var start = i\n      if (b >= 0xD800 && b <= 0xDFFF) i++\n      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16))\n    }\n  }\n  return byteArray\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(str)\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  var pos\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length))\n      break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction decodeUtf8Char (str) {\n  try {\n    return decodeURIComponent(str)\n  } catch (err) {\n    return String.fromCharCode(0xFFFD) // UTF 8 invalid char\n  }\n}\n\n/*\n * We have to make sure that the value is a valid integer. This means that it\n * is non-negative. It has no fractional component and that it does not\n * exceed the maximum allowed value.\n */\nfunction verifuint (value, max) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value >= 0, 'specified a negative value for writing an unsigned value')\n  assert(value <= max, 'value is larger than maximum value for type')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifsint (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifIEEE754 (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n}\n\nfunction assert (test, message) {\n  if (!test) throw new Error(message || 'Failed assertion')\n}\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/gulp-browserify/node_modules/buffer/index.js\",\"/../../node_modules/gulp-browserify/node_modules/buffer\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/gulp-browserify/node_modules/process/browser.js\",\"/../../node_modules/gulp-browserify/node_modules/process\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/ieee754/index.js\",\"/../../node_modules/ieee754\")","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})"],"sourceRoot":"/source/"}
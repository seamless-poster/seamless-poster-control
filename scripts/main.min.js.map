{"version":3,"sources":["main.min.js","/source/main.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/app/scripts/fake_40d8e88c.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/buffer/index.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/process/browser.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/ieee754/index.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/browser-pack/_prelude.js"],"names":["isLocalhost","Boolean","window","location","hostname","match","navigator","protocol","serviceWorker","register","then","registration","onupdatefound","controller","installingWorker","installing","onstatechange","state","Error","e","console","error","_typeof","Symbol","iterator","obj","constructor","t","n","r","s","o","u","a","require","i","f","exports","call","length","1","module","process","global","Buffer","__argument0","__argument1","__argument2","__argument3","__filename","__dirname","service","characteristic","blue","connectButton","document","getElementById","okButton","addEventListener","log","bluetooth","requestDevice","filters","services","device","gatt","connect","server","getPrimaryService","getCharacteristic","readValue","value","getUint8","getValue","this","self","arguments","b55mWE","buffer","2","lookup","decode","elt","code","charCodeAt","PLUS","PLUS_URL_SAFE","SLASH","SLASH_URL_SAFE","NUMBER","UPPER","LOWER","b64ToByteArray","b64","push","v","arr","L","j","l","tmp","placeHolders","len","charAt","Arr","uint8ToBase64","uint8","encode","num","tripletToBase64","temp","extraBytes","output","Uint8Array","Array","toByteArray","fromByteArray","base64js","3","subject","encoding","noZero","type","stringtrim","coerce","byteLength","buf","_useTypedArrays","_augment","_isBuffer","_set","isArrayish","isBuffer","readUInt8","write","_hexWrite","string","offset","Number","remaining","strLen","assert","byte","parseInt","substr","isNaN","_charsWritten","_utf8Write","charsWritten","blitBuffer","utf8ToBytes","_asciiWrite","asciiToBytes","_binaryWrite","_base64Write","base64ToBytes","_utf16leWrite","utf16leToBytes","_base64Slice","start","end","base64","slice","_utf8Slice","res","Math","min","decodeUtf8Char","String","fromCharCode","toString","_asciiSlice","ret","_binarySlice","_hexSlice","out","toHex","_utf16leSlice","bytes","_readUInt16","littleEndian","noAssert","undefined","val","_readUInt32","_readInt16","neg","_readInt32","_readFloat","ieee754","read","_readDouble","_writeUInt16","verifuint","_writeUInt32","_writeInt16","verifsint","_writeInt32","_writeFloat","verifIEEE754","_writeDouble","str","trim","replace","clamp","index","defaultValue","ceil","isArray","Object","prototype","byteArray","b","h","encodeURIComponent","split","c","hi","lo","src","dst","decodeURIComponent","err","max","floor","test","message","SlowBuffer","INSPECT_MAX_BYTES","poolSize","ArrayBuffer","foo","subarray","isEncoding","toLowerCase","concat","list","totalLength","pos","item","copy","isFinite","swap","toJSON","data","_arr","target","target_start","source","sliceLen","newBuf","get","set","writeUInt8","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","fill","inspect","join","toArrayBuffer","BP","_get","toLocaleString","base64-js","4","noop","nextTick","canSetImmediate","setImmediate","canPost","postMessage","queue","ev","stopPropagation","fn","shift","setTimeout","title","browser","env","argv","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","5","isLE","mLen","nBytes","m","eLen","eMax","eBias","nBits","d","NaN","Infinity","pow","rt","abs","LN2"],"mappings":"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GACAxL,EAAAyL,SACA,KAMAzL,EAAAmF,gBAAA,WJsTQ,IACE,GAAID,GAAM,GAAIwG,aI/SxB,GJgTctI,EAAM,GAAIiB,YI/SxBa,EJiTU,OADA9B,GAAIuI,IAAM,WAAa,MAAO,KACvB,KAAOvI,EI/SxBuI,OJgTkC,kBAAjBvI,GAAIwI,SACX,MAAOrN,GACP,OI/SV,MA8EAyB,EAAA6L,WAAA,SAAAjH,GJiTQ,OAAQgD,OAAOhD,GI/SvBkH,eJgTU,II/SV,MJgTU,II/SV,OJgTU,II/SV,QJgTU,II/SV,QJgTU,II/SV,SJgTU,II/SV,SJgTU,II/SV,MJgTU,II/SV,OJgTU,II/SV,QJgTU,II/SV,UJgTU,II/SV,WJgTY,OI/SZ,CACA,SJgTY,OI/SZ,IAGA9L,EAAAwF,SAAA,SAAAgF,GJiTQ,QAAgB,OAANA,GAAoB9B,SAAN8B,IAAmBA,EI/SnDnF,YAEArF,EAAAiF,WAAA,SAAA4E,EAAAjF,GJiTQ,GI/SRoD,EJiTQ,QADA6B,GI/SR,GJgTgBjF,GI/ShB,QJgTU,II/SV,MJgTYoD,EAAM6B,EAAIlK,OI/StB,CACA,MJgTU,KI/SV,OJgTU,II/SV,QJgTYqI,EAAMtB,EAAYmD,GI/S9BlK,MACA,MJgTU,KI/SV,QJgTU,II/SV,SJgTU,II/SV,MJgTYqI,EAAM6B,EI/SlBlK,MACA,MJgTU,KI/SV,SJgTYqI,EAAMjB,EAAc8C,GI/ShClK,MACA,MJgTU,KI/SV,OJgTU,II/SV,QJgTU,II/SV,UJgTU,II/SV,WJgTYqI,EI/SZ,EJ+SkB6B,EAAIlK,MI9StB,MACA,SJgTY,KAAM,IAAIrB,OI/StB,oBJiTQ,MI/SR0J,IAEAhI,EAAA+L,OAAA,SAAAC,EAAAC,GJoTQ,GAHAhG,EAAOmE,EAAQ4B,GI/SvB,uEJkT4B,IAAhBA,EAAKrM,OACP,MAAO,IAAIK,GI/SrB,EJgTe,IAAoB,IAAhBgM,EAAKrM,OACd,MAAOqM,GI/SjB,EJkTQ,II/SRzM,EJgTQ,IAA2B,gBAAhB0M,GAET,IADAA,EI/SV,EJgTe1M,EAAI,EAAGA,EAAIyM,EAAKrM,OAAQJ,IAC3B0M,GAAeD,EAAKzM,GI/ShCI,MJmTQ,IAAIuF,GAAM,GAAIlF,GI/StBiM,GJgTYC,EI/SZ,CJgTQ,KAAK3M,EAAI,EAAGA,EAAIyM,EAAKrM,OAAQJ,II/SrC,CJgTU,GAAI4M,GAAOH,EI/SrBzM,EJgTU4M,GAAKC,KAAKlH,EI/SpBgH,GJgTUA,GAAOC,EI/SjBxM,OJiTQ,MI/SRuF,IA6DAlF,EAAAsK,UAAA5E,MAAA,SAAAE,EAAAC,EAAAlG,EAAAiF,GJmTQ,GAAIyH,SAASxG,GACNwG,SAAS1M,KACZiF,EI/SZjF,EJgTYA,EI/SZ+I,YJiTe,CACL,GAAI4D,GI/Sd1H,CJgTUA,GI/SViB,EJgTUA,EI/SVlG,EJgTUA,EI/SV2M,EJkTQzG,EAASC,OAAOD,II/SxB,CJgTQ,IAAIE,GAAYjE,KAAKnC,OI/S7BkG,CJgTalG,IAGHA,EAASmG,OI/SnBnG,GJgTcA,EAASoG,IACXpG,EI/SZoG,IJ2SUpG,EI/SVoG,EJsTQnB,EAAWgD,OAAOhD,GAAY,QI/StCkH,aJiTQ,II/SR9D,EJgTQ,QI/SRpD,GJgTU,II/SV,MJgTYoD,EAAMrC,EAAU7D,KAAM8D,EAAQC,EI/S1ClG,EACA,MJgTU,KI/SV,OJgTU,II/SV,QJgTYqI,EAAMzB,EAAWzE,KAAM8D,EAAQC,EI/S3ClG,EACA,MJgTU,KI/SV,QJgTYqI,EAAMrB,EAAY7E,KAAM8D,EAAQC,EI/S5ClG,EACA,MJgTU,KI/SV,SJgTYqI,EAAMnB,EAAa/E,KAAM8D,EAAQC,EI/S7ClG,EACA,MJgTU,KI/SV,SJgTYqI,EAAMlB,EAAahF,KAAM8D,EAAQC,EI/S7ClG,EACA,MJgTU,KI/SV,OJgTU,II/SV,QJgTU,II/SV,UJgTU,II/SV,WJgTYqI,EAAMhB,EAAclF,KAAM8D,EAAQC,EI/S9ClG,EACA,MACA,SJgTY,KAAM,IAAIrB,OI/StB,oBJiTQ,MI/SR0J,IAEAhI,EAAAsK,UAAAxC,SAAA,SAAAlD,EAAAuC,EAAAC,GJiTQ,GAAIrF,GI/SZD,IJwTQ,IAPA8C,EAAWgD,OAAOhD,GAAY,QI/StCkH,cJgTQ3E,EAAQrB,OAAOqB,II/SvB,EJgTQC,EI/SRsB,SJ+S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B4J,IJkTQ5J,EAAI2J,IAAMiC,EI/SlBjC,IJgTQ3J,EAAI4J,IAAMgC,EI/SlBhC,IJiTQ5J,EAAIsC,MAAQsJ,EI/SpBtJ,MJgTQtC,EAAI0E,SAAWkH,EI/SvBlH,SJgTQ1E,EAAI8L,eAAiBF,EI/S7BlH,SJgTQ1E,EAAImJ,OAASyC,EI/SrBzC,OJgTQnJ,EAAIgJ,KAAO4C,EI/SnB5C,KJgTQhJ,EAAIkE,MAAQ0H,EI/SpB1H,MJgTQlE,EAAIqC,UAAYuJ,EI/SxBvJ,UJgTQrC,EAAI8J,aAAe8B,EI/S3B9B,aJgTQ9J,EAAI+J,aAAe6B,EI/S3B7B,aJgTQ/J,EAAIgK,aAAe4B,EI/S3B5B,aJgTQhK,EAAIiK,aAAe2B,EI/S3B3B,aJgTQjK,EAAIkK,SAAW0B,EI/SvB1B,SJgTQlK,EAAImK,YAAcyB,EI/S1BzB,YJgTQnK,EAAIoK,YAAcwB,EI/S1BxB,YJgTQpK,EAAIqK,YAAcuB,EI/S1BvB,YJgTQrK,EAAIsK,YAAcsB,EI/S1BtB,YJgTQtK,EAAIuK,YAAcqB,EI/S1BrB,YJgTQvK,EAAIwK,YAAcoB,EI/S1BpB,YJgTQxK,EAAIyK,aAAemB,EI/S3BnB,aJgTQzK,EAAI0K,aAAekB,EI/S3BlB,aJgTQ1K,EAAI6J,WAAa+B,EI/SzB/B,WJgTQ7J,EAAI2K,cAAgBiB,EI/S5BjB,cJgTQ3K,EAAI4K,cAAgBgB,EI/S5BhB,cJgTQ5K,EAAI6K,cAAgBe,EI/S5Bf,cJgTQ7K,EAAI8K,cAAgBc,EI/S5Bd,cJgTQ9K,EAAI+K,UAAYa,EI/SxBb,UJgTQ/K,EAAIgL,aAAeY,EI/S3BZ,aJgTQhL,EAAIiL,aAAeW,EI/S3BX,aJgTQjL,EAAIkL,aAAeU,EI/S3BV,aJgTQlL,EAAImL,aAAeS,EI/S3BT,aJgTQnL,EAAIoL,aAAeQ,EI/S3BR,aJgTQpL,EAAIqL,aAAeO,EI/S3BP,aJgTQrL,EAAIsL,cAAgBM,EI/S5BN,cJgTQtL,EAAIuL,cAAgBK,EI/S5BL,cJgTQvL,EAAIwL,KAAOI,EI/SnBJ,KJgTQxL,EAAIyL,QAAUG,EI/StBH,QJgTQzL,EAAI2L,cAAgBC,EI/S5BD,cAEA3L,K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","file":"main.min.js","sourcesContent":["'use strict'; /*!\n               *\n               *  Web Starter Kit\n               *  Copyright 2015 Google Inc. All rights reserved.\n               *\n               *  Licensed under the Apache License, Version 2.0 (the \"License\");\n               *  you may not use this file except in compliance with the License.\n               *  You may obtain a copy of the License at\n               *\n               *    https://www.apache.org/licenses/LICENSE-2.0\n               *\n               *  Unless required by applicable law or agreed to in writing, software\n               *  distributed under the License is distributed on an \"AS IS\" BASIS,\n               *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n               *  See the License for the specific language governing permissions and\n               *  limitations under the License\n               *\n               */\n/* eslint-env browser */\n(function () {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  var isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.1/8 is considered localhost for IPv4.\n  window.location.hostname.match(\n  /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));\n\n\n\n  if ('serviceWorker' in navigator && (\n  window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js').\n    then(function (registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function () {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {\n          // The updatefound event implies that registration.installing is set:\n          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n          var installingWorker = registration.installing;\n\n          installingWorker.onstatechange = function () {\n            switch (installingWorker.state) {\n              case 'installed':\n                // At this point, the old content will have been purged and the\n                // fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in the page's interface.\n                break;\n\n              case 'redundant':\n                throw new Error('The installing ' +\n                'service worker became redundant.');\n\n              default:\n              // Ignore\n            }\n          };\n        }\n      };\n    }).catch(function (e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uanMiXSwibmFtZXMiOlsiaXNMb2NhbGhvc3QiLCJCb29sZWFuIiwid2luZG93IiwibG9jYXRpb24iLCJob3N0bmFtZSIsIm1hdGNoIiwibmF2aWdhdG9yIiwicHJvdG9jb2wiLCJzZXJ2aWNlV29ya2VyIiwicmVnaXN0ZXIiLCJ0aGVuIiwicmVnaXN0cmF0aW9uIiwib251cGRhdGVmb3VuZCIsImNvbnRyb2xsZXIiLCJpbnN0YWxsaW5nV29ya2VyIiwiaW5zdGFsbGluZyIsIm9uc3RhdGVjaGFuZ2UiLCJzdGF0ZSIsIkVycm9yIiwiY2F0Y2giLCJlIiwiY29uc29sZSIsImVycm9yIl0sIm1hcHBpbmdzIjoiY0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBO0FBQ0EsQ0FBQyxZQUFXO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJQSxjQUFjQyxRQUFRQyxPQUFPQyxRQUFQLENBQWdCQyxRQUFoQixLQUE2QixXQUE3QjtBQUN0QjtBQUNBRixTQUFPQyxRQUFQLENBQWdCQyxRQUFoQixLQUE2QixPQUZQO0FBR3RCO0FBQ0FGLFNBQU9DLFFBQVAsQ0FBZ0JDLFFBQWhCLENBQXlCQyxLQUF6QjtBQUNFLDBEQURGLENBSmMsQ0FBbEI7Ozs7QUFTQSxNQUFJLG1CQUFtQkMsU0FBbkI7QUFDQ0osU0FBT0MsUUFBUCxDQUFnQkksUUFBaEIsS0FBNkIsUUFBN0IsSUFBeUNQLFdBRDFDLENBQUosRUFDNEQ7QUFDMURNLGNBQVVFLGFBQVYsQ0FBd0JDLFFBQXhCLENBQWlDLG1CQUFqQztBQUNDQyxRQURELENBQ00sVUFBU0MsWUFBVCxFQUF1QjtBQUMzQjtBQUNBQSxtQkFBYUMsYUFBYixHQUE2QixZQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSU4sVUFBVUUsYUFBVixDQUF3QkssVUFBNUIsRUFBd0M7QUFDdEM7QUFDQTtBQUNBLGNBQUlDLG1CQUFtQkgsYUFBYUksVUFBcEM7O0FBRUFELDJCQUFpQkUsYUFBakIsR0FBaUMsWUFBVztBQUMxQyxvQkFBUUYsaUJBQWlCRyxLQUF6QjtBQUNFLG1CQUFLLFdBQUw7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVGLG1CQUFLLFdBQUw7QUFDRSxzQkFBTSxJQUFJQyxLQUFKLENBQVU7QUFDQSxrREFEVixDQUFOOztBQUdGO0FBQ0U7QUFiSjtBQWVELFdBaEJEO0FBaUJEO0FBQ0YsT0E1QkQ7QUE2QkQsS0FoQ0QsRUFnQ0dDLEtBaENILENBZ0NTLFVBQVNDLENBQVQsRUFBWTtBQUNuQkMsY0FBUUMsS0FBUixDQUFjLDJDQUFkLEVBQTJERixDQUEzRDtBQUNELEtBbENEO0FBbUNEOztBQUVEO0FBQ0QsQ0F4REQiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICpcbiAqICBXZWIgU3RhcnRlciBLaXRcbiAqICBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlXG4gKlxuICovXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENoZWNrIHRvIG1ha2Ugc3VyZSBzZXJ2aWNlIHdvcmtlcnMgYXJlIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyLFxuICAvLyBhbmQgdGhhdCB0aGUgY3VycmVudCBwYWdlIGlzIGFjY2Vzc2VkIGZyb20gYSBzZWN1cmUgb3JpZ2luLiBVc2luZyBhXG4gIC8vIHNlcnZpY2Ugd29ya2VyIGZyb20gYW4gaW5zZWN1cmUgb3JpZ2luIHdpbGwgdHJpZ2dlciBKUyBjb25zb2xlIGVycm9ycy4gU2VlXG4gIC8vIGh0dHA6Ly93d3cuY2hyb21pdW0ub3JnL0hvbWUvY2hyb21pdW0tc2VjdXJpdHkvcHJlZmVyLXNlY3VyZS1vcmlnaW5zLWZvci1wb3dlcmZ1bC1uZXctZmVhdHVyZXNcbiAgdmFyIGlzTG9jYWxob3N0ID0gQm9vbGVhbih3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnIHx8XG4gICAgICAvLyBbOjoxXSBpcyB0aGUgSVB2NiBsb2NhbGhvc3QgYWRkcmVzcy5cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gJ1s6OjFdJyB8fFxuICAgICAgLy8gMTI3LjAuMC4xLzggaXMgY29uc2lkZXJlZCBsb2NhbGhvc3QgZm9yIElQdjQuXG4gICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUubWF0Y2goXG4gICAgICAgIC9eMTI3KD86XFwuKD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSl7M30kL1xuICAgICAgKVxuICAgICk7XG5cbiAgaWYgKCdzZXJ2aWNlV29ya2VyJyBpbiBuYXZpZ2F0b3IgJiZcbiAgICAgICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonIHx8IGlzTG9jYWxob3N0KSkge1xuICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKCdzZXJ2aWNlLXdvcmtlci5qcycpXG4gICAgLnRoZW4oZnVuY3Rpb24ocmVnaXN0cmF0aW9uKSB7XG4gICAgICAvLyB1cGRhdGVmb3VuZCBpcyBmaXJlZCBpZiBzZXJ2aWNlLXdvcmtlci5qcyBjaGFuZ2VzLlxuICAgICAgcmVnaXN0cmF0aW9uLm9udXBkYXRlZm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gdXBkYXRlZm91bmQgaXMgYWxzbyBmaXJlZCB0aGUgdmVyeSBmaXJzdCB0aW1lIHRoZSBTVyBpcyBpbnN0YWxsZWQsXG4gICAgICAgIC8vIGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gcHJvbXB0IGZvciBhIHJlbG9hZCBhdCB0aGF0IHBvaW50LlxuICAgICAgICAvLyBTbyBjaGVjayBoZXJlIHRvIHNlZSBpZiB0aGUgcGFnZSBpcyBhbHJlYWR5IGNvbnRyb2xsZWQsXG4gICAgICAgIC8vIGkuZS4gd2hldGhlciB0aGVyZSdzIGFuIGV4aXN0aW5nIHNlcnZpY2Ugd29ya2VyLlxuICAgICAgICBpZiAobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xuICAgICAgICAgIC8vIFRoZSB1cGRhdGVmb3VuZCBldmVudCBpbXBsaWVzIHRoYXQgcmVnaXN0cmF0aW9uLmluc3RhbGxpbmcgaXMgc2V0OlxuICAgICAgICAgIC8vIGh0dHBzOi8vc2xpZ2h0bHlvZmYuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvc3BlYy9zZXJ2aWNlX3dvcmtlci9pbmRleC5odG1sI3NlcnZpY2Utd29ya2VyLWNvbnRhaW5lci11cGRhdGVmb3VuZC1ldmVudFxuICAgICAgICAgIHZhciBpbnN0YWxsaW5nV29ya2VyID0gcmVnaXN0cmF0aW9uLmluc3RhbGxpbmc7XG5cbiAgICAgICAgICBpbnN0YWxsaW5nV29ya2VyLm9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5zdGFsbGluZ1dvcmtlci5zdGF0ZSkge1xuICAgICAgICAgICAgICBjYXNlICdpbnN0YWxsZWQnOlxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBvbGQgY29udGVudCB3aWxsIGhhdmUgYmVlbiBwdXJnZWQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGZyZXNoIGNvbnRlbnQgd2lsbCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgIC8vIEl0J3MgdGhlIHBlcmZlY3QgdGltZSB0byBkaXNwbGF5IGEgXCJOZXcgY29udGVudCBpc1xuICAgICAgICAgICAgICAgIC8vIGF2YWlsYWJsZTsgcGxlYXNlIHJlZnJlc2guXCIgbWVzc2FnZSBpbiB0aGUgcGFnZSdzIGludGVyZmFjZS5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdyZWR1bmRhbnQnOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluc3RhbGxpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZXJ2aWNlIHdvcmtlciBiZWNhbWUgcmVkdW5kYW50LicpO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uOicsIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gWW91ciBjdXN0b20gSmF2YVNjcmlwdCBnb2VzIGhlcmVcbn0pKCk7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=\n\n\"use strict\";var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {return typeof obj;} : function (obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;};(function e(t, n, r) {function s(o, u) {if (!n[o]) {if (!t[o]) {var a = typeof require == \"function\" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);throw new Error(\"Cannot find module '\" + o + \"'\");}var f = n[o] = { exports: {} };t[o][0].call(f.exports, function (e) {var n = t[o][1][e];return s(n ? n : e);}, f, f.exports, e, t, n, r);}return n[o].exports;}var i = typeof require == \"function\" && require;for (var o = 0; o < r.length; o++) {s(r[o]);}return s;})({ 1: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      // const BluetoothDevice = require('web-bluetooth');\n      // const stateManager = require('./app/state.js');\n\n      var service = '1ecce4f2-7f9e-11e6-ae22-56b6b6499611';\n      var characteristic = '488d7950-7f9e-11e6-ae22-56b6b6499611';\n\n      // const filter = {\n      //   name: 'MyDevice',\n      //   service: [service]\n      // };\n      var blue = void 0;\n\n      var connectButton = document.getElementById('js-connect');\n      // const disconnectButton = document.getElementById('js-disconnect');\n\n      var okButton = document.getElementById('js-ok');\n\n      // connectButton.addEventListener('click', () => {\n      //   connectButton.disabled = true;\n      //   stateManager.change('connecting');\n      //\n      //   blue = new BluetoothDevice(filter);\n      //   blue.connect()\n      //     .then(device => {\n      //       console.log(device);\n      //       stateManager.change('connected');\n      //       connectButton.disabled = false;\n      //     })\n      //     .catch(error => {\n      //       console.log(error);\n      //       stateManager.change('init');\n      //       connectButton.disabled = false;\n      //     });\n      // });\n      //\n      // disconnectButton.addEventListener('click', () => {\n      //   if (blue.disconnect()) {\n      //     stateManager.change('init');\n      //   } else {\n      //     console.log('error while disconnect');\n      //   }\n      // });\n\n      connectButton.addEventListener('click', function () {\n        console.log('Requesting Bluetooth Device...');\n        navigator.bluetooth.requestDevice({\n          filters: [{ services: [service] }] }).\n\n        then(function (device) {\n          console.log('Connecting to GATT Server...');\n          return device.gatt.connect();\n        }).\n        then(function (server) {\n          console.log('Getting Service...');\n          return server.getPrimaryService(service);\n        }).\n        then(function (service) {\n          console.log('Getting Characteristics...');\n          // if (characteristic) {\n          //   // Get all characteristics that match this UUID.\n          //   return service.getCharacteristics(characteristic);\n          // }\n          // Get all characteristics.\n          return service.getCharacteristic(characteristic);\n          // return service.getCharacteristics();\n        }).\n        then(function (characteristic) {\n          // Reading Battery Level...\n          return characteristic.readValue();\n        }).\n        then(function (value) {\n          console.log('Custom service: ' + value.getUint8(0));\n        }).\n        catch(function (error) {\n          console.log('Argh! ' + error);\n        });\n      });\n\n      okButton.addEventListener('click', function () {\n        console.log('read: ' + characteristic);\n        blue.getValue(characteristic).\n        then(function (value) {\n          console.log(value);\n        });\n        // console.log('write: 026683da-7f8b-11e6-ae22-56b6b6499611');\n        // blue.writeValue('026683da-7f8b-11e6-ae22-56b6b6499611', 'ok')\n        //   .then(writeSuccess => {\n        //     console.log(writeSuccess);\n        //   })\n        //   .catch(error => {\n        //     console.log(error);\n        //   });\n      });\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/fake_40d8e88c.js\", \"/\");\n  }, { \"b55mWE\": 4, \"buffer\": 3 }], 2: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n      ;(function (exports) {\n        'use strict';\n\n        var Arr = typeof Uint8Array !== 'undefined' ?\n        Uint8Array :\n        Array;\n\n        var PLUS = '+'.charCodeAt(0);\n        var SLASH = '/'.charCodeAt(0);\n        var NUMBER = '0'.charCodeAt(0);\n        var LOWER = 'a'.charCodeAt(0);\n        var UPPER = 'A'.charCodeAt(0);\n        var PLUS_URL_SAFE = '-'.charCodeAt(0);\n        var SLASH_URL_SAFE = '_'.charCodeAt(0);\n\n        function decode(elt) {\n          var code = elt.charCodeAt(0);\n          if (code === PLUS ||\n          code === PLUS_URL_SAFE)\n          return 62; // '+'\n          if (code === SLASH ||\n          code === SLASH_URL_SAFE)\n          return 63; // '/'\n          if (code < NUMBER)\n          return -1; //no match\n          if (code < NUMBER + 10)\n          return code - NUMBER + 26 + 26;\n          if (code < UPPER + 26)\n          return code - UPPER;\n          if (code < LOWER + 26)\n          return code - LOWER + 26;\n        }\n\n        function b64ToByteArray(b64) {\n          var i, j, l, tmp, placeHolders, arr;\n\n          if (b64.length % 4 > 0) {\n            throw new Error('Invalid string. Length must be a multiple of 4');\n          }\n\n          // the number of equal signs (place holders)\n          // if there are two placeholders, than the two characters before it\n          // represent one byte\n          // if there is only one, then the three characters before it represent 2 bytes\n          // this is just a cheap hack to not do indexOf twice\n          var len = b64.length;\n          placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;\n\n          // base64 is 4/3 + up to two characters of the original data\n          arr = new Arr(b64.length * 3 / 4 - placeHolders);\n\n          // if there are placeholders, only get up to the last complete 4 chars\n          l = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n          var L = 0;\n\n          function push(v) {\n            arr[L++] = v;\n          }\n\n          for (i = 0, j = 0; i < l; i += 4, j += 3) {\n            tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));\n            push((tmp & 0xFF0000) >> 16);\n            push((tmp & 0xFF00) >> 8);\n            push(tmp & 0xFF);\n          }\n\n          if (placeHolders === 2) {\n            tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;\n            push(tmp & 0xFF);\n          } else if (placeHolders === 1) {\n            tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;\n            push(tmp >> 8 & 0xFF);\n            push(tmp & 0xFF);\n          }\n\n          return arr;\n        }\n\n        function uint8ToBase64(uint8) {\n          var i,\n          extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n          output = \"\",\n          temp,length;\n\n          function encode(num) {\n            return lookup.charAt(num);\n          }\n\n          function tripletToBase64(num) {\n            return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);\n          }\n\n          // go through the array every three bytes, we'll deal with trailing stuff later\n          for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n            temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n            output += tripletToBase64(temp);\n          }\n\n          // pad the end with zeros, but make sure to not forget the extra bytes\n          switch (extraBytes) {\n            case 1:\n              temp = uint8[uint8.length - 1];\n              output += encode(temp >> 2);\n              output += encode(temp << 4 & 0x3F);\n              output += '==';\n              break;\n            case 2:\n              temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];\n              output += encode(temp >> 10);\n              output += encode(temp >> 4 & 0x3F);\n              output += encode(temp << 2 & 0x3F);\n              output += '=';\n              break;}\n\n\n          return output;\n        }\n\n        exports.toByteArray = b64ToByteArray;\n        exports.fromByteArray = uint8ToBase64;\n      })(typeof exports === 'undefined' ? this.base64js = {} : exports);\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js\", \"/../../node_modules/gulp-browserify/node_modules/base64-js/lib\");\n  }, { \"b55mWE\": 4, \"buffer\": 3 }], 3: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      /*!\n                                                                                                                     * The buffer module from node.js, for the browser.\n                                                                                                                     *\n                                                                                                                     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n                                                                                                                     * @license  MIT\n                                                                                                                     */\n\n      var base64 = require('base64-js');\n      var ieee754 = require('ieee754');\n\n      exports.Buffer = Buffer;\n      exports.SlowBuffer = Buffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      Buffer.poolSize = 8192;\n\n      /**\n                               * If `Buffer._useTypedArrays`:\n                               *   === true    Use Uint8Array implementation (fastest)\n                               *   === false   Use Object implementation (compatible down to IE6)\n                               */\n      Buffer._useTypedArrays = function () {\n        // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,\n        // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding\n        // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support\n        // because we need to be able to add all the node Buffer API methods. This is an issue\n        // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438\n        try {\n          var buf = new ArrayBuffer(0);\n          var arr = new Uint8Array(buf);\n          arr.foo = function () {return 42;};\n          return 42 === arr.foo() &&\n          typeof arr.subarray === 'function'; // Chrome 9-10 lack `subarray`\n        } catch (e) {\n          return false;\n        }\n      }();\n\n      /**\n            * Class: Buffer\n            * =============\n            *\n            * The Buffer constructor returns instances of `Uint8Array` that are augmented\n            * with function properties for all the node `Buffer` API functions. We use\n            * `Uint8Array` so that square bracket notation works as expected -- it returns\n            * a single octet.\n            *\n            * By augmenting the instances, we can avoid modifying the `Uint8Array`\n            * prototype.\n            */\n      function Buffer(subject, encoding, noZero) {\n        if (!(this instanceof Buffer))\n        return new Buffer(subject, encoding, noZero);\n\n        var type = typeof subject === \"undefined\" ? \"undefined\" : _typeof(subject);\n\n        // Workaround: node's base64 implementation allows for non-padded strings\n        // while base64-js does not.\n        if (encoding === 'base64' && type === 'string') {\n          subject = stringtrim(subject);\n          while (subject.length % 4 !== 0) {\n            subject = subject + '=';\n          }\n        }\n\n        // Find the length\n        var length;\n        if (type === 'number')\n        length = coerce(subject);else\n        if (type === 'string')\n        length = Buffer.byteLength(subject, encoding);else\n        if (type === 'object')\n        length = coerce(subject.length); // assume that object is array-like\n        else\n          throw new Error('First argument needs to be a number, array or string.');\n\n        var buf;\n        if (Buffer._useTypedArrays) {\n          // Preferred: Return an augmented `Uint8Array` instance for best performance\n          buf = Buffer._augment(new Uint8Array(length));\n        } else {\n          // Fallback: Return THIS instance of Buffer (created by `new`)\n          buf = this;\n          buf.length = length;\n          buf._isBuffer = true;\n        }\n\n        var i;\n        if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {\n          // Speed optimization -- use set if we're copying from a typed array\n          buf._set(subject);\n        } else if (isArrayish(subject)) {\n          // Treat array-ish objects as a byte array\n          for (i = 0; i < length; i++) {\n            if (Buffer.isBuffer(subject))\n            buf[i] = subject.readUInt8(i);else\n\n            buf[i] = subject[i];\n          }\n        } else if (type === 'string') {\n          buf.write(subject, 0, encoding);\n        } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {\n          for (i = 0; i < length; i++) {\n            buf[i] = 0;\n          }\n        }\n\n        return buf;\n      }\n\n      // STATIC METHODS\n      // ==============\n\n      Buffer.isEncoding = function (encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case 'hex':\n          case 'utf8':\n          case 'utf-8':\n          case 'ascii':\n          case 'binary':\n          case 'base64':\n          case 'raw':\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            return true;\n          default:\n            return false;}\n\n      };\n\n      Buffer.isBuffer = function (b) {\n        return !!(b !== null && b !== undefined && b._isBuffer);\n      };\n\n      Buffer.byteLength = function (str, encoding) {\n        var ret;\n        str = str + '';\n        switch (encoding || 'utf8') {\n          case 'hex':\n            ret = str.length / 2;\n            break;\n          case 'utf8':\n          case 'utf-8':\n            ret = utf8ToBytes(str).length;\n            break;\n          case 'ascii':\n          case 'binary':\n          case 'raw':\n            ret = str.length;\n            break;\n          case 'base64':\n            ret = base64ToBytes(str).length;\n            break;\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            ret = str.length * 2;\n            break;\n          default:\n            throw new Error('Unknown encoding');}\n\n        return ret;\n      };\n\n      Buffer.concat = function (list, totalLength) {\n        assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\\n' +\n        'list should be an Array.');\n\n        if (list.length === 0) {\n          return new Buffer(0);\n        } else if (list.length === 1) {\n          return list[0];\n        }\n\n        var i;\n        if (typeof totalLength !== 'number') {\n          totalLength = 0;\n          for (i = 0; i < list.length; i++) {\n            totalLength += list[i].length;\n          }\n        }\n\n        var buf = new Buffer(totalLength);\n        var pos = 0;\n        for (i = 0; i < list.length; i++) {\n          var item = list[i];\n          item.copy(buf, pos);\n          pos += item.length;\n        }\n        return buf;\n      };\n\n      // BUFFER INSTANCE METHODS\n      // =======================\n\n      function _hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        var remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n\n        // must be an even number of digits\n        var strLen = string.length;\n        assert(strLen % 2 === 0, 'Invalid hex string');\n\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        for (var i = 0; i < length; i++) {\n          var byte = parseInt(string.substr(i * 2, 2), 16);\n          assert(!isNaN(byte), 'Invalid hex string');\n          buf[offset + i] = byte;\n        }\n        Buffer._charsWritten = i * 2;\n        return i;\n      }\n\n      function _utf8Write(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(utf8ToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      function _asciiWrite(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(asciiToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      function _binaryWrite(buf, string, offset, length) {\n        return _asciiWrite(buf, string, offset, length);\n      }\n\n      function _base64Write(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(base64ToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      function _utf16leWrite(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(utf16leToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      Buffer.prototype.write = function (string, offset, length, encoding) {\n        // Support both (string, offset, length, encoding)\n        // and the legacy (string, encoding, offset, length)\n        if (isFinite(offset)) {\n          if (!isFinite(length)) {\n            encoding = length;\n            length = undefined;\n          }\n        } else {// legacy\n          var swap = encoding;\n          encoding = offset;\n          offset = length;\n          length = swap;\n        }\n\n        offset = Number(offset) || 0;\n        var remaining = this.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        encoding = String(encoding || 'utf8').toLowerCase();\n\n        var ret;\n        switch (encoding) {\n          case 'hex':\n            ret = _hexWrite(this, string, offset, length);\n            break;\n          case 'utf8':\n          case 'utf-8':\n            ret = _utf8Write(this, string, offset, length);\n            break;\n          case 'ascii':\n            ret = _asciiWrite(this, string, offset, length);\n            break;\n          case 'binary':\n            ret = _binaryWrite(this, string, offset, length);\n            break;\n          case 'base64':\n            ret = _base64Write(this, string, offset, length);\n            break;\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            ret = _utf16leWrite(this, string, offset, length);\n            break;\n          default:\n            throw new Error('Unknown encoding');}\n\n        return ret;\n      };\n\n      Buffer.prototype.toString = function (encoding, start, end) {\n        var self = this;\n\n        encoding = String(encoding || 'utf8').toLowerCase();\n        start = Number(start) || 0;\n        end = end !== undefined ?\n        Number(end) :\n        end = self.length;\n\n        // Fastpath empty strings\n        if (end === start)\n        return '';\n\n        var ret;\n        switch (encoding) {\n          case 'hex':\n            ret = _hexSlice(self, start, end);\n            break;\n          case 'utf8':\n          case 'utf-8':\n            ret = _utf8Slice(self, start, end);\n            break;\n          case 'ascii':\n            ret = _asciiSlice(self, start, end);\n            break;\n          case 'binary':\n            ret = _binarySlice(self, start, end);\n            break;\n          case 'base64':\n            ret = _base64Slice(self, start, end);\n            break;\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            ret = _utf16leSlice(self, start, end);\n            break;\n          default:\n            throw new Error('Unknown encoding');}\n\n        return ret;\n      };\n\n      Buffer.prototype.toJSON = function () {\n        return {\n          type: 'Buffer',\n          data: Array.prototype.slice.call(this._arr || this, 0) };\n\n      };\n\n      // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n      Buffer.prototype.copy = function (target, target_start, start, end) {\n        var source = this;\n\n        if (!start) start = 0;\n        if (!end && end !== 0) end = this.length;\n        if (!target_start) target_start = 0;\n\n        // Copy 0 bytes; we're done\n        if (end === start) return;\n        if (target.length === 0 || source.length === 0) return;\n\n        // Fatal error conditions\n        assert(end >= start, 'sourceEnd < sourceStart');\n        assert(target_start >= 0 && target_start < target.length,\n        'targetStart out of bounds');\n        assert(start >= 0 && start < source.length, 'sourceStart out of bounds');\n        assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds');\n\n        // Are we oob?\n        if (end > this.length)\n        end = this.length;\n        if (target.length - target_start < end - start)\n        end = target.length - target_start + start;\n\n        var len = end - start;\n\n        if (len < 100 || !Buffer._useTypedArrays) {\n          for (var i = 0; i < len; i++) {\n            target[i + target_start] = this[i + start];}\n        } else {\n          target._set(this.subarray(start, start + len), target_start);\n        }\n      };\n\n      function _base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n\n      function _utf8Slice(buf, start, end) {\n        var res = '';\n        var tmp = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; i++) {\n          if (buf[i] <= 0x7F) {\n            res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);\n            tmp = '';\n          } else {\n            tmp += '%' + buf[i].toString(16);\n          }\n        }\n\n        return res + decodeUtf8Char(tmp);\n      }\n\n      function _asciiSlice(buf, start, end) {\n        var ret = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; i++) {\n          ret += String.fromCharCode(buf[i]);}\n        return ret;\n      }\n\n      function _binarySlice(buf, start, end) {\n        return _asciiSlice(buf, start, end);\n      }\n\n      function _hexSlice(buf, start, end) {\n        var len = buf.length;\n\n        if (!start || start < 0) start = 0;\n        if (!end || end < 0 || end > len) end = len;\n\n        var out = '';\n        for (var i = start; i < end; i++) {\n          out += toHex(buf[i]);\n        }\n        return out;\n      }\n\n      function _utf16leSlice(buf, start, end) {\n        var bytes = buf.slice(start, end);\n        var res = '';\n        for (var i = 0; i < bytes.length; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n\n      Buffer.prototype.slice = function (start, end) {\n        var len = this.length;\n        start = clamp(start, len, 0);\n        end = clamp(end, len, len);\n\n        if (Buffer._useTypedArrays) {\n          return Buffer._augment(this.subarray(start, end));\n        } else {\n          var sliceLen = end - start;\n          var newBuf = new Buffer(sliceLen, undefined, true);\n          for (var i = 0; i < sliceLen; i++) {\n            newBuf[i] = this[i + start];\n          }\n          return newBuf;\n        }\n      };\n\n      // `get` will be removed in Node 0.13+\n      Buffer.prototype.get = function (offset) {\n        console.log('.get() is deprecated. Access using array indexes instead.');\n        return this.readUInt8(offset);\n      };\n\n      // `set` will be removed in Node 0.13+\n      Buffer.prototype.set = function (v, offset) {\n        console.log('.set() is deprecated. Access using array indexes instead.');\n        return this.writeUInt8(v, offset);\n      };\n\n      Buffer.prototype.readUInt8 = function (offset, noAssert) {\n        if (!noAssert) {\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset < this.length, 'Trying to read beyond buffer length');\n        }\n\n        if (offset >= this.length)\n        return;\n\n        return this[offset];\n      };\n\n      function _readUInt16(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val;\n        if (littleEndian) {\n          val = buf[offset];\n          if (offset + 1 < len)\n          val |= buf[offset + 1] << 8;\n        } else {\n          val = buf[offset] << 8;\n          if (offset + 1 < len)\n          val |= buf[offset + 1];\n        }\n        return val;\n      }\n\n      Buffer.prototype.readUInt16LE = function (offset, noAssert) {\n        return _readUInt16(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readUInt16BE = function (offset, noAssert) {\n        return _readUInt16(this, offset, false, noAssert);\n      };\n\n      function _readUInt32(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val;\n        if (littleEndian) {\n          if (offset + 2 < len)\n          val = buf[offset + 2] << 16;\n          if (offset + 1 < len)\n          val |= buf[offset + 1] << 8;\n          val |= buf[offset];\n          if (offset + 3 < len)\n          val = val + (buf[offset + 3] << 24 >>> 0);\n        } else {\n          if (offset + 1 < len)\n          val = buf[offset + 1] << 16;\n          if (offset + 2 < len)\n          val |= buf[offset + 2] << 8;\n          if (offset + 3 < len)\n          val |= buf[offset + 3];\n          val = val + (buf[offset] << 24 >>> 0);\n        }\n        return val;\n      }\n\n      Buffer.prototype.readUInt32LE = function (offset, noAssert) {\n        return _readUInt32(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readUInt32BE = function (offset, noAssert) {\n        return _readUInt32(this, offset, false, noAssert);\n      };\n\n      Buffer.prototype.readInt8 = function (offset, noAssert) {\n        if (!noAssert) {\n          assert(offset !== undefined && offset !== null,\n          'missing offset');\n          assert(offset < this.length, 'Trying to read beyond buffer length');\n        }\n\n        if (offset >= this.length)\n        return;\n\n        var neg = this[offset] & 0x80;\n        if (neg)\n        return (0xff - this[offset] + 1) * -1;else\n\n        return this[offset];\n      };\n\n      function _readInt16(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val = _readUInt16(buf, offset, littleEndian, true);\n        var neg = val & 0x8000;\n        if (neg)\n        return (0xffff - val + 1) * -1;else\n\n        return val;\n      }\n\n      Buffer.prototype.readInt16LE = function (offset, noAssert) {\n        return _readInt16(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readInt16BE = function (offset, noAssert) {\n        return _readInt16(this, offset, false, noAssert);\n      };\n\n      function _readInt32(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val = _readUInt32(buf, offset, littleEndian, true);\n        var neg = val & 0x80000000;\n        if (neg)\n        return (0xffffffff - val + 1) * -1;else\n\n        return val;\n      }\n\n      Buffer.prototype.readInt32LE = function (offset, noAssert) {\n        return _readInt32(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readInt32BE = function (offset, noAssert) {\n        return _readInt32(this, offset, false, noAssert);\n      };\n\n      function _readFloat(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        return ieee754.read(buf, offset, littleEndian, 23, 4);\n      }\n\n      Buffer.prototype.readFloatLE = function (offset, noAssert) {\n        return _readFloat(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readFloatBE = function (offset, noAssert) {\n        return _readFloat(this, offset, false, noAssert);\n      };\n\n      function _readDouble(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset + 7 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        return ieee754.read(buf, offset, littleEndian, 52, 8);\n      }\n\n      Buffer.prototype.readDoubleLE = function (offset, noAssert) {\n        return _readDouble(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readDoubleBE = function (offset, noAssert) {\n        return _readDouble(this, offset, false, noAssert);\n      };\n\n      Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset < this.length, 'trying to write beyond buffer length');\n          verifuint(value, 0xff);\n        }\n\n        if (offset >= this.length) return;\n\n        this[offset] = value;\n      };\n\n      function _writeUInt16(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'trying to write beyond buffer length');\n          verifuint(value, 0xffff);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {\n          buf[offset + i] =\n          (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>>\n          (littleEndian ? i : 1 - i) * 8;\n        }\n      }\n\n      Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n        _writeUInt16(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n        _writeUInt16(this, value, offset, false, noAssert);\n      };\n\n      function _writeUInt32(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'trying to write beyond buffer length');\n          verifuint(value, 0xffffffff);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {\n          buf[offset + i] =\n          value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n        }\n      }\n\n      Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n        _writeUInt32(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n        _writeUInt32(this, value, offset, false, noAssert);\n      };\n\n      Buffer.prototype.writeInt8 = function (value, offset, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset < this.length, 'Trying to write beyond buffer length');\n          verifsint(value, 0x7f, -0x80);\n        }\n\n        if (offset >= this.length)\n        return;\n\n        if (value >= 0)\n        this.writeUInt8(value, offset, noAssert);else\n\n        this.writeUInt8(0xff + value + 1, offset, noAssert);\n      };\n\n      function _writeInt16(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'Trying to write beyond buffer length');\n          verifsint(value, 0x7fff, -0x8000);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        if (value >= 0)\n        _writeUInt16(buf, value, offset, littleEndian, noAssert);else\n\n        _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert);\n      }\n\n      Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n        _writeInt16(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n        _writeInt16(this, value, offset, false, noAssert);\n      };\n\n      function _writeInt32(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');\n          verifsint(value, 0x7fffffff, -0x80000000);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        if (value >= 0)\n        _writeUInt32(buf, value, offset, littleEndian, noAssert);else\n\n        _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert);\n      }\n\n      Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n        _writeInt32(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n        _writeInt32(this, value, offset, false, noAssert);\n      };\n\n      function _writeFloat(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');\n          verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n      }\n\n      Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n        _writeFloat(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n        _writeFloat(this, value, offset, false, noAssert);\n      };\n\n      function _writeDouble(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 7 < buf.length,\n          'Trying to write beyond buffer length');\n          verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n      }\n\n      Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n        _writeDouble(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n        _writeDouble(this, value, offset, false, noAssert);\n      };\n\n      // fill(value, start=0, end=buffer.length)\n      Buffer.prototype.fill = function (value, start, end) {\n        if (!value) value = 0;\n        if (!start) start = 0;\n        if (!end) end = this.length;\n\n        if (typeof value === 'string') {\n          value = value.charCodeAt(0);\n        }\n\n        assert(typeof value === 'number' && !isNaN(value), 'value is not a number');\n        assert(end >= start, 'end < start');\n\n        // Fill 0 bytes; we're done\n        if (end === start) return;\n        if (this.length === 0) return;\n\n        assert(start >= 0 && start < this.length, 'start out of bounds');\n        assert(end >= 0 && end <= this.length, 'end out of bounds');\n\n        for (var i = start; i < end; i++) {\n          this[i] = value;\n        }\n      };\n\n      Buffer.prototype.inspect = function () {\n        var out = [];\n        var len = this.length;\n        for (var i = 0; i < len; i++) {\n          out[i] = toHex(this[i]);\n          if (i === exports.INSPECT_MAX_BYTES) {\n            out[i + 1] = '...';\n            break;\n          }\n        }\n        return '<Buffer ' + out.join(' ') + '>';\n      };\n\n      /**\n          * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n          * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n          */\n      Buffer.prototype.toArrayBuffer = function () {\n        if (typeof Uint8Array !== 'undefined') {\n          if (Buffer._useTypedArrays) {\n            return new Buffer(this).buffer;\n          } else {\n            var buf = new Uint8Array(this.length);\n            for (var i = 0, len = buf.length; i < len; i += 1) {\n              buf[i] = this[i];}\n            return buf.buffer;\n          }\n        } else {\n          throw new Error('Buffer.toArrayBuffer not supported in this browser');\n        }\n      };\n\n      // HELPER FUNCTIONS\n      // ================\n\n      function stringtrim(str) {\n        if (str.trim) return str.trim();\n        return str.replace(/^\\s+|\\s+$/g, '');\n      }\n\n      var BP = Buffer.prototype;\n\n      /**\n                                  * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n                                  */\n      Buffer._augment = function (arr) {\n        arr._isBuffer = true;\n\n        // save reference to original Uint8Array get/set methods before overwriting\n        arr._get = arr.get;\n        arr._set = arr.set;\n\n        // deprecated, will be removed in node 0.13+\n        arr.get = BP.get;\n        arr.set = BP.set;\n\n        arr.write = BP.write;\n        arr.toString = BP.toString;\n        arr.toLocaleString = BP.toString;\n        arr.toJSON = BP.toJSON;\n        arr.copy = BP.copy;\n        arr.slice = BP.slice;\n        arr.readUInt8 = BP.readUInt8;\n        arr.readUInt16LE = BP.readUInt16LE;\n        arr.readUInt16BE = BP.readUInt16BE;\n        arr.readUInt32LE = BP.readUInt32LE;\n        arr.readUInt32BE = BP.readUInt32BE;\n        arr.readInt8 = BP.readInt8;\n        arr.readInt16LE = BP.readInt16LE;\n        arr.readInt16BE = BP.readInt16BE;\n        arr.readInt32LE = BP.readInt32LE;\n        arr.readInt32BE = BP.readInt32BE;\n        arr.readFloatLE = BP.readFloatLE;\n        arr.readFloatBE = BP.readFloatBE;\n        arr.readDoubleLE = BP.readDoubleLE;\n        arr.readDoubleBE = BP.readDoubleBE;\n        arr.writeUInt8 = BP.writeUInt8;\n        arr.writeUInt16LE = BP.writeUInt16LE;\n        arr.writeUInt16BE = BP.writeUInt16BE;\n        arr.writeUInt32LE = BP.writeUInt32LE;\n        arr.writeUInt32BE = BP.writeUInt32BE;\n        arr.writeInt8 = BP.writeInt8;\n        arr.writeInt16LE = BP.writeInt16LE;\n        arr.writeInt16BE = BP.writeInt16BE;\n        arr.writeInt32LE = BP.writeInt32LE;\n        arr.writeInt32BE = BP.writeInt32BE;\n        arr.writeFloatLE = BP.writeFloatLE;\n        arr.writeFloatBE = BP.writeFloatBE;\n        arr.writeDoubleLE = BP.writeDoubleLE;\n        arr.writeDoubleBE = BP.writeDoubleBE;\n        arr.fill = BP.fill;\n        arr.inspect = BP.inspect;\n        arr.toArrayBuffer = BP.toArrayBuffer;\n\n        return arr;\n      };\n\n      // slice(start, end)\n      function clamp(index, len, defaultValue) {\n        if (typeof index !== 'number') return defaultValue;\n        index = ~~index; // Coerce to integer.\n        if (index >= len) return len;\n        if (index >= 0) return index;\n        index += len;\n        if (index >= 0) return index;\n        return 0;\n      }\n\n      function coerce(length) {\n        // Coerce length to a number (possibly NaN), round up\n        // in case it's fractional (e.g. 123.456) then do a\n        // double negate to coerce a NaN to 0. Easy, right?\n        length = ~~Math.ceil(+length);\n        return length < 0 ? 0 : length;\n      }\n\n      function isArray(subject) {\n        return (Array.isArray || function (subject) {\n          return Object.prototype.toString.call(subject) === '[object Array]';\n        })(subject);\n      }\n\n      function isArrayish(subject) {\n        return isArray(subject) || Buffer.isBuffer(subject) ||\n        subject && (typeof subject === \"undefined\" ? \"undefined\" : _typeof(subject)) === 'object' &&\n        typeof subject.length === 'number';\n      }\n\n      function toHex(n) {\n        if (n < 16) return '0' + n.toString(16);\n        return n.toString(16);\n      }\n\n      function utf8ToBytes(str) {\n        var byteArray = [];\n        for (var i = 0; i < str.length; i++) {\n          var b = str.charCodeAt(i);\n          if (b <= 0x7F)\n          byteArray.push(str.charCodeAt(i));else\n          {\n            var start = i;\n            if (b >= 0xD800 && b <= 0xDFFF) i++;\n            var h = encodeURIComponent(str.slice(start, i + 1)).substr(1).split('%');\n            for (var j = 0; j < h.length; j++) {\n              byteArray.push(parseInt(h[j], 16));}\n          }\n        }\n        return byteArray;\n      }\n\n      function asciiToBytes(str) {\n        var byteArray = [];\n        for (var i = 0; i < str.length; i++) {\n          // Node's code seems to be doing this and not & 0x7F..\n          byteArray.push(str.charCodeAt(i) & 0xFF);\n        }\n        return byteArray;\n      }\n\n      function utf16leToBytes(str) {\n        var c, hi, lo;\n        var byteArray = [];\n        for (var i = 0; i < str.length; i++) {\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n\n        return byteArray;\n      }\n\n      function base64ToBytes(str) {\n        return base64.toByteArray(str);\n      }\n\n      function blitBuffer(src, dst, offset, length) {\n        var pos;\n        for (var i = 0; i < length; i++) {\n          if (i + offset >= dst.length || i >= src.length)\n          break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n\n      function decodeUtf8Char(str) {\n        try {\n          return decodeURIComponent(str);\n        } catch (err) {\n          return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n        }\n      }\n\n      /*\n         * We have to make sure that the value is a valid integer. This means that it\n         * is non-negative. It has no fractional component and that it does not\n         * exceed the maximum allowed value.\n         */\n      function verifuint(value, max) {\n        assert(typeof value === 'number', 'cannot write a non-number as a number');\n        assert(value >= 0, 'specified a negative value for writing an unsigned value');\n        assert(value <= max, 'value is larger than maximum value for type');\n        assert(Math.floor(value) === value, 'value has a fractional component');\n      }\n\n      function verifsint(value, max, min) {\n        assert(typeof value === 'number', 'cannot write a non-number as a number');\n        assert(value <= max, 'value larger than maximum allowed value');\n        assert(value >= min, 'value smaller than minimum allowed value');\n        assert(Math.floor(value) === value, 'value has a fractional component');\n      }\n\n      function verifIEEE754(value, max, min) {\n        assert(typeof value === 'number', 'cannot write a non-number as a number');\n        assert(value <= max, 'value larger than maximum allowed value');\n        assert(value >= min, 'value smaller than minimum allowed value');\n      }\n\n      function assert(test, message) {\n        if (!test) throw new Error(message || 'Failed assertion');\n      }\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/gulp-browserify/node_modules/buffer/index.js\", \"/../../node_modules/gulp-browserify/node_modules/buffer\");\n  }, { \"b55mWE\": 4, \"base64-js\": 2, \"buffer\": 3, \"ieee754\": 5 }], 4: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      // shim for using process in browser\n\n      var process = module.exports = {};\n\n      process.nextTick = function () {\n        var canSetImmediate = typeof window !== 'undefined' &&\n        window.setImmediate;\n        var canPost = typeof window !== 'undefined' &&\n        window.postMessage && window.addEventListener;\n\n\n        if (canSetImmediate) {\n          return function (f) {return window.setImmediate(f);};\n        }\n\n        if (canPost) {\n          var queue = [];\n          window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n              ev.stopPropagation();\n              if (queue.length > 0) {\n                var fn = queue.shift();\n                fn();\n              }\n            }\n          }, true);\n\n          return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n          };\n        }\n\n        return function nextTick(fn) {\n          setTimeout(fn, 0);\n        };\n      }();\n\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      // TODO(shtylman)\n      process.cwd = function () {return '/';};\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/gulp-browserify/node_modules/process/browser.js\", \"/../../node_modules/gulp-browserify/node_modules/process\");\n  }, { \"b55mWE\": 4, \"buffer\": 3 }], 5: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s = buffer[offset + i];\n\n        i += d;\n\n        e = s & (1 << -nBits) - 1;\n        s >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n\n      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n\n        value = Math.abs(value);\n\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n        buffer[offset + i - d] |= s * 128;\n      };\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/ieee754/index.js\", \"/../../node_modules/ieee754\");\n  }, { \"b55mWE\": 4, \"buffer\": 3 }] }, {}, [1]);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qLnZhbGxlbHVuZ2EvV29ya3NwYWNlcy90ZXNpcy9zZWFtbGVzcy1wb3N0ZXItY29udHJvbC9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvai52YWxsZWx1bmdhL1dvcmtzcGFjZXMvdGVzaXMvc2VhbWxlc3MtcG9zdGVyLWNvbnRyb2wvYXBwL3NjcmlwdHMvZmFrZV80MGQ4ZTg4Yy5qcyIsIi9Vc2Vycy9qLnZhbGxlbHVuZ2EvV29ya3NwYWNlcy90ZXNpcy9zZWFtbGVzcy1wb3N0ZXItY29udHJvbC9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIi9Vc2Vycy9qLnZhbGxlbHVuZ2EvV29ya3NwYWNlcy90ZXNpcy9zZWFtbGVzcy1wb3N0ZXItY29udHJvbC9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCIvVXNlcnMvai52YWxsZWx1bmdhL1dvcmtzcGFjZXMvdGVzaXMvc2VhbWxlc3MtcG9zdGVyLWNvbnRyb2wvbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiL1VzZXJzL2oudmFsbGVsdW5nYS9Xb3Jrc3BhY2VzL3Rlc2lzL3NlYW1sZXNzLXBvc3Rlci1jb250cm9sL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUNBQTtBQUNBO0FBQ0EsQUFDQTs7QUFDQTtBQUNBLDJCQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFDQTs7QUFDQTtBQUNBLEFBQ0E7O0FBQ0EsNkNBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7ZUFDQTtlQUNBO21EQUNBO0FBQ0E7ZUFDQTtvREFDQTtBQUNBO2VBQ0E7cURBQ0E7QUFDQTtlQUNBO3FEQUNBO0FBQ0E7ZUFDQTtlQUNBO2VBQ0E7ZUFDQTtzREFDQTtBQUNBO0FBQ0E7NEJBQ0EsQUFDQTs7ZUFDQTtBQUNBOztBQUNBLGtFQUNBO21CQUNBLEFBQ0E7OzhDQUNBO2lDQUNBO3NCQUNBO2VBQ0E7bUJBQ0EsQUFDQTs7QUFDQTtvQkFDQTtlQUNBLEFBQ0E7O1lBQ0E7Z0JBQ0E7ZUFDQTt5Q0FDQTtBQUNBO2VBQ0E7ZUFDQTswQ0FDQTtBQUNBO2VBQ0E7MkNBQ0E7QUFDQTtlQUNBOzRDQUNBO0FBQ0E7ZUFDQTs0Q0FDQTtBQUNBO2VBQ0E7ZUFDQTtlQUNBO2VBQ0E7NkNBQ0E7QUFDQTtBQUNBOzRCQUNBLEFBQ0E7O2VBQ0E7QUFDQTs7QUFDQSw0Q0FDQTtlQUNBO2dCQUNBOzhEQUNBLEFBQ0E7O0FBQ0E7O0FBQ0E7QUFDQSwwRUFDQTtxQkFDQSxBQUNBOzs0QkFDQTswQ0FDQTswQ0FDQSxBQUNBOztBQUNBOzJCQUNBO3dEQUNBLEFBQ0E7O0FBQ0E7NkJBQ0E7MERBQ0E7QUFDQTtvREFDQTtpREFDQSxBQUNBOztBQUNBO3VCQUNBO21CQUNBO2lEQUNBOzZDQUNBLEFBQ0E7O3dCQUNBLEFBQ0E7O2tEQUNBO21DQUNBO2dEQUNBO2VBQ0E7eURBQ0E7QUFDQTtBQUNBOztBQUNBLDZDQUNBOytDQUNBO3NDQUNBO2VBQ0E7dURBQ0E7QUFDQTtBQUNBOztBQUNBLDJDQUNBO2tCQUNBO2tCQUNBO21DQUNBLEFBQ0E7OzBDQUNBOzhCQUNBO2lFQUNBO2tCQUNBO2lCQUNBO3lDQUNBO0FBQ0E7QUFDQSxBQUNBOztvQ0FDQTtBQUNBOztBQUNBLDRDQUNBO2tCQUNBO21DQUNBLEFBQ0E7O3FDQUNBO3lDQUNBO2VBQ0E7QUFDQTs7QUFDQSw2Q0FDQTt1Q0FDQTtBQUNBOztBQUNBLDBDQUNBO3NCQUNBLEFBQ0E7O3lDQUNBO2dEQUNBLEFBQ0E7O2tCQUNBOzBDQUNBOzJCQUNBO0FBQ0E7ZUFDQTtBQUNB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O2VBQ0E7Z0RBQ0E7aURBQ0E7QUFDQTtpQkFDQTtBQUNBOzhCQUNBOzBCQUNBO2lCQUNBOzBDQUNBO0FBQ0E7OEJBQ0E7QUFDQTtpQkFDQTtBQUNBLEFBQ0E7O2lDQUNBO2dCQUNBO2dCQUNBO3FDQUNBOzhDQUNBO29CQUNBO2lCQUNBOzZEQUNBO2dCQUNBO0FBQ0E7QUFDQSxBQUNBOzt1RkFDQSxBQUNBOzt3QkFDQTtnQkFDQTtzRkFDQSxBQUNBOztzQ0FDQTtBQUNBLEFBQ0E7OztvQ0x0RkEiLCJmaWxlIjoiYXBwLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBjb25zdCBCbHVldG9vdGhEZXZpY2UgPSByZXF1aXJlKCd3ZWItYmx1ZXRvb3RoJyk7XG4vLyBjb25zdCBzdGF0ZU1hbmFnZXIgPSByZXF1aXJlKCcuL2FwcC9zdGF0ZS5qcycpO1xuXG5jb25zdCBzZXJ2aWNlID0gJzFlY2NlNGYyLTdmOWUtMTFlNi1hZTIyLTU2YjZiNjQ5OTYxMSc7XG5jb25zdCBjaGFyYWN0ZXJpc3RpYyA9ICc0ODhkNzk1MC03ZjllLTExZTYtYWUyMi01NmI2YjY0OTk2MTEnO1xuXG4vLyBjb25zdCBmaWx0ZXIgPSB7XG4vLyAgIG5hbWU6ICdNeURldmljZScsXG4vLyAgIHNlcnZpY2U6IFtzZXJ2aWNlXVxuLy8gfTtcbmxldCBibHVlO1xuXG5jb25zdCBjb25uZWN0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2pzLWNvbm5lY3QnKTtcbi8vIGNvbnN0IGRpc2Nvbm5lY3RCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnanMtZGlzY29ubmVjdCcpO1xuXG5jb25zdCBva0J1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdqcy1vaycpO1xuXG4vLyBjb25uZWN0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuLy8gICBjb25uZWN0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbi8vICAgc3RhdGVNYW5hZ2VyLmNoYW5nZSgnY29ubmVjdGluZycpO1xuLy9cbi8vICAgYmx1ZSA9IG5ldyBCbHVldG9vdGhEZXZpY2UoZmlsdGVyKTtcbi8vICAgYmx1ZS5jb25uZWN0KClcbi8vICAgICAudGhlbihkZXZpY2UgPT4ge1xuLy8gICAgICAgY29uc29sZS5sb2coZGV2aWNlKTtcbi8vICAgICAgIHN0YXRlTWFuYWdlci5jaGFuZ2UoJ2Nvbm5lY3RlZCcpO1xuLy8gICAgICAgY29ubmVjdEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuLy8gICAgIH0pXG4vLyAgICAgLmNhdGNoKGVycm9yID0+IHtcbi8vICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbi8vICAgICAgIHN0YXRlTWFuYWdlci5jaGFuZ2UoJ2luaXQnKTtcbi8vICAgICAgIGNvbm5lY3RCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbi8vICAgICB9KTtcbi8vIH0pO1xuLy9cbi8vIGRpc2Nvbm5lY3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4vLyAgIGlmIChibHVlLmRpc2Nvbm5lY3QoKSkge1xuLy8gICAgIHN0YXRlTWFuYWdlci5jaGFuZ2UoJ2luaXQnKTtcbi8vICAgfSBlbHNlIHtcbi8vICAgICBjb25zb2xlLmxvZygnZXJyb3Igd2hpbGUgZGlzY29ubmVjdCcpO1xuLy8gICB9XG4vLyB9KTtcblxuY29ubmVjdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgY29uc29sZS5sb2coJ1JlcXVlc3RpbmcgQmx1ZXRvb3RoIERldmljZS4uLicpO1xuICBuYXZpZ2F0b3IuYmx1ZXRvb3RoLnJlcXVlc3REZXZpY2Uoe1xuICAgIGZpbHRlcnM6IFt7c2VydmljZXM6IFtzZXJ2aWNlXX1dXG4gIH0pXG4gIC50aGVuKGRldmljZSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0Nvbm5lY3RpbmcgdG8gR0FUVCBTZXJ2ZXIuLi4nKTtcbiAgICByZXR1cm4gZGV2aWNlLmdhdHQuY29ubmVjdCgpO1xuICB9KVxuICAudGhlbihzZXJ2ZXIgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIFNlcnZpY2UuLi4nKTtcbiAgICByZXR1cm4gc2VydmVyLmdldFByaW1hcnlTZXJ2aWNlKHNlcnZpY2UpO1xuICB9KVxuICAudGhlbihzZXJ2aWNlID0+IHtcbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyBDaGFyYWN0ZXJpc3RpY3MuLi4nKTtcbiAgICAvLyBpZiAoY2hhcmFjdGVyaXN0aWMpIHtcbiAgICAvLyAgIC8vIEdldCBhbGwgY2hhcmFjdGVyaXN0aWNzIHRoYXQgbWF0Y2ggdGhpcyBVVUlELlxuICAgIC8vICAgcmV0dXJuIHNlcnZpY2UuZ2V0Q2hhcmFjdGVyaXN0aWNzKGNoYXJhY3RlcmlzdGljKTtcbiAgICAvLyB9XG4gICAgLy8gR2V0IGFsbCBjaGFyYWN0ZXJpc3RpY3MuXG4gICAgcmV0dXJuIHNlcnZpY2UuZ2V0Q2hhcmFjdGVyaXN0aWMoY2hhcmFjdGVyaXN0aWMpO1xuICAgIC8vIHJldHVybiBzZXJ2aWNlLmdldENoYXJhY3RlcmlzdGljcygpO1xuICB9KVxuICAudGhlbihjaGFyYWN0ZXJpc3RpYyA9PiB7XG4gICAgLy8gUmVhZGluZyBCYXR0ZXJ5IExldmVsLi4uXG4gICAgcmV0dXJuIGNoYXJhY3RlcmlzdGljLnJlYWRWYWx1ZSgpO1xuICB9KVxuICAudGhlbih2YWx1ZSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0N1c3RvbSBzZXJ2aWNlOiAnICsgdmFsdWUuZ2V0VWludDgoMCkpO1xuICB9KVxuICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdBcmdoISAnICsgZXJyb3IpO1xuICB9KTtcbn0pO1xuXG5va0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgY29uc29sZS5sb2coJ3JlYWQ6ICcgKyBjaGFyYWN0ZXJpc3RpYyk7XG4gIGJsdWUuZ2V0VmFsdWUoY2hhcmFjdGVyaXN0aWMpXG4gICAgLnRoZW4odmFsdWUgPT4ge1xuICAgICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgIH0pO1xuICAvLyBjb25zb2xlLmxvZygnd3JpdGU6IDAyNjY4M2RhLTdmOGItMTFlNi1hZTIyLTU2YjZiNjQ5OTYxMScpO1xuICAvLyBibHVlLndyaXRlVmFsdWUoJzAyNjY4M2RhLTdmOGItMTFlNi1hZTIyLTU2YjZiNjQ5OTYxMScsICdvaycpXG4gIC8vICAgLnRoZW4od3JpdGVTdWNjZXNzID0+IHtcbiAgLy8gICAgIGNvbnNvbGUubG9nKHdyaXRlU3VjY2Vzcyk7XG4gIC8vICAgfSlcbiAgLy8gICAuY2F0Y2goZXJyb3IgPT4ge1xuICAvLyAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAvLyAgIH0pO1xufSk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYjU1bVdFXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvZmFrZV80MGQ4ZTg4Yy5qc1wiLFwiL1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImI1NW1XRVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTJcblxuLyoqXG4gKiBJZiBgQnVmZmVyLl91c2VUeXBlZEFycmF5c2A6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChjb21wYXRpYmxlIGRvd24gdG8gSUU2KVxuICovXG5CdWZmZXIuX3VzZVR5cGVkQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IGlmIGJyb3dzZXIgc3VwcG9ydHMgVHlwZWQgQXJyYXlzLiBTdXBwb3J0ZWQgYnJvd3NlcnMgYXJlIElFIDEwKywgRmlyZWZveCA0KyxcbiAgLy8gQ2hyb21lIDcrLCBTYWZhcmkgNS4xKywgT3BlcmEgMTEuNissIGlPUyA0LjIrLiBJZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGFkZGluZ1xuICAvLyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsIHRoZW4gdGhhdCdzIHRoZSBzYW1lIGFzIG5vIGBVaW50OEFycmF5YCBzdXBwb3J0XG4gIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBhYmxlIHRvIGFkZCBhbGwgdGhlIG5vZGUgQnVmZmVyIEFQSSBtZXRob2RzLiBUaGlzIGlzIGFuIGlzc3VlXG4gIC8vIGluIEZpcmVmb3ggNC0yOS4gTm93IGZpeGVkOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzhcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgLy8gQ2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdFxuXG4gIC8vIFdvcmthcm91bmQ6IG5vZGUncyBiYXNlNjQgaW1wbGVtZW50YXRpb24gYWxsb3dzIGZvciBub24tcGFkZGVkIHN0cmluZ3NcbiAgLy8gd2hpbGUgYmFzZTY0LWpzIGRvZXMgbm90LlxuICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgc3ViamVjdCA9IHN0cmluZ3RyaW0oc3ViamVjdClcbiAgICB3aGlsZSAoc3ViamVjdC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICBzdWJqZWN0ID0gc3ViamVjdCArICc9J1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aFxuICB2YXIgbGVuZ3RoXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdClcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0Lmxlbmd0aCkgLy8gYXNzdW1lIHRoYXQgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsIGFycmF5IG9yIHN0cmluZy4nKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAvLyBQcmVmZXJyZWQ6IFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYnVmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBidWYgPSB0aGlzXG4gICAgYnVmLmxlbmd0aCA9IGxlbmd0aFxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgaVxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgICAgZWxzZVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0W2ldXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbi8vIFNUQVRJQyBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gKGIpIHtcbiAgcmV0dXJuICEhKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHZhciByZXRcbiAgc3RyID0gc3RyICsgJydcbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAvIDJcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBhc3NlcnQoaXNBcnJheShsaXN0KSwgJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuJyArXG4gICAgICAnbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuLy8gQlVGRkVSIElOU1RBTkNFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIF9oZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGFzc2VydChzdHJMZW4gJSAyID09PSAwLCAnSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgYXNzZXJ0KCFpc05hTihieXRlKSwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gYnl0ZVxuICB9XG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gaSAqIDJcbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gX3V0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF9hc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBfYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX3V0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHsgIC8vIGxlZ2FjeVxuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IF9oZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSBfdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IF9hc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBfYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IF9iYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gX3V0ZjE2bGVXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG4gIHN0YXJ0ID0gTnVtYmVyKHN0YXJ0KSB8fCAwXG4gIGVuZCA9IChlbmQgIT09IHVuZGVmaW5lZClcbiAgICA/IE51bWJlcihlbmQpXG4gICAgOiBlbmQgPSBzZWxmLmxlbmd0aFxuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKGVuZCA9PT0gc3RhcnQpXG4gICAgcmV0dXJuICcnXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IF9oZXhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSBfdXRmOFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IF9hc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBfYmluYXJ5U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IF9iYXNlNjRTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gX3V0ZjE2bGVTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpc1xuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBhc3NlcnQodGFyZ2V0X3N0YXJ0ID49IDAgJiYgdGFyZ2V0X3N0YXJ0IDwgdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCBzb3VyY2UubGVuZ3RoLCAnc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gc291cmNlLmxlbmd0aCwgJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydClcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnRcblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAobGVuIDwgMTAwIHx8ICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gX3V0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBfYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBfYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIF9oZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIF91dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2krMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gY2xhbXAoc3RhcnQsIGxlbiwgMClcbiAgZW5kID0gY2xhbXAoZW5kLCBsZW4sIGxlbilcblxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRVSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAyXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gICAgdmFsIHw9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldCArIDNdIDw8IDI0ID4+PiAwKVxuICB9IGVsc2Uge1xuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDFdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDJdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgM11cbiAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldF0gPDwgMjQgPj4+IDApXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgdmFyIG5lZyA9IHRoaXNbb2Zmc2V0XSAmIDB4ODBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MTYoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZEludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IF9yZWFkVUludDMyKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDAwMDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmZmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZEZsb2F0IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRmxvYXQodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRG91YmxlIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZilcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVyblxuXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG59XG5cbmZ1bmN0aW9uIF93cml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MClcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgdGhpcy53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgdGhpcy53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQxNihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MTYoYnVmLCAweGZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICBfd3JpdGVVSW50MzIoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgX3dyaXRlVUludDMyKGJ1ZiwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKVxuICB9XG5cbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSwgJ3ZhbHVlIGlzIG5vdCBhIG51bWJlcicpXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHRoaXMubGVuZ3RoLCAnc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gdGhpcy5sZW5ndGgsICdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdmFsdWVcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvdXQgPSBbXVxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pXG4gICAgaWYgKGkgPT09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJ1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKVxuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5mdW5jdGlvbiBjbGFtcCAoaW5kZXgsIGxlbiwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSByZXR1cm4gZGVmYXVsdFZhbHVlXG4gIGluZGV4ID0gfn5pbmRleDsgIC8vIENvZXJjZSB0byBpbnRlZ2VyLlxuICBpZiAoaW5kZXggPj0gbGVuKSByZXR1cm4gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgaW5kZXggKz0gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gY29lcmNlIChsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKVxuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGhcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBBcnJheV0nXG4gIH0pKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspXG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHBvc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0XG4gKiBpcyBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdFxuICogZXhjZWVkIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmdWludCAodmFsdWUsIG1heCkge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPj0gMCwgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZnNpbnQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKHRlc3QsIG1lc3NhZ2UpIHtcbiAgaWYgKCF0ZXN0KSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnRmFpbGVkIGFzc2VydGlvbicpXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYjU1bVdFXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYjU1bVdFXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImI1NW1XRVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2llZWU3NTRcIikiXX0=\n","/*!\n *\n *  Web Starter Kit\n *  Copyright 2015 Google Inc. All rights reserved.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *    https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License\n *\n */\n/* eslint-env browser */\n(function() {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  var isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n      // [::1] is the IPv6 localhost address.\n      window.location.hostname === '[::1]' ||\n      // 127.0.0.1/8 is considered localhost for IPv4.\n      window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n      )\n    );\n\n  if ('serviceWorker' in navigator &&\n      (window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js')\n    .then(function(registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function() {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {\n          // The updatefound event implies that registration.installing is set:\n          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n          var installingWorker = registration.installing;\n\n          installingWorker.onstatechange = function() {\n            switch (installingWorker.state) {\n              case 'installed':\n                // At this point, the old content will have been purged and the\n                // fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in the page's interface.\n                break;\n\n              case 'redundant':\n                throw new Error('The installing ' +\n                                'service worker became redundant.');\n\n              default:\n                // Ignore\n            }\n          };\n        }\n      };\n    }).catch(function(e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n// const BluetoothDevice = require('web-bluetooth');\n// const stateManager = require('./app/state.js');\n\nconst service = '1ecce4f2-7f9e-11e6-ae22-56b6b6499611';\nconst characteristic = '488d7950-7f9e-11e6-ae22-56b6b6499611';\n\n// const filter = {\n//   name: 'MyDevice',\n//   service: [service]\n// };\nlet blue;\n\nconst connectButton = document.getElementById('js-connect');\n// const disconnectButton = document.getElementById('js-disconnect');\n\nconst okButton = document.getElementById('js-ok');\n\n// connectButton.addEventListener('click', () => {\n//   connectButton.disabled = true;\n//   stateManager.change('connecting');\n//\n//   blue = new BluetoothDevice(filter);\n//   blue.connect()\n//     .then(device => {\n//       console.log(device);\n//       stateManager.change('connected');\n//       connectButton.disabled = false;\n//     })\n//     .catch(error => {\n//       console.log(error);\n//       stateManager.change('init');\n//       connectButton.disabled = false;\n//     });\n// });\n//\n// disconnectButton.addEventListener('click', () => {\n//   if (blue.disconnect()) {\n//     stateManager.change('init');\n//   } else {\n//     console.log('error while disconnect');\n//   }\n// });\n\nconnectButton.addEventListener('click', () => {\n  console.log('Requesting Bluetooth Device...');\n  navigator.bluetooth.requestDevice({\n    filters: [{services: [service]}]\n  })\n  .then(device => {\n    console.log('Connecting to GATT Server...');\n    return device.gatt.connect();\n  })\n  .then(server => {\n    console.log('Getting Service...');\n    return server.getPrimaryService(service);\n  })\n  .then(service => {\n    console.log('Getting Characteristics...');\n    // if (characteristic) {\n    //   // Get all characteristics that match this UUID.\n    //   return service.getCharacteristics(characteristic);\n    // }\n    // Get all characteristics.\n    return service.getCharacteristic(characteristic);\n    // return service.getCharacteristics();\n  })\n  .then(characteristic => {\n    // Reading Battery Level...\n    return characteristic.readValue();\n  })\n  .then(value => {\n    console.log('Custom service: ' + value.getUint8(0));\n  })\n  .catch(error => {\n    console.log('Argh! ' + error);\n  });\n});\n\nokButton.addEventListener('click', () => {\n  console.log('read: ' + characteristic);\n  blue.getValue(characteristic)\n    .then(value => {\n      console.log(value);\n    });\n  // console.log('write: 026683da-7f8b-11e6-ae22-56b6b6499611');\n  // blue.writeValue('026683da-7f8b-11e6-ae22-56b6b6499611', 'ok')\n  //   .then(writeSuccess => {\n  //     console.log(writeSuccess);\n  //   })\n  //   .catch(error => {\n  //     console.log(error);\n  //   });\n});\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/fake_40d8e88c.js\",\"/\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js\",\"/../../node_modules/gulp-browserify/node_modules/base64-js/lib\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = Buffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192\n\n/**\n * If `Buffer._useTypedArrays`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (compatible down to IE6)\n */\nBuffer._useTypedArrays = (function () {\n  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,\n  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding\n  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support\n  // because we need to be able to add all the node Buffer API methods. This is an issue\n  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438\n  try {\n    var buf = new ArrayBuffer(0)\n    var arr = new Uint8Array(buf)\n    arr.foo = function () { return 42 }\n    return 42 === arr.foo() &&\n        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`\n  } catch (e) {\n    return false\n  }\n})()\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (subject, encoding, noZero) {\n  if (!(this instanceof Buffer))\n    return new Buffer(subject, encoding, noZero)\n\n  var type = typeof subject\n\n  // Workaround: node's base64 implementation allows for non-padded strings\n  // while base64-js does not.\n  if (encoding === 'base64' && type === 'string') {\n    subject = stringtrim(subject)\n    while (subject.length % 4 !== 0) {\n      subject = subject + '='\n    }\n  }\n\n  // Find the length\n  var length\n  if (type === 'number')\n    length = coerce(subject)\n  else if (type === 'string')\n    length = Buffer.byteLength(subject, encoding)\n  else if (type === 'object')\n    length = coerce(subject.length) // assume that object is array-like\n  else\n    throw new Error('First argument needs to be a number, array or string.')\n\n  var buf\n  if (Buffer._useTypedArrays) {\n    // Preferred: Return an augmented `Uint8Array` instance for best performance\n    buf = Buffer._augment(new Uint8Array(length))\n  } else {\n    // Fallback: Return THIS instance of Buffer (created by `new`)\n    buf = this\n    buf.length = length\n    buf._isBuffer = true\n  }\n\n  var i\n  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {\n    // Speed optimization -- use set if we're copying from a typed array\n    buf._set(subject)\n  } else if (isArrayish(subject)) {\n    // Treat array-ish objects as a byte array\n    for (i = 0; i < length; i++) {\n      if (Buffer.isBuffer(subject))\n        buf[i] = subject.readUInt8(i)\n      else\n        buf[i] = subject[i]\n    }\n  } else if (type === 'string') {\n    buf.write(subject, 0, encoding)\n  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {\n    for (i = 0; i < length; i++) {\n      buf[i] = 0\n    }\n  }\n\n  return buf\n}\n\n// STATIC METHODS\n// ==============\n\nBuffer.isEncoding = function (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.isBuffer = function (b) {\n  return !!(b !== null && b !== undefined && b._isBuffer)\n}\n\nBuffer.byteLength = function (str, encoding) {\n  var ret\n  str = str + ''\n  switch (encoding || 'utf8') {\n    case 'hex':\n      ret = str.length / 2\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8ToBytes(str).length\n      break\n    case 'ascii':\n    case 'binary':\n    case 'raw':\n      ret = str.length\n      break\n    case 'base64':\n      ret = base64ToBytes(str).length\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = str.length * 2\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.concat = function (list, totalLength) {\n  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\\n' +\n      'list should be an Array.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  } else if (list.length === 1) {\n    return list[0]\n  }\n\n  var i\n  if (typeof totalLength !== 'number') {\n    totalLength = 0\n    for (i = 0; i < list.length; i++) {\n      totalLength += list[i].length\n    }\n  }\n\n  var buf = new Buffer(totalLength)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\n// BUFFER INSTANCE METHODS\n// =======================\n\nfunction _hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  assert(strLen % 2 === 0, 'Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16)\n    assert(!isNaN(byte), 'Invalid hex string')\n    buf[offset + i] = byte\n  }\n  Buffer._charsWritten = i * 2\n  return i\n}\n\nfunction _utf8Write (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(utf8ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _asciiWrite (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(asciiToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _binaryWrite (buf, string, offset, length) {\n  return _asciiWrite(buf, string, offset, length)\n}\n\nfunction _base64Write (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(base64ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _utf16leWrite (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(utf16leToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nBuffer.prototype.write = function (string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length\n      length = undefined\n    }\n  } else {  // legacy\n    var swap = encoding\n    encoding = offset\n    offset = length\n    length = swap\n  }\n\n  offset = Number(offset) || 0\n  var remaining = this.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase()\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = _hexWrite(this, string, offset, length)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = _utf8Write(this, string, offset, length)\n      break\n    case 'ascii':\n      ret = _asciiWrite(this, string, offset, length)\n      break\n    case 'binary':\n      ret = _binaryWrite(this, string, offset, length)\n      break\n    case 'base64':\n      ret = _base64Write(this, string, offset, length)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = _utf16leWrite(this, string, offset, length)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toString = function (encoding, start, end) {\n  var self = this\n\n  encoding = String(encoding || 'utf8').toLowerCase()\n  start = Number(start) || 0\n  end = (end !== undefined)\n    ? Number(end)\n    : end = self.length\n\n  // Fastpath empty strings\n  if (end === start)\n    return ''\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = _hexSlice(self, start, end)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = _utf8Slice(self, start, end)\n      break\n    case 'ascii':\n      ret = _asciiSlice(self, start, end)\n      break\n    case 'binary':\n      ret = _binarySlice(self, start, end)\n      break\n    case 'base64':\n      ret = _base64Slice(self, start, end)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = _utf16leSlice(self, start, end)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toJSON = function () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function (target, target_start, start, end) {\n  var source = this\n\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (!target_start) target_start = 0\n\n  // Copy 0 bytes; we're done\n  if (end === start) return\n  if (target.length === 0 || source.length === 0) return\n\n  // Fatal error conditions\n  assert(end >= start, 'sourceEnd < sourceStart')\n  assert(target_start >= 0 && target_start < target.length,\n      'targetStart out of bounds')\n  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')\n  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length)\n    end = this.length\n  if (target.length - target_start < end - start)\n    end = target.length - target_start + start\n\n  var len = end - start\n\n  if (len < 100 || !Buffer._useTypedArrays) {\n    for (var i = 0; i < len; i++)\n      target[i + target_start] = this[i + start]\n  } else {\n    target._set(this.subarray(start, start + len), target_start)\n  }\n}\n\nfunction _base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction _utf8Slice (buf, start, end) {\n  var res = ''\n  var tmp = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    if (buf[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])\n      tmp = ''\n    } else {\n      tmp += '%' + buf[i].toString(16)\n    }\n  }\n\n  return res + decodeUtf8Char(tmp)\n}\n\nfunction _asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++)\n    ret += String.fromCharCode(buf[i])\n  return ret\n}\n\nfunction _binarySlice (buf, start, end) {\n  return _asciiSlice(buf, start, end)\n}\n\nfunction _hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction _utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function (start, end) {\n  var len = this.length\n  start = clamp(start, len, 0)\n  end = clamp(end, len, len)\n\n  if (Buffer._useTypedArrays) {\n    return Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    var newBuf = new Buffer(sliceLen, undefined, true)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n    return newBuf\n  }\n}\n\n// `get` will be removed in Node 0.13+\nBuffer.prototype.get = function (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` will be removed in Node 0.13+\nBuffer.prototype.set = function (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nBuffer.prototype.readUInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  return this[offset]\n}\n\nfunction _readUInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    val = buf[offset]\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n  } else {\n    val = buf[offset] << 8\n    if (offset + 1 < len)\n      val |= buf[offset + 1]\n  }\n  return val\n}\n\nBuffer.prototype.readUInt16LE = function (offset, noAssert) {\n  return _readUInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt16BE = function (offset, noAssert) {\n  return _readUInt16(this, offset, false, noAssert)\n}\n\nfunction _readUInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    if (offset + 2 < len)\n      val = buf[offset + 2] << 16\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n    val |= buf[offset]\n    if (offset + 3 < len)\n      val = val + (buf[offset + 3] << 24 >>> 0)\n  } else {\n    if (offset + 1 < len)\n      val = buf[offset + 1] << 16\n    if (offset + 2 < len)\n      val |= buf[offset + 2] << 8\n    if (offset + 3 < len)\n      val |= buf[offset + 3]\n    val = val + (buf[offset] << 24 >>> 0)\n  }\n  return val\n}\n\nBuffer.prototype.readUInt32LE = function (offset, noAssert) {\n  return _readUInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt32BE = function (offset, noAssert) {\n  return _readUInt32(this, offset, false, noAssert)\n}\n\nBuffer.prototype.readInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null,\n        'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  var neg = this[offset] & 0x80\n  if (neg)\n    return (0xff - this[offset] + 1) * -1\n  else\n    return this[offset]\n}\n\nfunction _readInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = _readUInt16(buf, offset, littleEndian, true)\n  var neg = val & 0x8000\n  if (neg)\n    return (0xffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt16LE = function (offset, noAssert) {\n  return _readInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt16BE = function (offset, noAssert) {\n  return _readInt16(this, offset, false, noAssert)\n}\n\nfunction _readInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = _readUInt32(buf, offset, littleEndian, true)\n  var neg = val & 0x80000000\n  if (neg)\n    return (0xffffffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt32LE = function (offset, noAssert) {\n  return _readInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt32BE = function (offset, noAssert) {\n  return _readInt32(this, offset, false, noAssert)\n}\n\nfunction _readFloat (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 23, 4)\n}\n\nBuffer.prototype.readFloatLE = function (offset, noAssert) {\n  return _readFloat(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readFloatBE = function (offset, noAssert) {\n  return _readFloat(this, offset, false, noAssert)\n}\n\nfunction _readDouble (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 52, 8)\n}\n\nBuffer.prototype.readDoubleLE = function (offset, noAssert) {\n  return _readDouble(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readDoubleBE = function (offset, noAssert) {\n  return _readDouble(this, offset, false, noAssert)\n}\n\nBuffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xff)\n  }\n\n  if (offset >= this.length) return\n\n  this[offset] = value\n}\n\nfunction _writeUInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {\n    buf[offset + i] =\n        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n            (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n  _writeUInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n  _writeUInt16(this, value, offset, false, noAssert)\n}\n\nfunction _writeUInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffffffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {\n    buf[offset + i] =\n        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n  _writeUInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n  _writeUInt32(this, value, offset, false, noAssert)\n}\n\nBuffer.prototype.writeInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7f, -0x80)\n  }\n\n  if (offset >= this.length)\n    return\n\n  if (value >= 0)\n    this.writeUInt8(value, offset, noAssert)\n  else\n    this.writeUInt8(0xff + value + 1, offset, noAssert)\n}\n\nfunction _writeInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fff, -0x8000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    _writeUInt16(buf, value, offset, littleEndian, noAssert)\n  else\n    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)\n}\n\nBuffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n  _writeInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n  _writeInt16(this, value, offset, false, noAssert)\n}\n\nfunction _writeInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fffffff, -0x80000000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    _writeUInt32(buf, value, offset, littleEndian, noAssert)\n  else\n    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)\n}\n\nBuffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n  _writeInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n  _writeInt32(this, value, offset, false, noAssert)\n}\n\nfunction _writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n}\n\nBuffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n  _writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n  _writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction _writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 7 < buf.length,\n        'Trying to write beyond buffer length')\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n}\n\nBuffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n  _writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n  _writeDouble(this, value, offset, false, noAssert)\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (typeof value === 'string') {\n    value = value.charCodeAt(0)\n  }\n\n  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')\n  assert(end >= start, 'end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  assert(start >= 0 && start < this.length, 'start out of bounds')\n  assert(end >= 0 && end <= this.length, 'end out of bounds')\n\n  for (var i = start; i < end; i++) {\n    this[i] = value\n  }\n}\n\nBuffer.prototype.inspect = function () {\n  var out = []\n  var len = this.length\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i])\n    if (i === exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...'\n      break\n    }\n  }\n  return '<Buffer ' + out.join(' ') + '>'\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer._useTypedArrays) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1)\n        buf[i] = this[i]\n      return buf.buffer\n    }\n  } else {\n    throw new Error('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function (arr) {\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array get/set methods before overwriting\n  arr._get = arr.get\n  arr._set = arr.set\n\n  // deprecated, will be removed in node 0.13+\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\n// slice(start, end)\nfunction clamp (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index;  // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\n\nfunction coerce (length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it's fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length)\n  return length < 0 ? 0 : length\n}\n\nfunction isArray (subject) {\n  return (Array.isArray || function (subject) {\n    return Object.prototype.toString.call(subject) === '[object Array]'\n  })(subject)\n}\n\nfunction isArrayish (subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n      subject && typeof subject === 'object' &&\n      typeof subject.length === 'number'\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    var b = str.charCodeAt(i)\n    if (b <= 0x7F)\n      byteArray.push(str.charCodeAt(i))\n    else {\n      var start = i\n      if (b >= 0xD800 && b <= 0xDFFF) i++\n      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16))\n    }\n  }\n  return byteArray\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(str)\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  var pos\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length))\n      break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction decodeUtf8Char (str) {\n  try {\n    return decodeURIComponent(str)\n  } catch (err) {\n    return String.fromCharCode(0xFFFD) // UTF 8 invalid char\n  }\n}\n\n/*\n * We have to make sure that the value is a valid integer. This means that it\n * is non-negative. It has no fractional component and that it does not\n * exceed the maximum allowed value.\n */\nfunction verifuint (value, max) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value >= 0, 'specified a negative value for writing an unsigned value')\n  assert(value <= max, 'value is larger than maximum value for type')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifsint (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifIEEE754 (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n}\n\nfunction assert (test, message) {\n  if (!test) throw new Error(message || 'Failed assertion')\n}\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/gulp-browserify/node_modules/buffer/index.js\",\"/../../node_modules/gulp-browserify/node_modules/buffer\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/gulp-browserify/node_modules/process/browser.js\",\"/../../node_modules/gulp-browserify/node_modules/process\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/ieee754/index.js\",\"/../../node_modules/ieee754\")","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})"],"sourceRoot":"/source/"}
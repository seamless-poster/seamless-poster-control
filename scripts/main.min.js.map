{"version":3,"sources":["main.min.js","/source/main.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/app/scripts/app/device.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/app/scripts/fake_d565b276.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/buffer/index.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/process/browser.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/ieee754/index.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/browser-pack/_prelude.js"],"names":["_classCallCheck","instance","Constructor","TypeError","isLocalhost","Boolean","window","location","hostname","match","navigator","protocol","serviceWorker","register","then","registration","onupdatefound","controller","installingWorker","installing","onstatechange","state","Error","e","console","error","_typeof","Symbol","iterator","obj","constructor","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","t","n","r","s","o","u","a","require","f","exports","call","1","module","process","global","Buffer","__argument0","__argument1","__argument2","__argument3","__filename","__dirname","PosterDevice","this","device","onDisconnected","bind","value","_this","log","options","filters","name","bluetooth","requestDevice","addEventListener","gatt","connect","Promise","reject","data","getPrimaryService","service","getCharacteristic","characteristic","writeValue","disconnect","posterDevice","self","arguments","b55mWE","buffer","2","blue","connectButton","document","getElementById","okButton","request","writeColor","getValue","./app/device.js","3","lookup","decode","elt","code","charCodeAt","PLUS","PLUS_URL_SAFE","SLASH","SLASH_URL_SAFE","NUMBER","UPPER","LOWER","b64ToByteArray","b64","push","v","arr","L","j","l","tmp","placeHolders","len","charAt","Arr","uint8ToBase64","uint8","encode","num","tripletToBase64","temp","extraBytes","output","Uint8Array","Array","toByteArray","fromByteArray","base64js","4","subject","encoding","noZero","type","stringtrim","coerce","byteLength","buf","_useTypedArrays","_augment","_isBuffer","_set","isArrayish","isBuffer","readUInt8","write","_hexWrite","string","offset","Number","remaining","strLen","assert","byte","parseInt","substr","isNaN","_charsWritten","_utf8Write","charsWritten","blitBuffer","utf8ToBytes","_asciiWrite","asciiToBytes","_binaryWrite","_base64Write","base64ToBytes","_utf16leWrite","utf16leToBytes","_base64Slice","start","end","base64","slice","_utf8Slice","res","Math","min","decodeUtf8Char","String","fromCharCode","toString","_asciiSlice","ret","_binarySlice","_hexSlice","out","toHex","_utf16leSlice","bytes","_readUInt16","littleEndian","noAssert","undefined","val","_readUInt32","_readInt16","neg","_readInt32","_readFloat","ieee754","read","_readDouble","_writeUInt16","verifuint","_writeUInt32","_writeInt16","verifsint","_writeInt32","_writeFloat","verifIEEE754","_writeDouble","str","trim","replace","clamp","index","defaultValue","ceil","isArray","byteArray","b","h","encodeURIComponent","split","c","hi","lo","src","dst","decodeURIComponent","err","max","floor","test","message","SlowBuffer","INSPECT_MAX_BYTES","poolSize","ArrayBuffer","foo","subarray","isEncoding","toLowerCase","concat","list","totalLength","pos","item","copy","isFinite","swap","toJSON","_arr","target_start","source","sliceLen","newBuf","get","set","writeUInt8","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","fill","inspect","join","toArrayBuffer","BP","_get","toLocaleString","base64-js","5","noop","nextTick","canSetImmediate","setImmediate","canPost","postMessage","queue","ev","stopPropagation","fn","shift","setTimeout","title","browser","env","argv","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","6","isLE","mLen","nBytes","m","eLen","eMax","eBias","nBits","d","NaN","Infinity","pow","rt","abs","LN2"],"mappings":"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GAAIiC,WKvXZ,EL0XQjC,EAAIyL,KAAOzL,EKvXnBuJ,ILwXQvJ,EAAIkC,KAAOlC,EKvXnBwJ,IL0XQxJ,EAAIuJ,IAAMiC,EKvXlBjC,ILwXQvJ,EAAIwJ,IAAMgC,EKvXlBhC,ILyXQxJ,EAAIsC,MAAQkJ,EKvXpBlJ,MLwXQtC,EAAI0E,SAAW8G,EKvXvB9G,SLwXQ1E,EAAI0L,eAAiBF,EKvX7B9G,SLwXQ1E,EAAIiJ,OAASuC,EKvXrBvC,OLwXQjJ,EAAI8I,KAAO0C,EKvXnB1C,KLwXQ9I,EAAIkE,MAAQsH,EKvXpBtH,MLwXQlE,EAAIqC,UAAYmJ,EKvXxBnJ,ULwXQrC,EAAI0J,aAAe8B,EKvX3B9B,aLwXQ1J,EAAI2J,aAAe6B,EKvX3B7B,aLwXQ3J,EAAI4J,aAAe4B,EKvX3B5B,aLwXQ5J,EAAI6J,aAAe2B,EKvX3B3B,aLwXQ7J,EAAI8J,SAAW0B,EKvXvB1B,SLwXQ9J,EAAI+J,YAAcyB,EKvX1BzB,YLwXQ/J,EAAIgK,YAAcwB,EKvX1BxB,YLwXQhK,EAAIiK,YAAcuB,EKvX1BvB,YLwXQjK,EAAIkK,YAAcsB,EKvX1BtB,YLwXQlK,EAAImK,YAAcqB,EKvX1BrB,YLwXQnK,EAAIoK,YAAcoB,EKvX1BpB,YLwXQpK,EAAIqK,aAAemB,EKvX3BnB,aLwXQrK,EAAIsK,aAAekB,EKvX3BlB,aLwXQtK,EAAIyJ,WAAa+B,EKvXzB/B,WLwXQzJ,EAAIuK,cAAgBiB,EKvX5BjB,cLwXQvK,EAAIwK,cAAgBgB,EKvX5BhB,cLwXQxK,EAAIyK,cAAgBe,EKvX5Bf,cLwXQzK,EAAI0K,cAAgBc,EKvX5Bd,cLwXQ1K,EAAI2K,UAAYa,EKvXxBb,ULwXQ3K,EAAI4K,aAAeY,EKvX3BZ,aLwXQ5K,EAAI6K,aAAeW,EKvX3BX,aLwXQ7K,EAAI8K,aAAeU,EKvX3BV,aLwXQ9K,EAAI+K,aAAeS,EKvX3BT,aLwXQ/K,EAAIgL,aAAeQ,EKvX3BR,aLwXQhL,EAAIiL,aAAeO,EKvX3BP,aLwXQjL,EAAIkL,cAAgBM,EKvX5BN,cLwXQlL,EAAImL,cAAgBK,EKvX5BL,cLwXQnL,EAAIoL,KAAOI,EKvX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","file":"main.min.js","sourcesContent":["'use strict'; /*!\n               *\n               *  Web Starter Kit\n               *  Copyright 2015 Google Inc. All rights reserved.\n               *\n               *  Licensed under the Apache License, Version 2.0 (the \"License\");\n               *  you may not use this file except in compliance with the License.\n               *  You may obtain a copy of the License at\n               *\n               *    https://www.apache.org/licenses/LICENSE-2.0\n               *\n               *  Unless required by applicable law or agreed to in writing, software\n               *  distributed under the License is distributed on an \"AS IS\" BASIS,\n               *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n               *  See the License for the specific language governing permissions and\n               *  limitations under the License\n               *\n               */\n/* eslint-env browser */\n(function () {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  var isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.1/8 is considered localhost for IPv4.\n  window.location.hostname.match(\n  /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));\n\n\n\n  if ('serviceWorker' in navigator && (\n  window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js').\n    then(function (registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function () {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {\n          // The updatefound event implies that registration.installing is set:\n          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n          var installingWorker = registration.installing;\n\n          installingWorker.onstatechange = function () {\n            switch (installingWorker.state) {\n              case 'installed':\n                // At this point, the old content will have been purged and the\n                // fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in the page's interface.\n                break;\n\n              case 'redundant':\n                throw new Error('The installing ' +\n                'service worker became redundant.');\n\n              default:\n              // Ignore\n            }\n          };\n        }\n      };\n    }).catch(function (e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uanMiXSwibmFtZXMiOlsiaXNMb2NhbGhvc3QiLCJCb29sZWFuIiwid2luZG93IiwibG9jYXRpb24iLCJob3N0bmFtZSIsIm1hdGNoIiwibmF2aWdhdG9yIiwicHJvdG9jb2wiLCJzZXJ2aWNlV29ya2VyIiwicmVnaXN0ZXIiLCJ0aGVuIiwicmVnaXN0cmF0aW9uIiwib251cGRhdGVmb3VuZCIsImNvbnRyb2xsZXIiLCJpbnN0YWxsaW5nV29ya2VyIiwiaW5zdGFsbGluZyIsIm9uc3RhdGVjaGFuZ2UiLCJzdGF0ZSIsIkVycm9yIiwiY2F0Y2giLCJlIiwiY29uc29sZSIsImVycm9yIl0sIm1hcHBpbmdzIjoiY0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBO0FBQ0EsQ0FBQyxZQUFXO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJQSxjQUFjQyxRQUFRQyxPQUFPQyxRQUFQLENBQWdCQyxRQUFoQixLQUE2QixXQUE3QjtBQUN0QjtBQUNBRixTQUFPQyxRQUFQLENBQWdCQyxRQUFoQixLQUE2QixPQUZQO0FBR3RCO0FBQ0FGLFNBQU9DLFFBQVAsQ0FBZ0JDLFFBQWhCLENBQXlCQyxLQUF6QjtBQUNFLDBEQURGLENBSmMsQ0FBbEI7Ozs7QUFTQSxNQUFJLG1CQUFtQkMsU0FBbkI7QUFDQ0osU0FBT0MsUUFBUCxDQUFnQkksUUFBaEIsS0FBNkIsUUFBN0IsSUFBeUNQLFdBRDFDLENBQUosRUFDNEQ7QUFDMURNLGNBQVVFLGFBQVYsQ0FBd0JDLFFBQXhCLENBQWlDLG1CQUFqQztBQUNDQyxRQURELENBQ00sVUFBU0MsWUFBVCxFQUF1QjtBQUMzQjtBQUNBQSxtQkFBYUMsYUFBYixHQUE2QixZQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSU4sVUFBVUUsYUFBVixDQUF3QkssVUFBNUIsRUFBd0M7QUFDdEM7QUFDQTtBQUNBLGNBQUlDLG1CQUFtQkgsYUFBYUksVUFBcEM7O0FBRUFELDJCQUFpQkUsYUFBakIsR0FBaUMsWUFBVztBQUMxQyxvQkFBUUYsaUJBQWlCRyxLQUF6QjtBQUNFLG1CQUFLLFdBQUw7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVGLG1CQUFLLFdBQUw7QUFDRSxzQkFBTSxJQUFJQyxLQUFKLENBQVU7QUFDQSxrREFEVixDQUFOOztBQUdGO0FBQ0U7QUFiSjtBQWVELFdBaEJEO0FBaUJEO0FBQ0YsT0E1QkQ7QUE2QkQsS0FoQ0QsRUFnQ0dDLEtBaENILENBZ0NTLFVBQVNDLENBQVQsRUFBWTtBQUNuQkMsY0FBUUMsS0FBUixDQUFjLDJDQUFkLEVBQTJERixDQUEzRDtBQUNELEtBbENEO0FBbUNEOztBQUVEO0FBQ0QsQ0F4REQiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICpcbiAqICBXZWIgU3RhcnRlciBLaXRcbiAqICBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlXG4gKlxuICovXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENoZWNrIHRvIG1ha2Ugc3VyZSBzZXJ2aWNlIHdvcmtlcnMgYXJlIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyLFxuICAvLyBhbmQgdGhhdCB0aGUgY3VycmVudCBwYWdlIGlzIGFjY2Vzc2VkIGZyb20gYSBzZWN1cmUgb3JpZ2luLiBVc2luZyBhXG4gIC8vIHNlcnZpY2Ugd29ya2VyIGZyb20gYW4gaW5zZWN1cmUgb3JpZ2luIHdpbGwgdHJpZ2dlciBKUyBjb25zb2xlIGVycm9ycy4gU2VlXG4gIC8vIGh0dHA6Ly93d3cuY2hyb21pdW0ub3JnL0hvbWUvY2hyb21pdW0tc2VjdXJpdHkvcHJlZmVyLXNlY3VyZS1vcmlnaW5zLWZvci1wb3dlcmZ1bC1uZXctZmVhdHVyZXNcbiAgdmFyIGlzTG9jYWxob3N0ID0gQm9vbGVhbih3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnIHx8XG4gICAgICAvLyBbOjoxXSBpcyB0aGUgSVB2NiBsb2NhbGhvc3QgYWRkcmVzcy5cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gJ1s6OjFdJyB8fFxuICAgICAgLy8gMTI3LjAuMC4xLzggaXMgY29uc2lkZXJlZCBsb2NhbGhvc3QgZm9yIElQdjQuXG4gICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUubWF0Y2goXG4gICAgICAgIC9eMTI3KD86XFwuKD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSl7M30kL1xuICAgICAgKVxuICAgICk7XG5cbiAgaWYgKCdzZXJ2aWNlV29ya2VyJyBpbiBuYXZpZ2F0b3IgJiZcbiAgICAgICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonIHx8IGlzTG9jYWxob3N0KSkge1xuICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKCdzZXJ2aWNlLXdvcmtlci5qcycpXG4gICAgLnRoZW4oZnVuY3Rpb24ocmVnaXN0cmF0aW9uKSB7XG4gICAgICAvLyB1cGRhdGVmb3VuZCBpcyBmaXJlZCBpZiBzZXJ2aWNlLXdvcmtlci5qcyBjaGFuZ2VzLlxuICAgICAgcmVnaXN0cmF0aW9uLm9udXBkYXRlZm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gdXBkYXRlZm91bmQgaXMgYWxzbyBmaXJlZCB0aGUgdmVyeSBmaXJzdCB0aW1lIHRoZSBTVyBpcyBpbnN0YWxsZWQsXG4gICAgICAgIC8vIGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gcHJvbXB0IGZvciBhIHJlbG9hZCBhdCB0aGF0IHBvaW50LlxuICAgICAgICAvLyBTbyBjaGVjayBoZXJlIHRvIHNlZSBpZiB0aGUgcGFnZSBpcyBhbHJlYWR5IGNvbnRyb2xsZWQsXG4gICAgICAgIC8vIGkuZS4gd2hldGhlciB0aGVyZSdzIGFuIGV4aXN0aW5nIHNlcnZpY2Ugd29ya2VyLlxuICAgICAgICBpZiAobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xuICAgICAgICAgIC8vIFRoZSB1cGRhdGVmb3VuZCBldmVudCBpbXBsaWVzIHRoYXQgcmVnaXN0cmF0aW9uLmluc3RhbGxpbmcgaXMgc2V0OlxuICAgICAgICAgIC8vIGh0dHBzOi8vc2xpZ2h0bHlvZmYuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvc3BlYy9zZXJ2aWNlX3dvcmtlci9pbmRleC5odG1sI3NlcnZpY2Utd29ya2VyLWNvbnRhaW5lci11cGRhdGVmb3VuZC1ldmVudFxuICAgICAgICAgIHZhciBpbnN0YWxsaW5nV29ya2VyID0gcmVnaXN0cmF0aW9uLmluc3RhbGxpbmc7XG5cbiAgICAgICAgICBpbnN0YWxsaW5nV29ya2VyLm9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5zdGFsbGluZ1dvcmtlci5zdGF0ZSkge1xuICAgICAgICAgICAgICBjYXNlICdpbnN0YWxsZWQnOlxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBvbGQgY29udGVudCB3aWxsIGhhdmUgYmVlbiBwdXJnZWQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGZyZXNoIGNvbnRlbnQgd2lsbCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgIC8vIEl0J3MgdGhlIHBlcmZlY3QgdGltZSB0byBkaXNwbGF5IGEgXCJOZXcgY29udGVudCBpc1xuICAgICAgICAgICAgICAgIC8vIGF2YWlsYWJsZTsgcGxlYXNlIHJlZnJlc2guXCIgbWVzc2FnZSBpbiB0aGUgcGFnZSdzIGludGVyZmFjZS5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdyZWR1bmRhbnQnOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluc3RhbGxpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZXJ2aWNlIHdvcmtlciBiZWNhbWUgcmVkdW5kYW50LicpO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uOicsIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gWW91ciBjdXN0b20gSmF2YVNjcmlwdCBnb2VzIGhlcmVcbn0pKCk7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=\n\n\"use strict\";var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {return typeof obj;} : function (obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;};var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}(function e(t, n, r) {function s(o, u) {if (!n[o]) {if (!t[o]) {var a = typeof require == \"function\" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);throw new Error(\"Cannot find module '\" + o + \"'\");}var f = n[o] = { exports: {} };t[o][0].call(f.exports, function (e) {var n = t[o][1][e];return s(n ? n : e);}, f, f.exports, e, t, n, r);}return n[o].exports;}var i = typeof require == \"function\" && require;for (var o = 0; o < r.length; o++) {s(r[o]);}return s;})({ 1: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {var\n      PosterDevice = function () {\n\n        function PosterDevice() {_classCallCheck(this, PosterDevice);\n          this.device = null;\n          this.onDisconnected = this.onDisconnected.bind(this);\n        }_createClass(PosterDevice, [{ key: \"request\", value: function request()\n\n          {var _this = this;\n            console.log('request');\n            var options = {\n              filters: [{\n                name: 'MyDevice' }] };\n\n\n            return navigator.bluetooth.requestDevice(options).\n            then(function (device) {\n              _this.device = device;\n              _this.device.addEventListener('gattserverdisconnected', _this.onDisconnected);\n              return device;\n            });\n          } }, { key: \"connect\", value: function connect()\n\n          {\n            console.log('connect');\n            if (this.device) {\n              return this.device.gatt.connect();\n            }\n            return Promise.reject('Device is not connected.');\n          } }, { key: \"writeColor\", value: function writeColor(\n\n          data) {\n            console.log('writeColor');\n            return this.device.gatt.getPrimaryService(0xFF02).\n            then(function (service) {return service.getCharacteristic(0xFFFC);}).\n            then(function (characteristic) {return characteristic.writeValue(data);});\n          } }, { key: \"disconnect\", value: function disconnect()\n\n          {\n            console.log('disconnect');\n            if (this.device) {\n              return this.device.gatt.disconnect();\n            }\n            return Promise.reject('Device is not connected.');\n          } }, { key: \"onDisconnected\", value: function onDisconnected()\n\n          {\n            console.log('onDisconnected');\n            console.log('Device is disconnected.');\n          } }]);return PosterDevice;}();\n\n\n      var posterDevice = new PosterDevice();\n      module.exports = posterDevice;\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/app/device.js\", \"/app\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }], 2: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      // const BluetoothDevice = require('web-bluetooth');\n      // const stateManager = require('./app/state.js');\n      var posterDevice = require('./app/device.js');\n\n      // const service = '1ecce4f2-7f9e-11e6-ae22-56b6b6499611';\n      var characteristic = '488d7950-7f9e-11e6-ae22-56b6b6499611';\n\n      // const filter = {\n      //   name: 'MyDevice',\n      //   service: [service]\n      // };\n      var blue = void 0;\n\n      var connectButton = document.getElementById('js-connect');\n      // const disconnectButton = document.getElementById('js-disconnect');\n\n      var okButton = document.getElementById('js-ok');\n\n      // connectButton.addEventListener('click', () => {\n      //   connectButton.disabled = true;\n      //   stateManager.change('connecting');\n      //\n      //   blue = new BluetoothDevice(filter);\n      //   blue.connect()\n      //     .then(device => {\n      //       console.log(device);\n      //       stateManager.change('connected');\n      //       connectButton.disabled = false;\n      //     })\n      //     .catch(error => {\n      //       console.log(error);\n      //       stateManager.change('init');\n      //       connectButton.disabled = false;\n      //     });\n      // });\n      //\n      // disconnectButton.addEventListener('click', () => {\n      //   if (blue.disconnect()) {\n      //     stateManager.change('init');\n      //   } else {\n      //     console.log('error while disconnect');\n      //   }\n      // });\n\n      connectButton.addEventListener('click', function () {\n        posterDevice.request().\n        then(function () {return posterDevice.connect();}).\n        then(function () {\n          posterDevice.writeColor('001122');\n        }).\n        catch(function (error) {\n          console.log(error);\n        });\n      });\n      // connectButton.addEventListener('click', () => {\n      //   console.log('Requesting Bluetooth Device...');\n      //   navigator.bluetooth.requestDevice({\n      //     filters: [{services: [service]}]\n      //   })\n      //   .then(device => {\n      //     console.log('Connecting to GATT Server...');\n      //     return device.gatt.connect();\n      //   })\n      //   .then(server => {\n      //     console.log('Getting Service...');\n      //     return server.getPrimaryService(service);\n      //   })\n      //   .then(service => {\n      //     console.log('Getting Characteristics...');\n      //     // if (characteristic) {\n      //     //   // Get all characteristics that match this UUID.\n      //     //   return service.getCharacteristics(characteristic);\n      //     // }\n      //     // Get all characteristics.\n      //     return service.getCharacteristic(characteristic);\n      //     // return service.getCharacteristics();\n      //   })\n      //   .then(characteristics => {\n      //     // console.log('> Characteristics: ' +\n      //     //   characteristics.map(c => c.uuid).join('\\n' + ' '.repeat(19)));\n      //\n      //     return characteristics[0].readValue();\n      //   })\n      //   .then(value => {\n      //     console.log('Battery percentage is ' + value.getUint8(0));\n      //   })\n      //   .catch(error => {\n      //     console.log('Argh! ' + error);\n      //   });\n      // });\n\n      okButton.addEventListener('click', function () {\n        console.log('read: ' + characteristic);\n        blue.getValue(characteristic).\n        then(function (value) {\n          console.log(value);\n        });\n        // console.log('write: 026683da-7f8b-11e6-ae22-56b6b6499611');\n        // blue.writeValue('026683da-7f8b-11e6-ae22-56b6b6499611', 'ok')\n        //   .then(writeSuccess => {\n        //     console.log(writeSuccess);\n        //   })\n        //   .catch(error => {\n        //     console.log(error);\n        //   });\n      });\n\n      console.log('2');\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/fake_d565b276.js\", \"/\");\n  }, { \"./app/device.js\": 1, \"b55mWE\": 5, \"buffer\": 4 }], 3: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n      ;(function (exports) {\n        'use strict';\n\n        var Arr = typeof Uint8Array !== 'undefined' ?\n        Uint8Array :\n        Array;\n\n        var PLUS = '+'.charCodeAt(0);\n        var SLASH = '/'.charCodeAt(0);\n        var NUMBER = '0'.charCodeAt(0);\n        var LOWER = 'a'.charCodeAt(0);\n        var UPPER = 'A'.charCodeAt(0);\n        var PLUS_URL_SAFE = '-'.charCodeAt(0);\n        var SLASH_URL_SAFE = '_'.charCodeAt(0);\n\n        function decode(elt) {\n          var code = elt.charCodeAt(0);\n          if (code === PLUS ||\n          code === PLUS_URL_SAFE)\n          return 62; // '+'\n          if (code === SLASH ||\n          code === SLASH_URL_SAFE)\n          return 63; // '/'\n          if (code < NUMBER)\n          return -1; //no match\n          if (code < NUMBER + 10)\n          return code - NUMBER + 26 + 26;\n          if (code < UPPER + 26)\n          return code - UPPER;\n          if (code < LOWER + 26)\n          return code - LOWER + 26;\n        }\n\n        function b64ToByteArray(b64) {\n          var i, j, l, tmp, placeHolders, arr;\n\n          if (b64.length % 4 > 0) {\n            throw new Error('Invalid string. Length must be a multiple of 4');\n          }\n\n          // the number of equal signs (place holders)\n          // if there are two placeholders, than the two characters before it\n          // represent one byte\n          // if there is only one, then the three characters before it represent 2 bytes\n          // this is just a cheap hack to not do indexOf twice\n          var len = b64.length;\n          placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;\n\n          // base64 is 4/3 + up to two characters of the original data\n          arr = new Arr(b64.length * 3 / 4 - placeHolders);\n\n          // if there are placeholders, only get up to the last complete 4 chars\n          l = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n          var L = 0;\n\n          function push(v) {\n            arr[L++] = v;\n          }\n\n          for (i = 0, j = 0; i < l; i += 4, j += 3) {\n            tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));\n            push((tmp & 0xFF0000) >> 16);\n            push((tmp & 0xFF00) >> 8);\n            push(tmp & 0xFF);\n          }\n\n          if (placeHolders === 2) {\n            tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;\n            push(tmp & 0xFF);\n          } else if (placeHolders === 1) {\n            tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;\n            push(tmp >> 8 & 0xFF);\n            push(tmp & 0xFF);\n          }\n\n          return arr;\n        }\n\n        function uint8ToBase64(uint8) {\n          var i,\n          extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n          output = \"\",\n          temp,length;\n\n          function encode(num) {\n            return lookup.charAt(num);\n          }\n\n          function tripletToBase64(num) {\n            return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);\n          }\n\n          // go through the array every three bytes, we'll deal with trailing stuff later\n          for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n            temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n            output += tripletToBase64(temp);\n          }\n\n          // pad the end with zeros, but make sure to not forget the extra bytes\n          switch (extraBytes) {\n            case 1:\n              temp = uint8[uint8.length - 1];\n              output += encode(temp >> 2);\n              output += encode(temp << 4 & 0x3F);\n              output += '==';\n              break;\n            case 2:\n              temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];\n              output += encode(temp >> 10);\n              output += encode(temp >> 4 & 0x3F);\n              output += encode(temp << 2 & 0x3F);\n              output += '=';\n              break;}\n\n\n          return output;\n        }\n\n        exports.toByteArray = b64ToByteArray;\n        exports.fromByteArray = uint8ToBase64;\n      })(typeof exports === 'undefined' ? this.base64js = {} : exports);\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js\", \"/../../node_modules/gulp-browserify/node_modules/base64-js/lib\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }], 4: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      /*!\n                                                                                                                     * The buffer module from node.js, for the browser.\n                                                                                                                     *\n                                                                                                                     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n                                                                                                                     * @license  MIT\n                                                                                                                     */\n\n      var base64 = require('base64-js');\n      var ieee754 = require('ieee754');\n\n      exports.Buffer = Buffer;\n      exports.SlowBuffer = Buffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      Buffer.poolSize = 8192;\n\n      /**\n                               * If `Buffer._useTypedArrays`:\n                               *   === true    Use Uint8Array implementation (fastest)\n                               *   === false   Use Object implementation (compatible down to IE6)\n                               */\n      Buffer._useTypedArrays = function () {\n        // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,\n        // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding\n        // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support\n        // because we need to be able to add all the node Buffer API methods. This is an issue\n        // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438\n        try {\n          var buf = new ArrayBuffer(0);\n          var arr = new Uint8Array(buf);\n          arr.foo = function () {return 42;};\n          return 42 === arr.foo() &&\n          typeof arr.subarray === 'function'; // Chrome 9-10 lack `subarray`\n        } catch (e) {\n          return false;\n        }\n      }();\n\n      /**\n            * Class: Buffer\n            * =============\n            *\n            * The Buffer constructor returns instances of `Uint8Array` that are augmented\n            * with function properties for all the node `Buffer` API functions. We use\n            * `Uint8Array` so that square bracket notation works as expected -- it returns\n            * a single octet.\n            *\n            * By augmenting the instances, we can avoid modifying the `Uint8Array`\n            * prototype.\n            */\n      function Buffer(subject, encoding, noZero) {\n        if (!(this instanceof Buffer))\n        return new Buffer(subject, encoding, noZero);\n\n        var type = typeof subject === \"undefined\" ? \"undefined\" : _typeof(subject);\n\n        // Workaround: node's base64 implementation allows for non-padded strings\n        // while base64-js does not.\n        if (encoding === 'base64' && type === 'string') {\n          subject = stringtrim(subject);\n          while (subject.length % 4 !== 0) {\n            subject = subject + '=';\n          }\n        }\n\n        // Find the length\n        var length;\n        if (type === 'number')\n        length = coerce(subject);else\n        if (type === 'string')\n        length = Buffer.byteLength(subject, encoding);else\n        if (type === 'object')\n        length = coerce(subject.length); // assume that object is array-like\n        else\n          throw new Error('First argument needs to be a number, array or string.');\n\n        var buf;\n        if (Buffer._useTypedArrays) {\n          // Preferred: Return an augmented `Uint8Array` instance for best performance\n          buf = Buffer._augment(new Uint8Array(length));\n        } else {\n          // Fallback: Return THIS instance of Buffer (created by `new`)\n          buf = this;\n          buf.length = length;\n          buf._isBuffer = true;\n        }\n\n        var i;\n        if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {\n          // Speed optimization -- use set if we're copying from a typed array\n          buf._set(subject);\n        } else if (isArrayish(subject)) {\n          // Treat array-ish objects as a byte array\n          for (i = 0; i < length; i++) {\n            if (Buffer.isBuffer(subject))\n            buf[i] = subject.readUInt8(i);else\n\n            buf[i] = subject[i];\n          }\n        } else if (type === 'string') {\n          buf.write(subject, 0, encoding);\n        } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {\n          for (i = 0; i < length; i++) {\n            buf[i] = 0;\n          }\n        }\n\n        return buf;\n      }\n\n      // STATIC METHODS\n      // ==============\n\n      Buffer.isEncoding = function (encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case 'hex':\n          case 'utf8':\n          case 'utf-8':\n          case 'ascii':\n          case 'binary':\n          case 'base64':\n          case 'raw':\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            return true;\n          default:\n            return false;}\n\n      };\n\n      Buffer.isBuffer = function (b) {\n        return !!(b !== null && b !== undefined && b._isBuffer);\n      };\n\n      Buffer.byteLength = function (str, encoding) {\n        var ret;\n        str = str + '';\n        switch (encoding || 'utf8') {\n          case 'hex':\n            ret = str.length / 2;\n            break;\n          case 'utf8':\n          case 'utf-8':\n            ret = utf8ToBytes(str).length;\n            break;\n          case 'ascii':\n          case 'binary':\n          case 'raw':\n            ret = str.length;\n            break;\n          case 'base64':\n            ret = base64ToBytes(str).length;\n            break;\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            ret = str.length * 2;\n            break;\n          default:\n            throw new Error('Unknown encoding');}\n\n        return ret;\n      };\n\n      Buffer.concat = function (list, totalLength) {\n        assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\\n' +\n        'list should be an Array.');\n\n        if (list.length === 0) {\n          return new Buffer(0);\n        } else if (list.length === 1) {\n          return list[0];\n        }\n\n        var i;\n        if (typeof totalLength !== 'number') {\n          totalLength = 0;\n          for (i = 0; i < list.length; i++) {\n            totalLength += list[i].length;\n          }\n        }\n\n        var buf = new Buffer(totalLength);\n        var pos = 0;\n        for (i = 0; i < list.length; i++) {\n          var item = list[i];\n          item.copy(buf, pos);\n          pos += item.length;\n        }\n        return buf;\n      };\n\n      // BUFFER INSTANCE METHODS\n      // =======================\n\n      function _hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        var remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n\n        // must be an even number of digits\n        var strLen = string.length;\n        assert(strLen % 2 === 0, 'Invalid hex string');\n\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        for (var i = 0; i < length; i++) {\n          var byte = parseInt(string.substr(i * 2, 2), 16);\n          assert(!isNaN(byte), 'Invalid hex string');\n          buf[offset + i] = byte;\n        }\n        Buffer._charsWritten = i * 2;\n        return i;\n      }\n\n      function _utf8Write(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(utf8ToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      function _asciiWrite(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(asciiToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      function _binaryWrite(buf, string, offset, length) {\n        return _asciiWrite(buf, string, offset, length);\n      }\n\n      function _base64Write(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(base64ToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      function _utf16leWrite(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(utf16leToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      Buffer.prototype.write = function (string, offset, length, encoding) {\n        // Support both (string, offset, length, encoding)\n        // and the legacy (string, encoding, offset, length)\n        if (isFinite(offset)) {\n          if (!isFinite(length)) {\n            encoding = length;\n            length = undefined;\n          }\n        } else {// legacy\n          var swap = encoding;\n          encoding = offset;\n          offset = length;\n          length = swap;\n        }\n\n        offset = Number(offset) || 0;\n        var remaining = this.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        encoding = String(encoding || 'utf8').toLowerCase();\n\n        var ret;\n        switch (encoding) {\n          case 'hex':\n            ret = _hexWrite(this, string, offset, length);\n            break;\n          case 'utf8':\n          case 'utf-8':\n            ret = _utf8Write(this, string, offset, length);\n            break;\n          case 'ascii':\n            ret = _asciiWrite(this, string, offset, length);\n            break;\n          case 'binary':\n            ret = _binaryWrite(this, string, offset, length);\n            break;\n          case 'base64':\n            ret = _base64Write(this, string, offset, length);\n            break;\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            ret = _utf16leWrite(this, string, offset, length);\n            break;\n          default:\n            throw new Error('Unknown encoding');}\n\n        return ret;\n      };\n\n      Buffer.prototype.toString = function (encoding, start, end) {\n        var self = this;\n\n        encoding = String(encoding || 'utf8').toLowerCase();\n        start = Number(start) || 0;\n        end = end !== undefined ?\n        Number(end) :\n        end = self.length;\n\n        // Fastpath empty strings\n        if (end === start)\n        return '';\n\n        var ret;\n        switch (encoding) {\n          case 'hex':\n            ret = _hexSlice(self, start, end);\n            break;\n          case 'utf8':\n          case 'utf-8':\n            ret = _utf8Slice(self, start, end);\n            break;\n          case 'ascii':\n            ret = _asciiSlice(self, start, end);\n            break;\n          case 'binary':\n            ret = _binarySlice(self, start, end);\n            break;\n          case 'base64':\n            ret = _base64Slice(self, start, end);\n            break;\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            ret = _utf16leSlice(self, start, end);\n            break;\n          default:\n            throw new Error('Unknown encoding');}\n\n        return ret;\n      };\n\n      Buffer.prototype.toJSON = function () {\n        return {\n          type: 'Buffer',\n          data: Array.prototype.slice.call(this._arr || this, 0) };\n\n      };\n\n      // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n      Buffer.prototype.copy = function (target, target_start, start, end) {\n        var source = this;\n\n        if (!start) start = 0;\n        if (!end && end !== 0) end = this.length;\n        if (!target_start) target_start = 0;\n\n        // Copy 0 bytes; we're done\n        if (end === start) return;\n        if (target.length === 0 || source.length === 0) return;\n\n        // Fatal error conditions\n        assert(end >= start, 'sourceEnd < sourceStart');\n        assert(target_start >= 0 && target_start < target.length,\n        'targetStart out of bounds');\n        assert(start >= 0 && start < source.length, 'sourceStart out of bounds');\n        assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds');\n\n        // Are we oob?\n        if (end > this.length)\n        end = this.length;\n        if (target.length - target_start < end - start)\n        end = target.length - target_start + start;\n\n        var len = end - start;\n\n        if (len < 100 || !Buffer._useTypedArrays) {\n          for (var i = 0; i < len; i++) {\n            target[i + target_start] = this[i + start];}\n        } else {\n          target._set(this.subarray(start, start + len), target_start);\n        }\n      };\n\n      function _base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n\n      function _utf8Slice(buf, start, end) {\n        var res = '';\n        var tmp = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; i++) {\n          if (buf[i] <= 0x7F) {\n            res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);\n            tmp = '';\n          } else {\n            tmp += '%' + buf[i].toString(16);\n          }\n        }\n\n        return res + decodeUtf8Char(tmp);\n      }\n\n      function _asciiSlice(buf, start, end) {\n        var ret = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; i++) {\n          ret += String.fromCharCode(buf[i]);}\n        return ret;\n      }\n\n      function _binarySlice(buf, start, end) {\n        return _asciiSlice(buf, start, end);\n      }\n\n      function _hexSlice(buf, start, end) {\n        var len = buf.length;\n\n        if (!start || start < 0) start = 0;\n        if (!end || end < 0 || end > len) end = len;\n\n        var out = '';\n        for (var i = start; i < end; i++) {\n          out += toHex(buf[i]);\n        }\n        return out;\n      }\n\n      function _utf16leSlice(buf, start, end) {\n        var bytes = buf.slice(start, end);\n        var res = '';\n        for (var i = 0; i < bytes.length; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n\n      Buffer.prototype.slice = function (start, end) {\n        var len = this.length;\n        start = clamp(start, len, 0);\n        end = clamp(end, len, len);\n\n        if (Buffer._useTypedArrays) {\n          return Buffer._augment(this.subarray(start, end));\n        } else {\n          var sliceLen = end - start;\n          var newBuf = new Buffer(sliceLen, undefined, true);\n          for (var i = 0; i < sliceLen; i++) {\n            newBuf[i] = this[i + start];\n          }\n          return newBuf;\n        }\n      };\n\n      // `get` will be removed in Node 0.13+\n      Buffer.prototype.get = function (offset) {\n        console.log('.get() is deprecated. Access using array indexes instead.');\n        return this.readUInt8(offset);\n      };\n\n      // `set` will be removed in Node 0.13+\n      Buffer.prototype.set = function (v, offset) {\n        console.log('.set() is deprecated. Access using array indexes instead.');\n        return this.writeUInt8(v, offset);\n      };\n\n      Buffer.prototype.readUInt8 = function (offset, noAssert) {\n        if (!noAssert) {\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset < this.length, 'Trying to read beyond buffer length');\n        }\n\n        if (offset >= this.length)\n        return;\n\n        return this[offset];\n      };\n\n      function _readUInt16(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val;\n        if (littleEndian) {\n          val = buf[offset];\n          if (offset + 1 < len)\n          val |= buf[offset + 1] << 8;\n        } else {\n          val = buf[offset] << 8;\n          if (offset + 1 < len)\n          val |= buf[offset + 1];\n        }\n        return val;\n      }\n\n      Buffer.prototype.readUInt16LE = function (offset, noAssert) {\n        return _readUInt16(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readUInt16BE = function (offset, noAssert) {\n        return _readUInt16(this, offset, false, noAssert);\n      };\n\n      function _readUInt32(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val;\n        if (littleEndian) {\n          if (offset + 2 < len)\n          val = buf[offset + 2] << 16;\n          if (offset + 1 < len)\n          val |= buf[offset + 1] << 8;\n          val |= buf[offset];\n          if (offset + 3 < len)\n          val = val + (buf[offset + 3] << 24 >>> 0);\n        } else {\n          if (offset + 1 < len)\n          val = buf[offset + 1] << 16;\n          if (offset + 2 < len)\n          val |= buf[offset + 2] << 8;\n          if (offset + 3 < len)\n          val |= buf[offset + 3];\n          val = val + (buf[offset] << 24 >>> 0);\n        }\n        return val;\n      }\n\n      Buffer.prototype.readUInt32LE = function (offset, noAssert) {\n        return _readUInt32(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readUInt32BE = function (offset, noAssert) {\n        return _readUInt32(this, offset, false, noAssert);\n      };\n\n      Buffer.prototype.readInt8 = function (offset, noAssert) {\n        if (!noAssert) {\n          assert(offset !== undefined && offset !== null,\n          'missing offset');\n          assert(offset < this.length, 'Trying to read beyond buffer length');\n        }\n\n        if (offset >= this.length)\n        return;\n\n        var neg = this[offset] & 0x80;\n        if (neg)\n        return (0xff - this[offset] + 1) * -1;else\n\n        return this[offset];\n      };\n\n      function _readInt16(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val = _readUInt16(buf, offset, littleEndian, true);\n        var neg = val & 0x8000;\n        if (neg)\n        return (0xffff - val + 1) * -1;else\n\n        return val;\n      }\n\n      Buffer.prototype.readInt16LE = function (offset, noAssert) {\n        return _readInt16(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readInt16BE = function (offset, noAssert) {\n        return _readInt16(this, offset, false, noAssert);\n      };\n\n      function _readInt32(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val = _readUInt32(buf, offset, littleEndian, true);\n        var neg = val & 0x80000000;\n        if (neg)\n        return (0xffffffff - val + 1) * -1;else\n\n        return val;\n      }\n\n      Buffer.prototype.readInt32LE = function (offset, noAssert) {\n        return _readInt32(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readInt32BE = function (offset, noAssert) {\n        return _readInt32(this, offset, false, noAssert);\n      };\n\n      function _readFloat(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        return ieee754.read(buf, offset, littleEndian, 23, 4);\n      }\n\n      Buffer.prototype.readFloatLE = function (offset, noAssert) {\n        return _readFloat(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readFloatBE = function (offset, noAssert) {\n        return _readFloat(this, offset, false, noAssert);\n      };\n\n      function _readDouble(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset + 7 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        return ieee754.read(buf, offset, littleEndian, 52, 8);\n      }\n\n      Buffer.prototype.readDoubleLE = function (offset, noAssert) {\n        return _readDouble(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readDoubleBE = function (offset, noAssert) {\n        return _readDouble(this, offset, false, noAssert);\n      };\n\n      Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset < this.length, 'trying to write beyond buffer length');\n          verifuint(value, 0xff);\n        }\n\n        if (offset >= this.length) return;\n\n        this[offset] = value;\n      };\n\n      function _writeUInt16(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'trying to write beyond buffer length');\n          verifuint(value, 0xffff);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {\n          buf[offset + i] =\n          (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>>\n          (littleEndian ? i : 1 - i) * 8;\n        }\n      }\n\n      Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n        _writeUInt16(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n        _writeUInt16(this, value, offset, false, noAssert);\n      };\n\n      function _writeUInt32(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'trying to write beyond buffer length');\n          verifuint(value, 0xffffffff);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {\n          buf[offset + i] =\n          value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n        }\n      }\n\n      Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n        _writeUInt32(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n        _writeUInt32(this, value, offset, false, noAssert);\n      };\n\n      Buffer.prototype.writeInt8 = function (value, offset, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset < this.length, 'Trying to write beyond buffer length');\n          verifsint(value, 0x7f, -0x80);\n        }\n\n        if (offset >= this.length)\n        return;\n\n        if (value >= 0)\n        this.writeUInt8(value, offset, noAssert);else\n\n        this.writeUInt8(0xff + value + 1, offset, noAssert);\n      };\n\n      function _writeInt16(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'Trying to write beyond buffer length');\n          verifsint(value, 0x7fff, -0x8000);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        if (value >= 0)\n        _writeUInt16(buf, value, offset, littleEndian, noAssert);else\n\n        _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert);\n      }\n\n      Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n        _writeInt16(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n        _writeInt16(this, value, offset, false, noAssert);\n      };\n\n      function _writeInt32(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');\n          verifsint(value, 0x7fffffff, -0x80000000);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        if (value >= 0)\n        _writeUInt32(buf, value, offset, littleEndian, noAssert);else\n\n        _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert);\n      }\n\n      Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n        _writeInt32(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n        _writeInt32(this, value, offset, false, noAssert);\n      };\n\n      function _writeFloat(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');\n          verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n      }\n\n      Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n        _writeFloat(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n        _writeFloat(this, value, offset, false, noAssert);\n      };\n\n      function _writeDouble(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 7 < buf.length,\n          'Trying to write beyond buffer length');\n          verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n      }\n\n      Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n        _writeDouble(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n        _writeDouble(this, value, offset, false, noAssert);\n      };\n\n      // fill(value, start=0, end=buffer.length)\n      Buffer.prototype.fill = function (value, start, end) {\n        if (!value) value = 0;\n        if (!start) start = 0;\n        if (!end) end = this.length;\n\n        if (typeof value === 'string') {\n          value = value.charCodeAt(0);\n        }\n\n        assert(typeof value === 'number' && !isNaN(value), 'value is not a number');\n        assert(end >= start, 'end < start');\n\n        // Fill 0 bytes; we're done\n        if (end === start) return;\n        if (this.length === 0) return;\n\n        assert(start >= 0 && start < this.length, 'start out of bounds');\n        assert(end >= 0 && end <= this.length, 'end out of bounds');\n\n        for (var i = start; i < end; i++) {\n          this[i] = value;\n        }\n      };\n\n      Buffer.prototype.inspect = function () {\n        var out = [];\n        var len = this.length;\n        for (var i = 0; i < len; i++) {\n          out[i] = toHex(this[i]);\n          if (i === exports.INSPECT_MAX_BYTES) {\n            out[i + 1] = '...';\n            break;\n          }\n        }\n        return '<Buffer ' + out.join(' ') + '>';\n      };\n\n      /**\n          * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n          * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n          */\n      Buffer.prototype.toArrayBuffer = function () {\n        if (typeof Uint8Array !== 'undefined') {\n          if (Buffer._useTypedArrays) {\n            return new Buffer(this).buffer;\n          } else {\n            var buf = new Uint8Array(this.length);\n            for (var i = 0, len = buf.length; i < len; i += 1) {\n              buf[i] = this[i];}\n            return buf.buffer;\n          }\n        } else {\n          throw new Error('Buffer.toArrayBuffer not supported in this browser');\n        }\n      };\n\n      // HELPER FUNCTIONS\n      // ================\n\n      function stringtrim(str) {\n        if (str.trim) return str.trim();\n        return str.replace(/^\\s+|\\s+$/g, '');\n      }\n\n      var BP = Buffer.prototype;\n\n      /**\n                                  * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n                                  */\n      Buffer._augment = function (arr) {\n        arr._isBuffer = true;\n\n        // save reference to original Uint8Array get/set methods before overwriting\n        arr._get = arr.get;\n        arr._set = arr.set;\n\n        // deprecated, will be removed in node 0.13+\n        arr.get = BP.get;\n        arr.set = BP.set;\n\n        arr.write = BP.write;\n        arr.toString = BP.toString;\n        arr.toLocaleString = BP.toString;\n        arr.toJSON = BP.toJSON;\n        arr.copy = BP.copy;\n        arr.slice = BP.slice;\n        arr.readUInt8 = BP.readUInt8;\n        arr.readUInt16LE = BP.readUInt16LE;\n        arr.readUInt16BE = BP.readUInt16BE;\n        arr.readUInt32LE = BP.readUInt32LE;\n        arr.readUInt32BE = BP.readUInt32BE;\n        arr.readInt8 = BP.readInt8;\n        arr.readInt16LE = BP.readInt16LE;\n        arr.readInt16BE = BP.readInt16BE;\n        arr.readInt32LE = BP.readInt32LE;\n        arr.readInt32BE = BP.readInt32BE;\n        arr.readFloatLE = BP.readFloatLE;\n        arr.readFloatBE = BP.readFloatBE;\n        arr.readDoubleLE = BP.readDoubleLE;\n        arr.readDoubleBE = BP.readDoubleBE;\n        arr.writeUInt8 = BP.writeUInt8;\n        arr.writeUInt16LE = BP.writeUInt16LE;\n        arr.writeUInt16BE = BP.writeUInt16BE;\n        arr.writeUInt32LE = BP.writeUInt32LE;\n        arr.writeUInt32BE = BP.writeUInt32BE;\n        arr.writeInt8 = BP.writeInt8;\n        arr.writeInt16LE = BP.writeInt16LE;\n        arr.writeInt16BE = BP.writeInt16BE;\n        arr.writeInt32LE = BP.writeInt32LE;\n        arr.writeInt32BE = BP.writeInt32BE;\n        arr.writeFloatLE = BP.writeFloatLE;\n        arr.writeFloatBE = BP.writeFloatBE;\n        arr.writeDoubleLE = BP.writeDoubleLE;\n        arr.writeDoubleBE = BP.writeDoubleBE;\n        arr.fill = BP.fill;\n        arr.inspect = BP.inspect;\n        arr.toArrayBuffer = BP.toArrayBuffer;\n\n        return arr;\n      };\n\n      // slice(start, end)\n      function clamp(index, len, defaultValue) {\n        if (typeof index !== 'number') return defaultValue;\n        index = ~~index; // Coerce to integer.\n        if (index >= len) return len;\n        if (index >= 0) return index;\n        index += len;\n        if (index >= 0) return index;\n        return 0;\n      }\n\n      function coerce(length) {\n        // Coerce length to a number (possibly NaN), round up\n        // in case it's fractional (e.g. 123.456) then do a\n        // double negate to coerce a NaN to 0. Easy, right?\n        length = ~~Math.ceil(+length);\n        return length < 0 ? 0 : length;\n      }\n\n      function isArray(subject) {\n        return (Array.isArray || function (subject) {\n          return Object.prototype.toString.call(subject) === '[object Array]';\n        })(subject);\n      }\n\n      function isArrayish(subject) {\n        return isArray(subject) || Buffer.isBuffer(subject) ||\n        subject && (typeof subject === \"undefined\" ? \"undefined\" : _typeof(subject)) === 'object' &&\n        typeof subject.length === 'number';\n      }\n\n      function toHex(n) {\n        if (n < 16) return '0' + n.toString(16);\n        return n.toString(16);\n      }\n\n      function utf8ToBytes(str) {\n        var byteArray = [];\n        for (var i = 0; i < str.length; i++) {\n          var b = str.charCodeAt(i);\n          if (b <= 0x7F)\n          byteArray.push(str.charCodeAt(i));else\n          {\n            var start = i;\n            if (b >= 0xD800 && b <= 0xDFFF) i++;\n            var h = encodeURIComponent(str.slice(start, i + 1)).substr(1).split('%');\n            for (var j = 0; j < h.length; j++) {\n              byteArray.push(parseInt(h[j], 16));}\n          }\n        }\n        return byteArray;\n      }\n\n      function asciiToBytes(str) {\n        var byteArray = [];\n        for (var i = 0; i < str.length; i++) {\n          // Node's code seems to be doing this and not & 0x7F..\n          byteArray.push(str.charCodeAt(i) & 0xFF);\n        }\n        return byteArray;\n      }\n\n      function utf16leToBytes(str) {\n        var c, hi, lo;\n        var byteArray = [];\n        for (var i = 0; i < str.length; i++) {\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n\n        return byteArray;\n      }\n\n      function base64ToBytes(str) {\n        return base64.toByteArray(str);\n      }\n\n      function blitBuffer(src, dst, offset, length) {\n        var pos;\n        for (var i = 0; i < length; i++) {\n          if (i + offset >= dst.length || i >= src.length)\n          break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n\n      function decodeUtf8Char(str) {\n        try {\n          return decodeURIComponent(str);\n        } catch (err) {\n          return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n        }\n      }\n\n      /*\n         * We have to make sure that the value is a valid integer. This means that it\n         * is non-negative. It has no fractional component and that it does not\n         * exceed the maximum allowed value.\n         */\n      function verifuint(value, max) {\n        assert(typeof value === 'number', 'cannot write a non-number as a number');\n        assert(value >= 0, 'specified a negative value for writing an unsigned value');\n        assert(value <= max, 'value is larger than maximum value for type');\n        assert(Math.floor(value) === value, 'value has a fractional component');\n      }\n\n      function verifsint(value, max, min) {\n        assert(typeof value === 'number', 'cannot write a non-number as a number');\n        assert(value <= max, 'value larger than maximum allowed value');\n        assert(value >= min, 'value smaller than minimum allowed value');\n        assert(Math.floor(value) === value, 'value has a fractional component');\n      }\n\n      function verifIEEE754(value, max, min) {\n        assert(typeof value === 'number', 'cannot write a non-number as a number');\n        assert(value <= max, 'value larger than maximum allowed value');\n        assert(value >= min, 'value smaller than minimum allowed value');\n      }\n\n      function assert(test, message) {\n        if (!test) throw new Error(message || 'Failed assertion');\n      }\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/gulp-browserify/node_modules/buffer/index.js\", \"/../../node_modules/gulp-browserify/node_modules/buffer\");\n  }, { \"b55mWE\": 5, \"base64-js\": 3, \"buffer\": 4, \"ieee754\": 6 }], 5: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      // shim for using process in browser\n\n      var process = module.exports = {};\n\n      process.nextTick = function () {\n        var canSetImmediate = typeof window !== 'undefined' &&\n        window.setImmediate;\n        var canPost = typeof window !== 'undefined' &&\n        window.postMessage && window.addEventListener;\n\n\n        if (canSetImmediate) {\n          return function (f) {return window.setImmediate(f);};\n        }\n\n        if (canPost) {\n          var queue = [];\n          window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n              ev.stopPropagation();\n              if (queue.length > 0) {\n                var fn = queue.shift();\n                fn();\n              }\n            }\n          }, true);\n\n          return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n          };\n        }\n\n        return function nextTick(fn) {\n          setTimeout(fn, 0);\n        };\n      }();\n\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      // TODO(shtylman)\n      process.cwd = function () {return '/';};\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/gulp-browserify/node_modules/process/browser.js\", \"/../../node_modules/gulp-browserify/node_modules/process\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }], 6: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s = buffer[offset + i];\n\n        i += d;\n\n        e = s & (1 << -nBits) - 1;\n        s >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n\n      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n\n        value = Math.abs(value);\n\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n        buffer[offset + i - d] |= s * 128;\n      };\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/ieee754/index.js\", \"/../../node_modules/ieee754\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }] }, {}, [2]);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qLnZhbGxlbHVuZ2EvV29ya3NwYWNlcy90ZXNpcy9zZWFtbGVzcy1wb3N0ZXItY29udHJvbC9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvai52YWxsZWx1bmdhL1dvcmtzcGFjZXMvdGVzaXMvc2VhbWxlc3MtcG9zdGVyLWNvbnRyb2wvYXBwL3NjcmlwdHMvYXBwL2RldmljZS5qcyIsIi9Vc2Vycy9qLnZhbGxlbHVuZ2EvV29ya3NwYWNlcy90ZXNpcy9zZWFtbGVzcy1wb3N0ZXItY29udHJvbC9hcHAvc2NyaXB0cy9mYWtlX2Q1NjViMjc2LmpzIiwiL1VzZXJzL2oudmFsbGVsdW5nYS9Xb3Jrc3BhY2VzL3Rlc2lzL3NlYW1sZXNzLXBvc3Rlci1jb250cm9sL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwiL1VzZXJzL2oudmFsbGVsdW5nYS9Xb3Jrc3BhY2VzL3Rlc2lzL3NlYW1sZXNzLXBvc3Rlci1jb250cm9sL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi9Vc2Vycy9qLnZhbGxlbHVuZ2EvV29ya3NwYWNlcy90ZXNpcy9zZWFtbGVzcy1wb3N0ZXItY29udHJvbC9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvai52YWxsZWx1bmdhL1dvcmtzcGFjZXMvdGVzaXMvc2VhbWxlc3MtcG9zdGVyLWNvbnRyb2wvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQ0FBO0FBRUEsQUFDQTs7Z0NBQ0E7d0JBQ0E7eURBQ0E7QUFDQSxBQUNBLFNBUEE7O0FBUUE7d0JBQ0E7MEJBQ0E7d0JBQ0E7c0JBQ0EsQUFDQSxBQUNBOzs7cURBQ0E7bUNBQ0E7NkJBQ0E7NEVBQ0E7cUJBQ0E7QUFDQTtBQUNBLEFBQ0E7O0FBQ0E7d0JBQ0E7NkJBQ0E7c0NBQ0E7QUFDQTtrQ0FDQTtBQUNBLEFBQ0E7O2dCQUNBO3dCQUNBO3NEQUNBO3NFQUNBOzZFQUNBO0FBQ0EsQUFDQTs7QUFDQTt3QkFDQTs2QkFDQTtzQ0FDQTtBQUNBO2tDQUNBO0FBQ0EsQUFDQTs7QUFDQTt3QkFDQTt3QkFDQTtBQUNBLEFBQ0E7OztBQUNBO0FBQ0EsdUJBQ0EsQUFDQTs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQSxpQ0FDQTs7QUFDQTtBQUNBLDJCQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFDQTs7QUFDQTtBQUNBLEFBQ0E7O0FBQ0EsNkNBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQUFDQTs7QUFDQSwwREFDQTtxQkFDQTs4Q0FDQTt5QkFDQTtrQ0FDQTtBQUNBOytCQUNBO3NCQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEFBQ0E7O0FBQ0EscURBQ0E7K0JBQ0E7c0JBQ0E7OEJBQ0E7c0JBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxrQkFDQSxBQUNBOzs7O0FDOUdBO0FBQ0EsbUJBQ0E7O0FBQ0EsMkJBQ0E7QUFDQSxBQUNBOzt3Q0FDQTtBQUNBO0FBQ0EsQUFDQTs7a0NBQ0E7bUNB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QUNBO0FBQ0E7QUFDQSxBQUNBOztxQ0FDQTt5QkFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQ0E7O0FBQ0EsdUJBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQ0E7O0FBQ0Esd0NBQ0E7d0JBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EscUNBQ0E7d0JBQ0E7QUFDQSxBQUNBOzs7O0FDakVBO0FBQ0EsbUVBQ0E7ZUFDQTt1Q0FDQTtpQ0FDQTs0QkFDQTtxQkFDQTtvQ0FDQTs0QkFDQTtnQ0FDQSxBQUNBOzthQUNBLEFBQ0E7O2dDQUNBO2VBQ0E7aUJBQ0E7aUZBQ0EsQUFDQTs7Z0NBQ0E7ZUFDQTtpQkFDQTtpRkFDQSxBQUNBOztxQkFDQTtrQkFDQTsrQkFDQTswQ0FDQTtlQUNBOzhCQUNBO2tCQUNBO0FBQ0E7a0RBQ0E7QUFDQTs7QUFDQSwyRUFDQTtrQkFDQTt1Q0FDQTtpQ0FDQTs0QkFDQTtxRUFDQTtvQ0FDQTs0QkFDQTtnRUFDQSxBQUNBOzt5QkFDQSxBQUNBOztnREFDQTtpQ0FDQTtjQUNBO2VBQ0E7Z0RBQ0E7aURBQ0E7QUFDQTtpQkFDQTtBQUNBOzhCQUNBOzBCQUNBO2lCQUNBOzBDQUNBO0FBQ0E7OEJBQ0E7QUFDQTtpQkFDQTtBQUNBLEFBQ0E7O2lDQUNBO2dCQUNBO2dCQUNBO3FDQUNBOzhDQUNBO29CQUNBO2lCQUNBOzZEQUNBO2dCQUNBO0FBQ0E7QUFDQSxBQUNBOzt1RkFDQSxBQUNBOzt3QkFDQTtnQkFDQTtzRkFDQSxBQUNBOztzQ0FDQTtBQUNBLEFBQ0E7OztvQ050RkEiLCJmaWxlIjoiYXBwLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5jbGFzcyBQb3N0ZXJEZXZpY2Uge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGV2aWNlID0gbnVsbDtcbiAgICB0aGlzLm9uRGlzY29ubmVjdGVkID0gdGhpcy5vbkRpc2Nvbm5lY3RlZC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgcmVxdWVzdCgpIHtcbiAgICBjb25zb2xlLmxvZygncmVxdWVzdCcpO1xuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgZmlsdGVyczogW3tcbiAgICAgICAgbmFtZTogJ015RGV2aWNlJ1xuICAgICAgfV1cbiAgICB9O1xuICAgIHJldHVybiBuYXZpZ2F0b3IuYmx1ZXRvb3RoLnJlcXVlc3REZXZpY2Uob3B0aW9ucylcbiAgICAudGhlbihkZXZpY2UgPT4ge1xuICAgICAgdGhpcy5kZXZpY2UgPSBkZXZpY2U7XG4gICAgICB0aGlzLmRldmljZS5hZGRFdmVudExpc3RlbmVyKCdnYXR0c2VydmVyZGlzY29ubmVjdGVkJywgdGhpcy5vbkRpc2Nvbm5lY3RlZCk7XG4gICAgICByZXR1cm4gZGV2aWNlO1xuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdCgpIHtcbiAgICBjb25zb2xlLmxvZygnY29ubmVjdCcpO1xuICAgIGlmICh0aGlzLmRldmljZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGV2aWNlLmdhdHQuY29ubmVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0RldmljZSBpcyBub3QgY29ubmVjdGVkLicpO1xuICB9XG5cbiAgd3JpdGVDb2xvcihkYXRhKSB7XG4gICAgY29uc29sZS5sb2coJ3dyaXRlQ29sb3InKTtcbiAgICByZXR1cm4gdGhpcy5kZXZpY2UuZ2F0dC5nZXRQcmltYXJ5U2VydmljZSgweEZGMDIpXG4gICAgLnRoZW4oc2VydmljZSA9PiBzZXJ2aWNlLmdldENoYXJhY3RlcmlzdGljKDB4RkZGQykpXG4gICAgLnRoZW4oY2hhcmFjdGVyaXN0aWMgPT4gY2hhcmFjdGVyaXN0aWMud3JpdGVWYWx1ZShkYXRhKSk7XG4gIH1cblxuICBkaXNjb25uZWN0KCkge1xuICAgIGNvbnNvbGUubG9nKCdkaXNjb25uZWN0Jyk7XG4gICAgaWYgKHRoaXMuZGV2aWNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXZpY2UuZ2F0dC5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnRGV2aWNlIGlzIG5vdCBjb25uZWN0ZWQuJyk7XG4gIH1cblxuICBvbkRpc2Nvbm5lY3RlZCgpIHtcbiAgICBjb25zb2xlLmxvZygnb25EaXNjb25uZWN0ZWQnKTtcbiAgICBjb25zb2xlLmxvZygnRGV2aWNlIGlzIGRpc2Nvbm5lY3RlZC4nKTtcbiAgfVxufVxuXG5jb25zdCBwb3N0ZXJEZXZpY2UgPSBuZXcgUG9zdGVyRGV2aWNlKCk7XG5tb2R1bGUuZXhwb3J0cyA9IHBvc3RlckRldmljZTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJiNTVtV0VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9hcHAvZGV2aWNlLmpzXCIsXCIvYXBwXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gY29uc3QgQmx1ZXRvb3RoRGV2aWNlID0gcmVxdWlyZSgnd2ViLWJsdWV0b290aCcpO1xuLy8gY29uc3Qgc3RhdGVNYW5hZ2VyID0gcmVxdWlyZSgnLi9hcHAvc3RhdGUuanMnKTtcbmNvbnN0IHBvc3RlckRldmljZSA9IHJlcXVpcmUoJy4vYXBwL2RldmljZS5qcycpO1xuXG4vLyBjb25zdCBzZXJ2aWNlID0gJzFlY2NlNGYyLTdmOWUtMTFlNi1hZTIyLTU2YjZiNjQ5OTYxMSc7XG5jb25zdCBjaGFyYWN0ZXJpc3RpYyA9ICc0ODhkNzk1MC03ZjllLTExZTYtYWUyMi01NmI2YjY0OTk2MTEnO1xuXG4vLyBjb25zdCBmaWx0ZXIgPSB7XG4vLyAgIG5hbWU6ICdNeURldmljZScsXG4vLyAgIHNlcnZpY2U6IFtzZXJ2aWNlXVxuLy8gfTtcbmxldCBibHVlO1xuXG5jb25zdCBjb25uZWN0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2pzLWNvbm5lY3QnKTtcbi8vIGNvbnN0IGRpc2Nvbm5lY3RCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnanMtZGlzY29ubmVjdCcpO1xuXG5jb25zdCBva0J1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdqcy1vaycpO1xuXG4vLyBjb25uZWN0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuLy8gICBjb25uZWN0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbi8vICAgc3RhdGVNYW5hZ2VyLmNoYW5nZSgnY29ubmVjdGluZycpO1xuLy9cbi8vICAgYmx1ZSA9IG5ldyBCbHVldG9vdGhEZXZpY2UoZmlsdGVyKTtcbi8vICAgYmx1ZS5jb25uZWN0KClcbi8vICAgICAudGhlbihkZXZpY2UgPT4ge1xuLy8gICAgICAgY29uc29sZS5sb2coZGV2aWNlKTtcbi8vICAgICAgIHN0YXRlTWFuYWdlci5jaGFuZ2UoJ2Nvbm5lY3RlZCcpO1xuLy8gICAgICAgY29ubmVjdEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuLy8gICAgIH0pXG4vLyAgICAgLmNhdGNoKGVycm9yID0+IHtcbi8vICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbi8vICAgICAgIHN0YXRlTWFuYWdlci5jaGFuZ2UoJ2luaXQnKTtcbi8vICAgICAgIGNvbm5lY3RCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbi8vICAgICB9KTtcbi8vIH0pO1xuLy9cbi8vIGRpc2Nvbm5lY3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4vLyAgIGlmIChibHVlLmRpc2Nvbm5lY3QoKSkge1xuLy8gICAgIHN0YXRlTWFuYWdlci5jaGFuZ2UoJ2luaXQnKTtcbi8vICAgfSBlbHNlIHtcbi8vICAgICBjb25zb2xlLmxvZygnZXJyb3Igd2hpbGUgZGlzY29ubmVjdCcpO1xuLy8gICB9XG4vLyB9KTtcblxuY29ubmVjdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgcG9zdGVyRGV2aWNlLnJlcXVlc3QoKVxuICAudGhlbigoKSA9PiBwb3N0ZXJEZXZpY2UuY29ubmVjdCgpKVxuICAudGhlbigoKSA9PiB7XG4gICAgcG9zdGVyRGV2aWNlLndyaXRlQ29sb3IoJzAwMTEyMicpO1xuICB9KVxuICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgfSk7XG59KTtcbi8vIGNvbm5lY3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4vLyAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0aW5nIEJsdWV0b290aCBEZXZpY2UuLi4nKTtcbi8vICAgbmF2aWdhdG9yLmJsdWV0b290aC5yZXF1ZXN0RGV2aWNlKHtcbi8vICAgICBmaWx0ZXJzOiBbe3NlcnZpY2VzOiBbc2VydmljZV19XVxuLy8gICB9KVxuLy8gICAudGhlbihkZXZpY2UgPT4ge1xuLy8gICAgIGNvbnNvbGUubG9nKCdDb25uZWN0aW5nIHRvIEdBVFQgU2VydmVyLi4uJyk7XG4vLyAgICAgcmV0dXJuIGRldmljZS5nYXR0LmNvbm5lY3QoKTtcbi8vICAgfSlcbi8vICAgLnRoZW4oc2VydmVyID0+IHtcbi8vICAgICBjb25zb2xlLmxvZygnR2V0dGluZyBTZXJ2aWNlLi4uJyk7XG4vLyAgICAgcmV0dXJuIHNlcnZlci5nZXRQcmltYXJ5U2VydmljZShzZXJ2aWNlKTtcbi8vICAgfSlcbi8vICAgLnRoZW4oc2VydmljZSA9PiB7XG4vLyAgICAgY29uc29sZS5sb2coJ0dldHRpbmcgQ2hhcmFjdGVyaXN0aWNzLi4uJyk7XG4vLyAgICAgLy8gaWYgKGNoYXJhY3RlcmlzdGljKSB7XG4vLyAgICAgLy8gICAvLyBHZXQgYWxsIGNoYXJhY3RlcmlzdGljcyB0aGF0IG1hdGNoIHRoaXMgVVVJRC5cbi8vICAgICAvLyAgIHJldHVybiBzZXJ2aWNlLmdldENoYXJhY3RlcmlzdGljcyhjaGFyYWN0ZXJpc3RpYyk7XG4vLyAgICAgLy8gfVxuLy8gICAgIC8vIEdldCBhbGwgY2hhcmFjdGVyaXN0aWNzLlxuLy8gICAgIHJldHVybiBzZXJ2aWNlLmdldENoYXJhY3RlcmlzdGljKGNoYXJhY3RlcmlzdGljKTtcbi8vICAgICAvLyByZXR1cm4gc2VydmljZS5nZXRDaGFyYWN0ZXJpc3RpY3MoKTtcbi8vICAgfSlcbi8vICAgLnRoZW4oY2hhcmFjdGVyaXN0aWNzID0+IHtcbi8vICAgICAvLyBjb25zb2xlLmxvZygnPiBDaGFyYWN0ZXJpc3RpY3M6ICcgK1xuLy8gICAgIC8vICAgY2hhcmFjdGVyaXN0aWNzLm1hcChjID0+IGMudXVpZCkuam9pbignXFxuJyArICcgJy5yZXBlYXQoMTkpKSk7XG4vL1xuLy8gICAgIHJldHVybiBjaGFyYWN0ZXJpc3RpY3NbMF0ucmVhZFZhbHVlKCk7XG4vLyAgIH0pXG4vLyAgIC50aGVuKHZhbHVlID0+IHtcbi8vICAgICBjb25zb2xlLmxvZygnQmF0dGVyeSBwZXJjZW50YWdlIGlzICcgKyB2YWx1ZS5nZXRVaW50OCgwKSk7XG4vLyAgIH0pXG4vLyAgIC5jYXRjaChlcnJvciA9PiB7XG4vLyAgICAgY29uc29sZS5sb2coJ0FyZ2ghICcgKyBlcnJvcik7XG4vLyAgIH0pO1xuLy8gfSk7XG5cbm9rQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICBjb25zb2xlLmxvZygncmVhZDogJyArIGNoYXJhY3RlcmlzdGljKTtcbiAgYmx1ZS5nZXRWYWx1ZShjaGFyYWN0ZXJpc3RpYylcbiAgICAudGhlbih2YWx1ZSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgfSk7XG4gIC8vIGNvbnNvbGUubG9nKCd3cml0ZTogMDI2NjgzZGEtN2Y4Yi0xMWU2LWFlMjItNTZiNmI2NDk5NjExJyk7XG4gIC8vIGJsdWUud3JpdGVWYWx1ZSgnMDI2NjgzZGEtN2Y4Yi0xMWU2LWFlMjItNTZiNmI2NDk5NjExJywgJ29rJylcbiAgLy8gICAudGhlbih3cml0ZVN1Y2Nlc3MgPT4ge1xuICAvLyAgICAgY29uc29sZS5sb2cod3JpdGVTdWNjZXNzKTtcbiAgLy8gICB9KVxuICAvLyAgIC5jYXRjaChlcnJvciA9PiB7XG4gIC8vICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gIC8vICAgfSk7XG59KTtcblxuY29uc29sZS5sb2coJzInKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJiNTVtV0VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9mYWtlX2Q1NjViMjc2LmpzXCIsXCIvXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYjU1bVdFXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MlxuXG4vKipcbiAqIElmIGBCdWZmZXIuX3VzZVR5cGVkQXJyYXlzYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKGNvbXBhdGlibGUgZG93biB0byBJRTYpXG4gKi9cbkJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgaWYgYnJvd3NlciBzdXBwb3J0cyBUeXBlZCBBcnJheXMuIFN1cHBvcnRlZCBicm93c2VycyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLFxuICAvLyBDaHJvbWUgNyssIFNhZmFyaSA1LjErLCBPcGVyYSAxMS42KywgaU9TIDQuMisuIElmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYWRkaW5nXG4gIC8vIHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcywgdGhlbiB0aGF0J3MgdGhlIHNhbWUgYXMgbm8gYFVpbnQ4QXJyYXlgIHN1cHBvcnRcbiAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gYWRkIGFsbCB0aGUgbm9kZSBCdWZmZXIgQVBJIG1ldGhvZHMuIFRoaXMgaXMgYW4gaXNzdWVcbiAgLy8gaW4gRmlyZWZveCA0LTI5LiBOb3cgZml4ZWQ6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOFxuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiZcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAvLyBDaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gV29ya2Fyb3VuZDogbm9kZSdzIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgc3RyaW5nc1xuICAvLyB3aGlsZSBiYXNlNjQtanMgZG9lcyBub3QuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcgJiYgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzdWJqZWN0ID0gc3RyaW5ndHJpbShzdWJqZWN0KVxuICAgIHdoaWxlIChzdWJqZWN0Lmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0ICsgJz0nXG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0KVxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QubGVuZ3RoKSAvLyBhc3N1bWUgdGhhdCBvYmplY3QgaXMgYXJyYXktbGlrZVxuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgYXJyYXkgb3Igc3RyaW5nLicpXG5cbiAgdmFyIGJ1ZlxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgICBlbHNlXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3RbaV1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgIW5vWmVybykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuLy8gU1RBVElDIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPT0gbnVsbCAmJiBiICE9PSB1bmRlZmluZWQgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoIC8gMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGFzc2VydChpc0FycmF5KGxpc3QpLCAnVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdCwgW3RvdGFsTGVuZ3RoXSlcXG4nICtcbiAgICAgICdsaXN0IHNob3VsZCBiZSBhbiBBcnJheS4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBCVUZGRVIgSU5TVEFOQ0UgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gX2hleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgYXNzZXJ0KHN0ckxlbiAlIDIgPT09IDAsICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBhc3NlcnQoIWlzTmFOKGJ5dGUpLCAnSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMlxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBfdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2FzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2JpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIF9hc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gX2hleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IF91dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gX2FzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IF9iaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gX2Jhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBfdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcbiAgc3RhcnQgPSBOdW1iZXIoc3RhcnQpIHx8IDBcbiAgZW5kID0gKGVuZCAhPT0gdW5kZWZpbmVkKVxuICAgID8gTnVtYmVyKGVuZClcbiAgICA6IGVuZCA9IHNlbGYubGVuZ3RoXG5cbiAgLy8gRmFzdHBhdGggZW1wdHkgc3RyaW5nc1xuICBpZiAoZW5kID09PSBzdGFydClcbiAgICByZXR1cm4gJydcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gX2hleFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IF91dGY4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gX2FzY2lpU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IF9iaW5hcnlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gX2Jhc2U2NFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBfdXRmMTZsZVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGFzc2VydCh0YXJnZXRfc3RhcnQgPj0gMCAmJiB0YXJnZXRfc3RhcnQgPCB0YXJnZXQubGVuZ3RoLFxuICAgICAgJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSBzb3VyY2UubGVuZ3RoLCAnc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAgfHwgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIF9hc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gX2JpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIF9hc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gX2hleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gX3V0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSsxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSBjbGFtcChzdGFydCwgbGVuLCAwKVxuICBlbmQgPSBjbGFtcChlbmQsIGxlbiwgbGVuKVxuXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgdmFyIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmXG4gIH1cbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDJdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgICB2YWwgfD0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApXG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMV0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMl0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAzXVxuICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0XSA8PCAyNCA+Pj4gMClcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICB2YXIgbmVnID0gdGhpc1tvZmZzZXRdICYgMHg4MFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQxNihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MzIoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRmxvYXQgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWREb3VibGUgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAgICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB0aGlzLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB0aGlzLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQxNihidWYsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQzMihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MzIoYnVmLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApXG4gIH1cblxuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpLCAndmFsdWUgaXMgbm90IGEgbnVtYmVyJylcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5sZW5ndGgsICdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSB0aGlzLmxlbmd0aCwgJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHRoaXNbaV0gPSB2YWx1ZVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCA9IFtdXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpc1tpXSlcbiAgICBpZiAoaSA9PT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPidcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpXG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbmZ1bmN0aW9uIGNsYW1wIChpbmRleCwgbGVuLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHJldHVybiBkZWZhdWx0VmFsdWVcbiAgaW5kZXggPSB+fmluZGV4OyAgLy8gQ29lcmNlIHRvIGludGVnZXIuXG4gIGlmIChpbmRleCA+PSBsZW4pIHJldHVybiBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICBpbmRleCArPSBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBjb2VyY2UgKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpXG4gIHJldHVybiBsZW5ndGggPCAwID8gMCA6IGxlbmd0aFxufVxuXG5mdW5jdGlvbiBpc0FycmF5IChzdWJqZWN0KSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoc3ViamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgfSkoc3ViamVjdClcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50ICh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA+PSAwLCAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmc2ludCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodGVzdCwgbWVzc2FnZSkge1xuICBpZiAoIXRlc3QpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdGYWlsZWQgYXNzZXJ0aW9uJylcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJiNTVtV0VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJiNTVtV0VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYjU1bVdFXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvaWVlZTc1NFwiKSJdfQ==\n","/*!\n *\n *  Web Starter Kit\n *  Copyright 2015 Google Inc. All rights reserved.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *    https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License\n *\n */\n/* eslint-env browser */\n(function() {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  var isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n      // [::1] is the IPv6 localhost address.\n      window.location.hostname === '[::1]' ||\n      // 127.0.0.1/8 is considered localhost for IPv4.\n      window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n      )\n    );\n\n  if ('serviceWorker' in navigator &&\n      (window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js')\n    .then(function(registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function() {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {\n          // The updatefound event implies that registration.installing is set:\n          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n          var installingWorker = registration.installing;\n\n          installingWorker.onstatechange = function() {\n            switch (installingWorker.state) {\n              case 'installed':\n                // At this point, the old content will have been purged and the\n                // fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in the page's interface.\n                break;\n\n              case 'redundant':\n                throw new Error('The installing ' +\n                                'service worker became redundant.');\n\n              default:\n                // Ignore\n            }\n          };\n        }\n      };\n    }).catch(function(e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nclass PosterDevice {\n\n  constructor() {\n    this.device = null;\n    this.onDisconnected = this.onDisconnected.bind(this);\n  }\n\n  request() {\n    console.log('request');\n    let options = {\n      filters: [{\n        name: 'MyDevice'\n      }]\n    };\n    return navigator.bluetooth.requestDevice(options)\n    .then(device => {\n      this.device = device;\n      this.device.addEventListener('gattserverdisconnected', this.onDisconnected);\n      return device;\n    });\n  }\n\n  connect() {\n    console.log('connect');\n    if (this.device) {\n      return this.device.gatt.connect();\n    }\n    return Promise.reject('Device is not connected.');\n  }\n\n  writeColor(data) {\n    console.log('writeColor');\n    return this.device.gatt.getPrimaryService(0xFF02)\n    .then(service => service.getCharacteristic(0xFFFC))\n    .then(characteristic => characteristic.writeValue(data));\n  }\n\n  disconnect() {\n    console.log('disconnect');\n    if (this.device) {\n      return this.device.gatt.disconnect();\n    }\n    return Promise.reject('Device is not connected.');\n  }\n\n  onDisconnected() {\n    console.log('onDisconnected');\n    console.log('Device is disconnected.');\n  }\n}\n\nconst posterDevice = new PosterDevice();\nmodule.exports = posterDevice;\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/app/device.js\",\"/app\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n// const BluetoothDevice = require('web-bluetooth');\n// const stateManager = require('./app/state.js');\nconst posterDevice = require('./app/device.js');\n\n// const service = '1ecce4f2-7f9e-11e6-ae22-56b6b6499611';\nconst characteristic = '488d7950-7f9e-11e6-ae22-56b6b6499611';\n\n// const filter = {\n//   name: 'MyDevice',\n//   service: [service]\n// };\nlet blue;\n\nconst connectButton = document.getElementById('js-connect');\n// const disconnectButton = document.getElementById('js-disconnect');\n\nconst okButton = document.getElementById('js-ok');\n\n// connectButton.addEventListener('click', () => {\n//   connectButton.disabled = true;\n//   stateManager.change('connecting');\n//\n//   blue = new BluetoothDevice(filter);\n//   blue.connect()\n//     .then(device => {\n//       console.log(device);\n//       stateManager.change('connected');\n//       connectButton.disabled = false;\n//     })\n//     .catch(error => {\n//       console.log(error);\n//       stateManager.change('init');\n//       connectButton.disabled = false;\n//     });\n// });\n//\n// disconnectButton.addEventListener('click', () => {\n//   if (blue.disconnect()) {\n//     stateManager.change('init');\n//   } else {\n//     console.log('error while disconnect');\n//   }\n// });\n\nconnectButton.addEventListener('click', () => {\n  posterDevice.request()\n  .then(() => posterDevice.connect())\n  .then(() => {\n    posterDevice.writeColor('001122');\n  })\n  .catch(error => {\n    console.log(error);\n  });\n});\n// connectButton.addEventListener('click', () => {\n//   console.log('Requesting Bluetooth Device...');\n//   navigator.bluetooth.requestDevice({\n//     filters: [{services: [service]}]\n//   })\n//   .then(device => {\n//     console.log('Connecting to GATT Server...');\n//     return device.gatt.connect();\n//   })\n//   .then(server => {\n//     console.log('Getting Service...');\n//     return server.getPrimaryService(service);\n//   })\n//   .then(service => {\n//     console.log('Getting Characteristics...');\n//     // if (characteristic) {\n//     //   // Get all characteristics that match this UUID.\n//     //   return service.getCharacteristics(characteristic);\n//     // }\n//     // Get all characteristics.\n//     return service.getCharacteristic(characteristic);\n//     // return service.getCharacteristics();\n//   })\n//   .then(characteristics => {\n//     // console.log('> Characteristics: ' +\n//     //   characteristics.map(c => c.uuid).join('\\n' + ' '.repeat(19)));\n//\n//     return characteristics[0].readValue();\n//   })\n//   .then(value => {\n//     console.log('Battery percentage is ' + value.getUint8(0));\n//   })\n//   .catch(error => {\n//     console.log('Argh! ' + error);\n//   });\n// });\n\nokButton.addEventListener('click', () => {\n  console.log('read: ' + characteristic);\n  blue.getValue(characteristic)\n    .then(value => {\n      console.log(value);\n    });\n  // console.log('write: 026683da-7f8b-11e6-ae22-56b6b6499611');\n  // blue.writeValue('026683da-7f8b-11e6-ae22-56b6b6499611', 'ok')\n  //   .then(writeSuccess => {\n  //     console.log(writeSuccess);\n  //   })\n  //   .catch(error => {\n  //     console.log(error);\n  //   });\n});\n\nconsole.log('2');\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/fake_d565b276.js\",\"/\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js\",\"/../../node_modules/gulp-browserify/node_modules/base64-js/lib\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = Buffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192\n\n/**\n * If `Buffer._useTypedArrays`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (compatible down to IE6)\n */\nBuffer._useTypedArrays = (function () {\n  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,\n  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding\n  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support\n  // because we need to be able to add all the node Buffer API methods. This is an issue\n  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438\n  try {\n    var buf = new ArrayBuffer(0)\n    var arr = new Uint8Array(buf)\n    arr.foo = function () { return 42 }\n    return 42 === arr.foo() &&\n        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`\n  } catch (e) {\n    return false\n  }\n})()\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (subject, encoding, noZero) {\n  if (!(this instanceof Buffer))\n    return new Buffer(subject, encoding, noZero)\n\n  var type = typeof subject\n\n  // Workaround: node's base64 implementation allows for non-padded strings\n  // while base64-js does not.\n  if (encoding === 'base64' && type === 'string') {\n    subject = stringtrim(subject)\n    while (subject.length % 4 !== 0) {\n      subject = subject + '='\n    }\n  }\n\n  // Find the length\n  var length\n  if (type === 'number')\n    length = coerce(subject)\n  else if (type === 'string')\n    length = Buffer.byteLength(subject, encoding)\n  else if (type === 'object')\n    length = coerce(subject.length) // assume that object is array-like\n  else\n    throw new Error('First argument needs to be a number, array or string.')\n\n  var buf\n  if (Buffer._useTypedArrays) {\n    // Preferred: Return an augmented `Uint8Array` instance for best performance\n    buf = Buffer._augment(new Uint8Array(length))\n  } else {\n    // Fallback: Return THIS instance of Buffer (created by `new`)\n    buf = this\n    buf.length = length\n    buf._isBuffer = true\n  }\n\n  var i\n  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {\n    // Speed optimization -- use set if we're copying from a typed array\n    buf._set(subject)\n  } else if (isArrayish(subject)) {\n    // Treat array-ish objects as a byte array\n    for (i = 0; i < length; i++) {\n      if (Buffer.isBuffer(subject))\n        buf[i] = subject.readUInt8(i)\n      else\n        buf[i] = subject[i]\n    }\n  } else if (type === 'string') {\n    buf.write(subject, 0, encoding)\n  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {\n    for (i = 0; i < length; i++) {\n      buf[i] = 0\n    }\n  }\n\n  return buf\n}\n\n// STATIC METHODS\n// ==============\n\nBuffer.isEncoding = function (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.isBuffer = function (b) {\n  return !!(b !== null && b !== undefined && b._isBuffer)\n}\n\nBuffer.byteLength = function (str, encoding) {\n  var ret\n  str = str + ''\n  switch (encoding || 'utf8') {\n    case 'hex':\n      ret = str.length / 2\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8ToBytes(str).length\n      break\n    case 'ascii':\n    case 'binary':\n    case 'raw':\n      ret = str.length\n      break\n    case 'base64':\n      ret = base64ToBytes(str).length\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = str.length * 2\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.concat = function (list, totalLength) {\n  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\\n' +\n      'list should be an Array.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  } else if (list.length === 1) {\n    return list[0]\n  }\n\n  var i\n  if (typeof totalLength !== 'number') {\n    totalLength = 0\n    for (i = 0; i < list.length; i++) {\n      totalLength += list[i].length\n    }\n  }\n\n  var buf = new Buffer(totalLength)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\n// BUFFER INSTANCE METHODS\n// =======================\n\nfunction _hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  assert(strLen % 2 === 0, 'Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16)\n    assert(!isNaN(byte), 'Invalid hex string')\n    buf[offset + i] = byte\n  }\n  Buffer._charsWritten = i * 2\n  return i\n}\n\nfunction _utf8Write (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(utf8ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _asciiWrite (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(asciiToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _binaryWrite (buf, string, offset, length) {\n  return _asciiWrite(buf, string, offset, length)\n}\n\nfunction _base64Write (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(base64ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _utf16leWrite (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(utf16leToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nBuffer.prototype.write = function (string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length\n      length = undefined\n    }\n  } else {  // legacy\n    var swap = encoding\n    encoding = offset\n    offset = length\n    length = swap\n  }\n\n  offset = Number(offset) || 0\n  var remaining = this.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase()\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = _hexWrite(this, string, offset, length)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = _utf8Write(this, string, offset, length)\n      break\n    case 'ascii':\n      ret = _asciiWrite(this, string, offset, length)\n      break\n    case 'binary':\n      ret = _binaryWrite(this, string, offset, length)\n      break\n    case 'base64':\n      ret = _base64Write(this, string, offset, length)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = _utf16leWrite(this, string, offset, length)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toString = function (encoding, start, end) {\n  var self = this\n\n  encoding = String(encoding || 'utf8').toLowerCase()\n  start = Number(start) || 0\n  end = (end !== undefined)\n    ? Number(end)\n    : end = self.length\n\n  // Fastpath empty strings\n  if (end === start)\n    return ''\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = _hexSlice(self, start, end)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = _utf8Slice(self, start, end)\n      break\n    case 'ascii':\n      ret = _asciiSlice(self, start, end)\n      break\n    case 'binary':\n      ret = _binarySlice(self, start, end)\n      break\n    case 'base64':\n      ret = _base64Slice(self, start, end)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = _utf16leSlice(self, start, end)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toJSON = function () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function (target, target_start, start, end) {\n  var source = this\n\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (!target_start) target_start = 0\n\n  // Copy 0 bytes; we're done\n  if (end === start) return\n  if (target.length === 0 || source.length === 0) return\n\n  // Fatal error conditions\n  assert(end >= start, 'sourceEnd < sourceStart')\n  assert(target_start >= 0 && target_start < target.length,\n      'targetStart out of bounds')\n  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')\n  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length)\n    end = this.length\n  if (target.length - target_start < end - start)\n    end = target.length - target_start + start\n\n  var len = end - start\n\n  if (len < 100 || !Buffer._useTypedArrays) {\n    for (var i = 0; i < len; i++)\n      target[i + target_start] = this[i + start]\n  } else {\n    target._set(this.subarray(start, start + len), target_start)\n  }\n}\n\nfunction _base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction _utf8Slice (buf, start, end) {\n  var res = ''\n  var tmp = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    if (buf[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])\n      tmp = ''\n    } else {\n      tmp += '%' + buf[i].toString(16)\n    }\n  }\n\n  return res + decodeUtf8Char(tmp)\n}\n\nfunction _asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++)\n    ret += String.fromCharCode(buf[i])\n  return ret\n}\n\nfunction _binarySlice (buf, start, end) {\n  return _asciiSlice(buf, start, end)\n}\n\nfunction _hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction _utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function (start, end) {\n  var len = this.length\n  start = clamp(start, len, 0)\n  end = clamp(end, len, len)\n\n  if (Buffer._useTypedArrays) {\n    return Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    var newBuf = new Buffer(sliceLen, undefined, true)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n    return newBuf\n  }\n}\n\n// `get` will be removed in Node 0.13+\nBuffer.prototype.get = function (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` will be removed in Node 0.13+\nBuffer.prototype.set = function (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nBuffer.prototype.readUInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  return this[offset]\n}\n\nfunction _readUInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    val = buf[offset]\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n  } else {\n    val = buf[offset] << 8\n    if (offset + 1 < len)\n      val |= buf[offset + 1]\n  }\n  return val\n}\n\nBuffer.prototype.readUInt16LE = function (offset, noAssert) {\n  return _readUInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt16BE = function (offset, noAssert) {\n  return _readUInt16(this, offset, false, noAssert)\n}\n\nfunction _readUInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    if (offset + 2 < len)\n      val = buf[offset + 2] << 16\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n    val |= buf[offset]\n    if (offset + 3 < len)\n      val = val + (buf[offset + 3] << 24 >>> 0)\n  } else {\n    if (offset + 1 < len)\n      val = buf[offset + 1] << 16\n    if (offset + 2 < len)\n      val |= buf[offset + 2] << 8\n    if (offset + 3 < len)\n      val |= buf[offset + 3]\n    val = val + (buf[offset] << 24 >>> 0)\n  }\n  return val\n}\n\nBuffer.prototype.readUInt32LE = function (offset, noAssert) {\n  return _readUInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt32BE = function (offset, noAssert) {\n  return _readUInt32(this, offset, false, noAssert)\n}\n\nBuffer.prototype.readInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null,\n        'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  var neg = this[offset] & 0x80\n  if (neg)\n    return (0xff - this[offset] + 1) * -1\n  else\n    return this[offset]\n}\n\nfunction _readInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = _readUInt16(buf, offset, littleEndian, true)\n  var neg = val & 0x8000\n  if (neg)\n    return (0xffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt16LE = function (offset, noAssert) {\n  return _readInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt16BE = function (offset, noAssert) {\n  return _readInt16(this, offset, false, noAssert)\n}\n\nfunction _readInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = _readUInt32(buf, offset, littleEndian, true)\n  var neg = val & 0x80000000\n  if (neg)\n    return (0xffffffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt32LE = function (offset, noAssert) {\n  return _readInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt32BE = function (offset, noAssert) {\n  return _readInt32(this, offset, false, noAssert)\n}\n\nfunction _readFloat (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 23, 4)\n}\n\nBuffer.prototype.readFloatLE = function (offset, noAssert) {\n  return _readFloat(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readFloatBE = function (offset, noAssert) {\n  return _readFloat(this, offset, false, noAssert)\n}\n\nfunction _readDouble (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 52, 8)\n}\n\nBuffer.prototype.readDoubleLE = function (offset, noAssert) {\n  return _readDouble(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readDoubleBE = function (offset, noAssert) {\n  return _readDouble(this, offset, false, noAssert)\n}\n\nBuffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xff)\n  }\n\n  if (offset >= this.length) return\n\n  this[offset] = value\n}\n\nfunction _writeUInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {\n    buf[offset + i] =\n        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n            (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n  _writeUInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n  _writeUInt16(this, value, offset, false, noAssert)\n}\n\nfunction _writeUInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffffffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {\n    buf[offset + i] =\n        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n  _writeUInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n  _writeUInt32(this, value, offset, false, noAssert)\n}\n\nBuffer.prototype.writeInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7f, -0x80)\n  }\n\n  if (offset >= this.length)\n    return\n\n  if (value >= 0)\n    this.writeUInt8(value, offset, noAssert)\n  else\n    this.writeUInt8(0xff + value + 1, offset, noAssert)\n}\n\nfunction _writeInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fff, -0x8000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    _writeUInt16(buf, value, offset, littleEndian, noAssert)\n  else\n    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)\n}\n\nBuffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n  _writeInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n  _writeInt16(this, value, offset, false, noAssert)\n}\n\nfunction _writeInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fffffff, -0x80000000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    _writeUInt32(buf, value, offset, littleEndian, noAssert)\n  else\n    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)\n}\n\nBuffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n  _writeInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n  _writeInt32(this, value, offset, false, noAssert)\n}\n\nfunction _writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n}\n\nBuffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n  _writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n  _writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction _writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 7 < buf.length,\n        'Trying to write beyond buffer length')\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n}\n\nBuffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n  _writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n  _writeDouble(this, value, offset, false, noAssert)\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (typeof value === 'string') {\n    value = value.charCodeAt(0)\n  }\n\n  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')\n  assert(end >= start, 'end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  assert(start >= 0 && start < this.length, 'start out of bounds')\n  assert(end >= 0 && end <= this.length, 'end out of bounds')\n\n  for (var i = start; i < end; i++) {\n    this[i] = value\n  }\n}\n\nBuffer.prototype.inspect = function () {\n  var out = []\n  var len = this.length\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i])\n    if (i === exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...'\n      break\n    }\n  }\n  return '<Buffer ' + out.join(' ') + '>'\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer._useTypedArrays) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1)\n        buf[i] = this[i]\n      return buf.buffer\n    }\n  } else {\n    throw new Error('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function (arr) {\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array get/set methods before overwriting\n  arr._get = arr.get\n  arr._set = arr.set\n\n  // deprecated, will be removed in node 0.13+\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\n// slice(start, end)\nfunction clamp (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index;  // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\n\nfunction coerce (length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it's fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length)\n  return length < 0 ? 0 : length\n}\n\nfunction isArray (subject) {\n  return (Array.isArray || function (subject) {\n    return Object.prototype.toString.call(subject) === '[object Array]'\n  })(subject)\n}\n\nfunction isArrayish (subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n      subject && typeof subject === 'object' &&\n      typeof subject.length === 'number'\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    var b = str.charCodeAt(i)\n    if (b <= 0x7F)\n      byteArray.push(str.charCodeAt(i))\n    else {\n      var start = i\n      if (b >= 0xD800 && b <= 0xDFFF) i++\n      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16))\n    }\n  }\n  return byteArray\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(str)\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  var pos\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length))\n      break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction decodeUtf8Char (str) {\n  try {\n    return decodeURIComponent(str)\n  } catch (err) {\n    return String.fromCharCode(0xFFFD) // UTF 8 invalid char\n  }\n}\n\n/*\n * We have to make sure that the value is a valid integer. This means that it\n * is non-negative. It has no fractional component and that it does not\n * exceed the maximum allowed value.\n */\nfunction verifuint (value, max) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value >= 0, 'specified a negative value for writing an unsigned value')\n  assert(value <= max, 'value is larger than maximum value for type')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifsint (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifIEEE754 (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n}\n\nfunction assert (test, message) {\n  if (!test) throw new Error(message || 'Failed assertion')\n}\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/gulp-browserify/node_modules/buffer/index.js\",\"/../../node_modules/gulp-browserify/node_modules/buffer\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/gulp-browserify/node_modules/process/browser.js\",\"/../../node_modules/gulp-browserify/node_modules/process\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/ieee754/index.js\",\"/../../node_modules/ieee754\")","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})"],"sourceRoot":"/source/"}
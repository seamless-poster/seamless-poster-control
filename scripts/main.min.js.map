{"version":3,"sources":["main.min.js","/source/main.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/app/scripts/app/device.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/app/scripts/fake_85f83a39.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/buffer/index.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/process/browser.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/ieee754/index.js","/Users/j.vallelunga/Workspaces/tesis/seamless-poster-control/node_modules/gulp-browserify/node_modules/browser-pack/_prelude.js"],"names":["_classCallCheck","instance","Constructor","TypeError","isLocalhost","Boolean","window","location","hostname","match","navigator","protocol","serviceWorker","register","then","registration","onupdatefound","controller","installingWorker","installing","onstatechange","state","Error","e","console","error","_typeof","Symbol","iterator","obj","constructor","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","t","n","r","s","o","u","a","require","f","exports","call","1","module","process","global","Buffer","__argument0","__argument1","__argument2","__argument3","__filename","__dirname","PosterDevice","this","device","onDisconnected","bind","value","_this","options","filters","name","optionalServices","bluetooth","requestDevice","addEventListener","gatt","connect","Promise","reject","data","getPrimaryService","service","getCharacteristic","characteristic","writeValue","disconnect","log","posterDevice","self","arguments","b55mWE","buffer","2","blue","connectButton","document","getElementById","okButton","request","writeColor","getValue","./app/device.js","3","lookup","decode","elt","code","charCodeAt","PLUS","PLUS_URL_SAFE","SLASH","SLASH_URL_SAFE","NUMBER","UPPER","LOWER","b64ToByteArray","b64","push","v","arr","L","j","l","tmp","placeHolders","len","charAt","Arr","uint8ToBase64","uint8","encode","num","tripletToBase64","temp","extraBytes","output","Uint8Array","Array","toByteArray","fromByteArray","base64js","4","subject","encoding","noZero","type","stringtrim","coerce","byteLength","buf","_useTypedArrays","_augment","_isBuffer","_set","isArrayish","isBuffer","readUInt8","write","_hexWrite","string","offset","Number","remaining","strLen","assert","byte","parseInt","substr","isNaN","_charsWritten","_utf8Write","charsWritten","blitBuffer","utf8ToBytes","_asciiWrite","asciiToBytes","_binaryWrite","_base64Write","base64ToBytes","_utf16leWrite","utf16leToBytes","_base64Slice","start","end","base64","slice","_utf8Slice","res","Math","min","decodeUtf8Char","String","fromCharCode","toString","_asciiSlice","ret","_binarySlice","_hexSlice","out","toHex","_utf16leSlice","bytes","_readUInt16","littleEndian","noAssert","undefined","val","_readUInt32","_readInt16","neg","_readInt32","_readFloat","ieee754","read","_readDouble","_writeUInt16","verifuint","_writeUInt32","_writeInt16","verifsint","_writeInt32","_writeFloat","verifIEEE754","_writeDouble","str","trim","replace","clamp","index","defaultValue","ceil","isArray","byteArray","b","h","encodeURIComponent","split","c","hi","lo","src","dst","decodeURIComponent","err","max","floor","test","message","SlowBuffer","INSPECT_MAX_BYTES","poolSize","ArrayBuffer","foo","subarray","isEncoding","toLowerCase","concat","list","totalLength","pos","item","copy","isFinite","swap","toJSON","_arr","target_start","source","sliceLen","newBuf","get","set","writeUInt8","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","fill","inspect","join","toArrayBuffer","BP","_get","toLocaleString","base64-js","5","noop","nextTick","canSetImmediate","setImmediate","canPost","postMessage","queue","ev","stopPropagation","fn","shift","setTimeout","title","browser","env","argv","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","6","isLE","mLen","nBytes","m","eLen","eMax","eBias","nBits","d","NaN","Infinity","pow","rt","abs","LN2"],"mappings":"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Q,IACE,GAAID,GAAM,GAAIsG,aKjXxB,GLkXcpI,EAAM,GAAIiB,YKjXxBa,ELmXU,OADA9B,GAAIqI,IAAM,WAAa,MAAO,KACvB,KAAOrI,EKjXxBqI,OLkXkC,kBAAjBrI,GAAIsI,SACX,MAAO9O,GACP,OKjXV,MA8EAuC,EAAAwM,WAAA,SAAA/G,GLmXQ,OAAQgD,OAAOhD,GKjXvBgH,eLkXU,IKjXV,MLkXU,IKjXV,OLkXU,IKjXV,QLkXU,IKjXV,QLkXU,IKjXV,SLkXU,IKjXV,SLkXU,IKjXV,MLkXU,IKjXV,OLkXU,IKjXV,QLkXU,IKjXV,ULkXU,IKjXV,WLkXY,OKjXZ,CACA,SLkXY,OKjXZ,IAGAzM,EAAAqG,SAAA,SAAA8E,GLmXQ,QAAgB,OAANA,GAAoB5B,SAAN4B,IAAmBA,EKjXnDjF,YAEAlG,EAAA8F,WAAA,SAAA4E,EAAAjF,GLmXQ,GKjXRoD,ELmXQ,QADA6B,GKjXR,GLkXgBjF,GKjXhB,QLkXU,IKjXV,MLkXYoD,EAAM6B,EAAIpM,OKjXtB,CACA,MLkXU,KKjXV,OLkXU,IKjXV,QLkXYuK,EAAMtB,EAAYmD,GKjX9BpM,MACA,MLkXU,KKjXV,QLkXU,IKjXV,SLkXU,IKjXV,MLkXYuK,EAAM6B,EKjXlBpM,MACA,MLkXU,KKjXV,SLkXYuK,EAAMjB,EAAc8C,GKjXhCpM,MACA,MLkXU,KKjXV,OLkXU,IKjXV,QLkXU,IKjXV,ULkXU,IKjXV,WLkXYuK,EKjXZ,ELiXkB6B,EAAIpM,MKhXtB,MACA,SLkXY,KAAM,IAAId,OKjXtB,oBLmXQ,MKjXRqL,IAEA7I,EAAA0M,OAAA,SAAAC,EAAAC,GLsXQ,GAHA9F,EAAOmE,EAAQ0B,GKjXvB,uELoX4B,IAAhBA,EAAKrO,OACP,MAAO,IAAI0B,GKjXrB,ELkXe,IAAoB,IAAhB2M,EAAKrO,OACd,MAAOqO,GKjXjB,ELoXQ,IKjXRtO,ELkXQ,IAA2B,gBAAhBuO,GAET,IADAA,EKjXV,ELkXevO,EAAI,EAAGA,EAAIsO,EAAKrO,OAAQD,IAC3BuO,GAAeD,EAAKtO,GKjXhCC,MLqXQ,IAAIyH,GAAM,GAAI/F,GKjXtB4M,GLkXYC,EKjXZ,CLkXQ,KAAKxO,EAAI,EAAGA,EAAIsO,EAAKrO,OAAQD,IKjXrC,CLkXU,GAAIyO,GAAOH,EKjXrBtO,ELkXUyO,GAAKC,KAAKhH,EKjXpB8G,GLkXUA,GAAOC,EKjXjBxO,OLmXQ,MKjXRyH,IA6DA/F,EAAAhB,UAAAuH,MAAA,SAAAE,EAAAC,EAAApI,EAAAmH,GLqXQ,GAAIuH,SAAStG,GACNsG,SAAS1O,KACZmH,EKjXZnH,ELkXYA,EKjXZiL,YLmXe,CACL,GAAI0D,GKjXdxH,CLkXUA,GKjXViB,ELkXUA,EKjXVpI,ELkXUA,EKjXV2O,ELoXQvG,EAASC,OAAOD,IKjXxB,CLkXQ,IAAIE,GAAYpG,KAAKlC,OKjX7BoI,CLkXapI,IAGHA,EAASqI,OKjXnBrI,GLkXcA,EAASsI,IACXtI,EKjXZsI,IL6WUtI,EKjXVsI,ELwXQnB,EAAWgD,OAAOhD,GAAY,QKjXtCgH,aLmXQ,IKjXR5D,ELkXQ,QKjXRpD,GLkXU,IKjXV,MLkXYoD,EAAMrC,EAAUhG,KAAMiG,EAAQC,EKjX1CpI,EACA,MLkXU,KKjXV,OLkXU,IKjXV,QLkXYuK,EAAMzB,EAAW5G,KAAMiG,EAAQC,EKjX3CpI,EACA,MLkXU,KKjXV,QLkXYuK,EAAMrB,EAAYhH,KAAMiG,EAAQC,EKjX5CpI,EACA,MLkXU,KKjXV,SLkXYuK,EAAMnB,EAAalH,KAAMiG,EAAQC,EKjX7CpI,EACA,MLkXU,KKjXV,SLkXYuK,EAAMlB,EAAanH,KAAMiG,EAAQC,EKjX7CpI,EACA,MLkXU,KKjXV,OLkXU,IKjXV,QLkXU,IKjXV,ULkXU,IKjXV,WLkXYuK,EAAMhB,EAAcrH,KAAMiG,EAAQC,EKjX9CpI,EACA,MACA,SLkXY,KAAM,IAAId,OKjXtB,oBLmXQ,MKjXRqL,IAEA7I,EAAAhB,UAAA2J,SAAA,SAAAlD,EAAAuC,EAAAC,GLmXQ,GAAI/F,GKjXZ1B,IL0XQ,IAPAiF,EAAWgD,OAAOhD,GAAY,QKjXtCgH,cLkXQzE,EAAQrB,OAAOqB,IKjXvB,ELkXQC,EKjXRsB,SLiXctB,EACNtB,OKjXRsB,GLkXQA,EAAM/F,EKjXd5D,OLoXY2J,IKjXZD,ELkXQ,MKjXR,ELmXQ,IKjXRa,ELkXQ,QKjXRpD,GLkXU,IKjXV,MLkXYoD,EAAME,EAAU7G,EAAM8F,EKjXlCC,EACA,MLkXU,KKjXV,OLkXU,IKjXV,QLkXYY,EAAMT,EAAWlG,EAAM8F,EKjXnCC,EACA,MLkXU,KKjXV,QLkXYY,EAAMD,EAAY1G,EAAM8F,EKjXpCC,EACA,MLkXU,KKjXV,SLkXYY,EAAMC,EAAa5G,EAAM8F,EKjXrCC,EACA,MLkXU,KKjXV,SLkXYY,EAAMd,EAAa7F,EAAM8F,EKjXrCC,EACA,MLkXU,KKjXV,OLkXU,IKjXV,QLkXU,IKjXV,ULkXU,IKjXV,WLkXYY,EAAMK,EAAchH,EAAM8F,EKjXtCC,EACA,MACA,SLkXY,KAAM,IAAIzK,OKjXtB,oBLmXQ,MKjXRqL,IAEA7I,EAAAhB,UAAAkO,OAAA,WLmXQ,OACEvH,KKjXV,SLkXUlE,KAAM0D,MAAMnG,UAAUmJ,MAAMxI,KAAKa,KAAK2M,MAAQ3M,KKjXxD,KAIAR,EAAAhB,UAAA+N,KAAA,SAAA5O,EAAAiP,EAAApF,EAAAC,GLmXQ,GAAIoF,GKjXZ7M,ILwXQ,IALKwH,IAAOA,EKjXpB,GLkXaC,GAAe,IAARA,IAAWA,EAAMzH,KKjXrClC,QLkXa8O,IAAcA,EKjX3B,GLoXYnF,IAAQD,GACU,IAAlB7J,EAAOG,QAAkC,IAAlB+O,EAAO/O,OAAlC,CAGAwI,EAAOmB,GAAOD,EKjXtB,2BLkXQlB,EAAOsG,GAAgB,GAAKA,EAAejP,EKjXnDG,OACA,6BLkXQwI,EAAOkB,GAAS,GAAKA,EAAQqF,EAAO/O,OKjX5C,6BLkXQwI,EAAOmB,GAAO,GAAKA,GAAOoF,EAAO/O,OKjXzC,2BLoXY2J,EAAMzH,KKjXlBlC,SLkXQ2J,EAAMzH,KKjXdlC,QLkXYH,EAAOG,OAAS8O,EAAenF,EKjX3CD,ILkXQC,EAAM9J,EAAOG,OAAS8O,EKjX9BpF,ELmXQ,IAAIzD,GAAM0D,EKjXlBD,CLmXQ,IAAIzD,EAAM,MAAQvE,EAAOgG,gBACvB,IAAK,GAAI3H,GAAI,EAAGA,EAAIkG,EKjX9BlG,ILkXYF,EAAOE,EAAI+O,GAAgB5M,KAAKnC,EKjX5C2J,OLmXU7J,GAAOgI,KAAK3F,KAAK+L,SAASvE,EAAOA,EAAQzD,GKjXnD6I,KA+DApN,EAAAhB,UAAAmJ,MAAA,SAAAH,EAAAC,GLmXQ,GAAI1D,GAAM/D,KKjXlBlC,MLqXQ,IAHA0J,EAAQ6C,EAAM7C,EAAOzD,EKjX7B,GLkXQ0D,EAAM4C,EAAM5C,EAAK1D,EKjXzBA,GLmXYvE,EAAOgG,gBACT,MAAOhG,GAAOiG,SAASzF,KAAK+L,SAASvE,EKjX/CC,GLqXU,KAAK,GAFDqF,GAAWrF,EKjXzBD,ELkXcuF,EAAS,GAAIvN,GAAOsN,GAAU/D,UKjX5C,ILkXmBlL,EAAI,EAAGA,EAAIiP,EAAUjP,IAC5BkP,EAAOlP,GAAKmC,KAAKnC,EKjX7B2J,ELmXU,OKjXVuF,IAIAvN,EAAAhB,UAAAwO,IAAA,SAAA9G,GLoXQ,MADAhJ,SAAQsE,IKjXhB,6DLkXexB,KAAK8F,UKjXpBI,IAGA1G,EAAAhB,UAAAyO,IAAA,SAAAzJ,EAAA0C,GLoXQ,MADAhJ,SAAQsE,IKjXhB,6DLkXexB,KAAKkN,WAAW1J,EKjX/B0C,IAEA1G,EAAAhB,UAAAsH,UAAA,SAAAI,EAAA4C,GLwXQ,GALKA,IACHxC,EAAkByC,SAAX7C,GAAmC,OAAXA,EKjXzC,kBLkXUI,EAAOJ,EAASlG,KAAKlC,OKjX/B,0CLoXYoI,GAAUlG,KKjXtBlC,QLoXQ,MAAOkC,MKjXfkG,IA0BA1G,EAAAhB,UAAA2O,aAAA,SAAAjH,EAAA4C,GLmXQ,MAAOF,GAAY5I,KAAMkG,GAAQ,EKjXzC4C,IAEAtJ,EAAAhB,UAAA4O,aAAA,SAAAlH,EAAA4C,GLmXQ,MAAOF,GAAY5I,KAAMkG,GAAQ,EKjXzC4C,IAkCAtJ,EAAAhB,UAAA6O,aAAA,SAAAnH,EAAA4C,GLmXQ,MAAOG,GAAYjJ,KAAMkG,GAAQ,EKjXzC4C,IAEAtJ,EAAAhB,UAAA8O,aAAA,SAAApH,EAAA4C,GLmXQ,MAAOG,GAAYjJ,KAAMkG,GAAQ,EKjXzC4C,IAEAtJ,EAAAhB,UAAA+O,SAAA,SAAArH,EAAA4C,GLyXQ,GANKA,IACHxC,EAAkByC,SAAX7C,GKjXjB,OLiXyCA,EKhXzC,kBLkXUI,EAAOJ,EAASlG,KAAKlC,OKjX/B,0CLoXYoI,GAAUlG,KKjXtBlC,QLiXQ,CAGA,GAAIqL,GKjXZ,ILiXkBnJ,KAAKkG,EACf,OKjXRiD,ILkXgB,IAAOnJ,KAAKkG,GAAU,MAEvBlG,KKjXfkG,KAqBA1G,EAAAhB,UAAAgP,YAAA,SAAAtH,EAAA4C,GLmXQ,MAAOI,GAAWlJ,KAAMkG,GAAQ,EKjXxC4C,IAEAtJ,EAAAhB,UAAAiP,YAAA,SAAAvH,EAAA4C,GLmXQ,MAAOI,GAAWlJ,KAAMkG,GAAQ,EKjXxC4C,IAqBAtJ,EAAAhB,UAAAkP,YAAA,SAAAxH,EAAA4C,GLmXQ,MAAOM,GAAWpJ,KAAMkG,GAAQ,EKjXxC4C,IAEAtJ,EAAAhB,UAAAmP,YAAA,SAAAzH,EAAA4C,GLmXQ,MAAOM,GAAWpJ,KAAMkG,GAAQ,EKjXxC4C,IAWAtJ,EAAAhB,UAAAoP,YAAA,SAAA1H,EAAA4C,GLmXQ,MAAOO,GAAWrJ,KAAMkG,GAAQ,EKjXxC4C,IAEAtJ,EAAAhB,UAAAqP,YAAA,SAAA3H,EAAA4C,GLmXQ,MAAOO,GAAWrJ,KAAMkG,GAAQ,EKjXxC4C,IAWAtJ,EAAAhB,UAAAsP,aAAA,SAAA5H,EAAA4C,GLmXQ,MAAOU,GAAYxJ,KAAMkG,GAAQ,EKjXzC4C,IAEAtJ,EAAAhB,UAAAuP,aAAA,SAAA7H,EAAA4C,GLmXQ,MAAOU,GAAYxJ,KAAMkG,GAAQ,EKjXzC4C,IAEAtJ,EAAAhB,UAAA0O,WAAA,SAAA9M,EAAA8F,EAAA4C,GLmXaA,IACHxC,EAAiByC,SAAV3I,GAAiC,OAAVA,EKjXxC,iBLkXUkG,EAAkByC,SAAX7C,GAAmC,OAAXA,EKjXzC,kBLkXUI,EAAOJ,EAASlG,KAAKlC,OKjX/B,wCLkXU4L,EAAUtJ,EKjXpB,MLoXY8F,GAAUlG,KAAKlC,SAEnBkC,KAAKkG,GKjXb9F,IAsBAZ,EAAAhB,UAAAwP,cAAA,SAAA5N,EAAA8F,EAAA4C,GLmXQW,EAAazJ,KAAMI,EAAO8F,GAAQ,EKjX1C4C,IAEAtJ,EAAAhB,UAAAyP,cAAA,SAAA7N,EAAA8F,EAAA4C,GLmXQW,EAAazJ,KAAMI,EAAO8F,GAAQ,EKjX1C4C,IAqBAtJ,EAAAhB,UAAA0P,cAAA,SAAA9N,EAAA8F,EAAA4C,GLmXQa,EAAa3J,KAAMI,EAAO8F,GAAQ,EKjX1C4C,IAEAtJ,EAAAhB,UAAA2P,cAAA,SAAA/N,EAAA8F,EAAA4C,GLmXQa,EAAa3J,KAAMI,EAAO8F,GAAQ,EKjX1C4C,IAEAtJ,EAAAhB,UAAA4P,UAAA,SAAAhO,EAAA8F,EAAA4C,GLmXaA,IACHxC,EAAiByC,SAAV3I,GAAiC,OAAVA,EKjXxC,iBLkXUkG,EAAkByC,SAAX7C,GAAmC,OAAXA,EKjXzC,kBLkXUI,EAAOJ,EAASlG,KAAKlC,OKjX/B,wCLkXU+L,EAAUzJ,EAAO,WAGf8F,GAAUlG,KKjXtBlC,SLoXYsC,GKjXZ,ELkXQJ,KAAKkN,WAAW9M,EAAO8F,EKjX/B4C,GLmXQ9I,KAAKkN,WAAW,IAAO9M,EAAQ,EAAG8F,EKjX1C4C,KAqBAtJ,EAAAhB,UAAA6P,aAAA,SAAAjO,EAAA8F,EAAA4C,GLmXQc,EAAY5J,KAAMI,EAAO8F,GAAQ,EKjXzC4C,IAEAtJ,EAAAhB,UAAA8P,aAAA,SAAAlO,EAAA8F,EAAA4C,GLmXQc,EAAY5J,KAAMI,EAAO8F,GAAQ,EKjXzC4C,IAqBAtJ,EAAAhB,UAAA+P,aAAA,SAAAnO,EAAA8F,EAAA4C,GLmXQgB,EAAY9J,KAAMI,EAAO8F,GAAQ,EKjXzC4C,IAEAtJ,EAAAhB,UAAAgQ,aAAA,SAAApO,EAAA8F,EAAA4C,GLmXQgB,EAAY9J,KAAMI,EAAO8F,GAAQ,EKjXzC4C,IAkBAtJ,EAAAhB,UAAAiQ,aAAA,SAAArO,EAAA8F,EAAA4C,GLmXQiB,EAAY/J,KAAMI,EAAO8F,GAAQ,EKjXzC4C,IAEAtJ,EAAAhB,UAAAkQ,aAAA,SAAAtO,EAAA8F,EAAA4C,GLmXQiB,EAAY/J,KAAMI,EAAO8F,GAAQ,EKjXzC4C,IAmBAtJ,EAAAhB,UAAAmQ,cAAA,SAAAvO,EAAA8F,EAAA4C,GLmXQmB,EAAajK,KAAMI,EAAO8F,GAAQ,EKjX1C4C,IAEAtJ,EAAAhB,UAAAoQ,cAAA,SAAAxO,EAAA8F,EAAA4C,GLmXQmB,EAAajK,KAAMI,EAAO8F,GAAQ,EKjX1C4C,IAGAtJ,EAAAhB,UAAAqQ,KAAA,SAAAzO,EAAAoH,EAAAC,GL+XQ,GAZKrH,IAAOA,EKjXpB,GLkXaoH,IAAOA,EKjXpB,GLkXaC,IAAKA,EAAMzH,KKjXxBlC,QLmX6B,gBAAVsC,KACTA,EAAQA,EAAMyC,WKjXxB,ILoXQyD,EAAwB,gBAAVlG,KAAuBsG,MAAMtG,GKjXnD,yBLkXQkG,EAAOmB,GAAOD,EKjXtB,eLoXYC,IAAQD,GACQ,IAAhBxH,KAAKlC,OAAT,CAEAwI,EAAOkB,GAAS,GAAKA,EAAQxH,KAAKlC,OKjX1C,uBLkXQwI,EAAOmB,GAAO,GAAKA,GAAOzH,KAAKlC,OKjXvC,oBLmXQ,KAAK,GAAID,GAAI2J,EAAO3J,EAAI4J,EAAK5J,IAC3BmC,KAAKnC,GKjXfuC,IAGAZ,EAAAhB,UAAAsQ,QAAA,WLqXQ,IAAK,GAFDtG,MACAzE,EAAM/D,KKjXlBlC,OLkXiBD,EAAI,EAAGA,EAAIkG,EAAKlG,IAEvB,GADA2K,EAAI3K,GAAK4K,EAAMzI,KKjXzBnC,ILkXcA,IAAMqB,EAAQyM,kBKjX5B,CLkXYnD,EAAI3K,EAAI,GKjXpB,KACA,OLoXQ,MAAO,WAAa2K,EAAIuG,KAAK,KKjXrC,KAMAvP,EAAAhB,UAAAwQ,cAAA,WLmXQ,GAA0B,mBAAftK,YKjXnB,CLkXU,GAAIlF,EAAOgG,gBACT,MAAO,IAAIhG,GAAOQ,MKjX9B6B,MLoXY,KAAK,GADD0D,GAAM,GAAIb,YAAW1E,KKjXrClC,QLkXqBD,EAAI,EAAGkG,EAAMwB,EAAIzH,OAAQD,EAAIkG,EAAKlG,GKjXvD,ELkXc0H,EAAI1H,GAAKmC,KKjXvBnC,ELkXY,OAAO0H,GKjXnB1D,OLoXU,KAAM,IAAI7E,OKjXpB,sDAWA,IAAAiS,GAAAzP,EACAhB,SAIAgB,GAAAiG,SAAA,SAAAhC,GLmaQ,MAhDAA,GAAIiC,WKjXZ,ELoXQjC,EAAIyL,KAAOzL,EKjXnBuJ,ILkXQvJ,EAAIkC,KAAOlC,EKjXnBwJ,ILoXQxJ,EAAIuJ,IAAMiC,EKjXlBjC,ILkXQvJ,EAAIwJ,IAAMgC,EKjXlBhC,ILmXQxJ,EAAIsC,MAAQkJ,EKjXpBlJ,MLkXQtC,EAAI0E,SAAW8G,EKjXvB9G,SLkXQ1E,EAAI0L,eAAiBF,EKjX7B9G,SLkXQ1E,EAAIiJ,OAASuC,EKjXrBvC,OLkXQjJ,EAAI8I,KAAO0C,EKjXnB1C,KLkXQ9I,EAAIkE,MAAQsH,EKjXpBtH,MLkXQlE,EAAIqC,UAAYmJ,EKjXxBnJ,ULkXQrC,EAAI0J,aAAe8B,EKjX3B9B,aLkXQ1J,EAAI2J,aAAe6B,EKjX3B7B,aLkXQ3J,EAAI4J,aAAe4B,EKjX3B5B,aLkXQ5J,EAAI6J,aAAe2B,EKjX3B3B,aLkXQ7J,EAAI8J,SAAW0B,EKjXvB1B,SLkXQ9J,EAAI+J,YAAcyB,EKjX1BzB,YLkXQ/J,EAAIgK,YAAcwB,EKjX1BxB,YLkXQhK,EAAIiK,YAAcuB,EKjX1BvB,YLkXQjK,EAAIkK,YAAcsB,EKjX1BtB,YLkXQlK,EAAImK,YAAcqB,EKjX1BrB,YLkXQnK,EAAIoK,YAAcoB,EKjX1BpB,YLkXQpK,EAAIqK,aAAemB,EKjX3BnB,aLkXQrK,EAAIsK,aAAekB,EKjX3BlB,aLkXQtK,EAAIyJ,WAAa+B,EKjXzB/B,WLkXQzJ,EAAIuK,cAAgBiB,EKjX5BjB,cLkXQvK,EAAIwK,cAAgBgB,EKjX5BhB,cLkXQxK,EAAIyK,cAAgBe,EKjX5Bf,cLkXQzK,EAAI0K,cAAgBc,EKjX5Bd,cLkXQ1K,EAAI2K,UAAYa,EKjXxBb,ULkXQ3K,EAAI4K,aAAeY,EKjX3BZ,aLkXQ5K,EAAI6K,aAAeW,EKjX3BX,aLkXQ7K,EAAI8K,aAAeU,EKjX3BV,aLkXQ9K,EAAI+K,aAAeS,EKjX3BT,aLkXQ/K,EAAIgL,aAAeQ,EKjX3BR,aLkXQhL,EAAIiL,aAAeO,EKjX3BP,aLkXQjL,EAAIkL,cAAgBM,EKjX5BN,cLkXQlL,EAAImL,cAAgBK,EKjX5BL,cLkXQnL,EAAIoL,KAAOI,EKjXnBJ,KLkXQpL,EAAIqL,QAAUG,EKjXtBH,QLkXQrL,EAAIuL,cAAgBC,EKjX5BD,cAEAvL,KLmfOtE,KAAKa,KAAMhB,EAAQ,UAA2B,mBAAT0C,MAAuBA,KAAyB,mBAAX1F,QAAyBA,UAAagD,EAAQ,UAAUQ,OAAQmC,UAAU,GAAIA,UAAU,GAAIA,UAAU,GAAIA,UAAU,GAAI,mEAAoE,6DACtQC,OAAU,EAAGwN,YAAa,EAAGvN,OAAU,EAAGyH,QAAW,IAAM+F,GAAI,SAAUrQ,EAASK,EAAQH,IM18CjG,SAAAI,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GA6CA,QAAAwP,MA1CA,GAAAhQ,GAAAD,EAAAH,UAEAI,GAAAiQ,SAAA,WN48CQ,GAAIC,GM18CZ,mBN08CqCxT,SAC7BA,OM18CRyT,aN28CYC,EM18CZ,mBN08C6B1T,SACrBA,OAAO2T,aAAe3T,OM18C9B4E,gBN68CQ,IAAI4O,EACF,MAAO,UAAUvQ,GAAI,MAAOjD,QAAOyT,aAAaxQ,GAGlD,IAAIyQ,EM18CZ,CN28CU,GAAIE,KAYJ,OAXA5T,QAAO4E,iBAAiB,UAAW,SAAUiP,GAC3C,GAAIhD,GAASgD,EM18CzBhD,MN28CY,KAAKA,IAAW7Q,QAAqB,OAAX6Q,IAAgC,iBAAZgD,EAAG5O,OAC/C4O,EM18CdC,kBN28CkBF,EAAM9R,OAAS,GM18CjC,CN28CgB,GAAIiS,GAAKH,EM18CzBI,OACAD,QAGA,GN48CiB,SAAkBA,GACvBH,EAAMrM,KM18ClBwM,GN28CY/T,OAAO2T,YAAY,eM18C/B,MN88CQ,MAAO,UAAkBI,GACvBE,WAAWF,EM18CrB,OAGAzQ,EAAA4Q,MAAA,UACA5Q,EAAA6Q,SAAA,EACA7Q,EAAA8Q,OACA9Q,EAAA+Q,QAIA/Q,EAAAgR,GAAAhB,EACAhQ,EAAAiR,YAAAjB,EACAhQ,EAAAkR,KAAAlB,EACAhQ,EAAAmR,IAAAnB,EACAhQ,EAAAoR,eAAApB,EACAhQ,EAAAqR,mBAAArB,EACAhQ,EAAAsR,KACAtB,EACAhQ,EAAAuR,QAAA,SAAArQ,GN48CQ,KAAM,IAAIxD,OM18ClB,qCAGAsC,EAAAwR,IAAA,WAAA,MAAA,KACAxR,EAAAyR,MAAA,SAAAC,GN48CQ,KAAM,IAAIhU,OM18ClB,qCN68COmC,KAAKa,KAAMhB,EAAQ,UAA2B,mBAAT0C,MAAuBA,KAAyB,mBAAX1F,QAAyBA,UAAagD,EAAQ,UAAUQ,OAAQmC,UAAU,GAAIA,UAAU,GAAIA,UAAU,GAAIA,UAAU,GAAI,sEAAuE,8DACzQC,OAAU,EAAGC,OAAU,IAAMoP,GAAI,SAAUjS,EAASK,EAAQH,IO7gDnE,SAAAI,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAZ,EAAAqK,KAAA,SAAA1H,EAAAqE,EAAAgL,EAAAC,EAAAC,GP+gDQ,GAAInU,GO7gDZoU,EP8gDYC,EAAgB,EAATF,EAAaD,EO7gDhC,EP8gDYI,GAAQ,GAAKD,GO7gDzB,EP8gDYE,EAAQD,GO7gDpB,EP8gDYE,KACA5T,EAAIqT,EAAOE,EAAS,EO7gDhC,EP8gDYM,EAAIR,KO7gDhB,EP8gDYtS,EAAIiD,EAAOqE,EO7gDvBrI,EPohDQ,KALAA,GO7gDR6T,EP+gDQzU,EAAI2B,GAAK,IAAM6S,GO7gDvB,EP8gDQ7S,KO7gDR6S,EP8gDQA,GO7gDRH,EP8gDeG,EAAQ,EAAGxU,EAAQ,IAAJA,EAAU4E,EAAOqE,EAASrI,GAAIA,GAAK6T,EAAGD,GAAS,GAKrE,IAHAJ,EAAIpU,GAAK,IAAMwU,GO7gDvB,EP8gDQxU,KO7gDRwU,EP8gDQA,GO7gDRN,EP8gDeM,EAAQ,EAAGJ,EAAQ,IAAJA,EAAUxP,EAAOqE,EAASrI,GAAIA,GAAK6T,EAAGD,GAAS,GAErE,GAAU,IAANxU,EACFA,EAAI,EO7gDduU,MP8gDe,CAAA,GAAIvU,IAAMsU,EACf,MAAOF,GAAIM,KAAO/S,KAAS,IO7gDrCgT,EAAAA,EP+gDUP,IAAQvJ,KAAK+J,IAAI,EO7gD3BV,GP8gDUlU,GO7gDVuU,EP+gDQ,OAAQ5S,KAAS,GAAKyS,EAAIvJ,KAAK+J,IAAI,EAAG5U,EO7gD9CkU,IAEAjS,EAAA6G,MAAA,SAAAlE,EAAAzB,EAAA8F,EAAAgL,EAAAC,EAAAC,GP+gDQ,GAAInU,GAAGoU,EO7gDftG,EP8gDYuG,EAAgB,EAATF,EAAaD,EO7gDhC,EP8gDYI,GAAQ,GAAKD,GO7gDzB,EP8gDYE,EAAQD,GO7gDpB,EP8gDYO,EAAc,KAATX,EAAcrJ,KAAK+J,IAAI,OAAU/J,KAAK+J,IAAI,OO7gD3D,EP8gDYhU,EAAIqT,EAAO,EAAIE,EO7gD3B,EP8gDYM,EAAIR,EAAO,KACXtS,EAAIwB,EAAQ,GAAe,IAAVA,GAAe,EAAIA,EAAQ,EAAI,EO7gD5D,CPgjDQ,KAjCAA,EAAQ0H,KAAKiK,IO7gDrB3R,GP+gDYsG,MAAMtG,IAAUA,IAAUwR,EAAAA,GAC5BP,EAAI3K,MAAMtG,GAAS,EO7gD7B,EP8gDUnD,EO7gDVsU,IP+gDUtU,EAAI6K,KAAKyD,MAAMzD,KAAKtG,IAAIpB,GAAS0H,KO7gD3CkK,KP8gDc5R,GAAS2K,EAAIjD,KAAK+J,IAAI,GAAI5U,IAAM,IO5gD9CA,IP8gDY8N,GO7gDZ,GPghDY3K,GADEnD,EAAIuU,GAAS,EACNM,EO7gDrB/G,EP+gDqB+G,EAAKhK,KAAK+J,IAAI,EAAG,EO7gDtCL,GP+gDcpR,EAAQ2K,GAAK,IO5gD3B9N,IP8gDY8N,GO7gDZ,GPghDc9N,EAAIuU,GAASD,GACfF,EO7gDZ,EP8gDYpU,EO7gDZsU,GP8gDqBtU,EAAIuU,GAAS,GACtBH,GAAKjR,EAAQ2K,EAAI,GAAKjD,KAAK+J,IAAI,EO7gD3CV,GP8gDYlU,GO7gDZuU,IP+gDYH,EAAIjR,EAAQ0H,KAAK+J,IAAI,EAAGL,EAAQ,GAAK1J,KAAK+J,IAAI,EO7gD1DV,GP8gDYlU,EO7gDZ,IPihDekU,GAAQ,EAAGtP,EAAOqE,EAASrI,GAAS,IAAJwT,EAAUxT,GAAK6T,EAAGL,GAAK,IAAKF,GAAQ,GAI3E,IAFAlU,EAAIA,GAAKkU,EO7gDjBE,EP8gDQC,GO7gDRH,EP8gDeG,EAAO,EAAGzP,EAAOqE,EAASrI,GAAS,IAAJZ,EAAUY,GAAK6T,EAAGzU,GAAK,IAAKqU,GAAQ,GAE1EzP,EAAOqE,EAASrI,EAAI6T,IO7gD5B,IP6gDkC9S,KAG3BO,KAAKa,KAAMhB,EAAQ,UAA2B,mBAAT0C,MAAuBA,KAAyB,mBAAX1F,QAAyBA,UAAagD,EAAQ,UAAUQ,OAAQmC,UAAU,GAAIA,UAAU,GAAIA,UAAU,GAAIA,UAAU,GAAI,uCAAwC,iCAC1OC,OAAU,EAAGC,OAAU,SQrmD9B","file":"main.min.js","sourcesContent":["'use strict'; /*!\n               *\n               *  Web Starter Kit\n               *  Copyright 2015 Google Inc. All rights reserved.\n               *\n               *  Licensed under the Apache License, Version 2.0 (the \"License\");\n               *  you may not use this file except in compliance with the License.\n               *  You may obtain a copy of the License at\n               *\n               *    https://www.apache.org/licenses/LICENSE-2.0\n               *\n               *  Unless required by applicable law or agreed to in writing, software\n               *  distributed under the License is distributed on an \"AS IS\" BASIS,\n               *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n               *  See the License for the specific language governing permissions and\n               *  limitations under the License\n               *\n               */\n/* eslint-env browser */\n(function () {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  var isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.1/8 is considered localhost for IPv4.\n  window.location.hostname.match(\n  /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));\n\n\n\n  if ('serviceWorker' in navigator && (\n  window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js').\n    then(function (registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function () {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {\n          // The updatefound event implies that registration.installing is set:\n          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n          var installingWorker = registration.installing;\n\n          installingWorker.onstatechange = function () {\n            switch (installingWorker.state) {\n              case 'installed':\n                // At this point, the old content will have been purged and the\n                // fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in the page's interface.\n                break;\n\n              case 'redundant':\n                throw new Error('The installing ' +\n                'service worker became redundant.');\n\n              default:\n              // Ignore\n            }\n          };\n        }\n      };\n    }).catch(function (e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uanMiXSwibmFtZXMiOlsiaXNMb2NhbGhvc3QiLCJCb29sZWFuIiwid2luZG93IiwibG9jYXRpb24iLCJob3N0bmFtZSIsIm1hdGNoIiwibmF2aWdhdG9yIiwicHJvdG9jb2wiLCJzZXJ2aWNlV29ya2VyIiwicmVnaXN0ZXIiLCJ0aGVuIiwicmVnaXN0cmF0aW9uIiwib251cGRhdGVmb3VuZCIsImNvbnRyb2xsZXIiLCJpbnN0YWxsaW5nV29ya2VyIiwiaW5zdGFsbGluZyIsIm9uc3RhdGVjaGFuZ2UiLCJzdGF0ZSIsIkVycm9yIiwiY2F0Y2giLCJlIiwiY29uc29sZSIsImVycm9yIl0sIm1hcHBpbmdzIjoiY0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBO0FBQ0EsQ0FBQyxZQUFXO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJQSxjQUFjQyxRQUFRQyxPQUFPQyxRQUFQLENBQWdCQyxRQUFoQixLQUE2QixXQUE3QjtBQUN0QjtBQUNBRixTQUFPQyxRQUFQLENBQWdCQyxRQUFoQixLQUE2QixPQUZQO0FBR3RCO0FBQ0FGLFNBQU9DLFFBQVAsQ0FBZ0JDLFFBQWhCLENBQXlCQyxLQUF6QjtBQUNFLDBEQURGLENBSmMsQ0FBbEI7Ozs7QUFTQSxNQUFJLG1CQUFtQkMsU0FBbkI7QUFDQ0osU0FBT0MsUUFBUCxDQUFnQkksUUFBaEIsS0FBNkIsUUFBN0IsSUFBeUNQLFdBRDFDLENBQUosRUFDNEQ7QUFDMURNLGNBQVVFLGFBQVYsQ0FBd0JDLFFBQXhCLENBQWlDLG1CQUFqQztBQUNDQyxRQURELENBQ00sVUFBU0MsWUFBVCxFQUF1QjtBQUMzQjtBQUNBQSxtQkFBYUMsYUFBYixHQUE2QixZQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSU4sVUFBVUUsYUFBVixDQUF3QkssVUFBNUIsRUFBd0M7QUFDdEM7QUFDQTtBQUNBLGNBQUlDLG1CQUFtQkgsYUFBYUksVUFBcEM7O0FBRUFELDJCQUFpQkUsYUFBakIsR0FBaUMsWUFBVztBQUMxQyxvQkFBUUYsaUJBQWlCRyxLQUF6QjtBQUNFLG1CQUFLLFdBQUw7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVGLG1CQUFLLFdBQUw7QUFDRSxzQkFBTSxJQUFJQyxLQUFKLENBQVU7QUFDQSxrREFEVixDQUFOOztBQUdGO0FBQ0U7QUFiSjtBQWVELFdBaEJEO0FBaUJEO0FBQ0YsT0E1QkQ7QUE2QkQsS0FoQ0QsRUFnQ0dDLEtBaENILENBZ0NTLFVBQVNDLENBQVQsRUFBWTtBQUNuQkMsY0FBUUMsS0FBUixDQUFjLDJDQUFkLEVBQTJERixDQUEzRDtBQUNELEtBbENEO0FBbUNEOztBQUVEO0FBQ0QsQ0F4REQiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICpcbiAqICBXZWIgU3RhcnRlciBLaXRcbiAqICBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlXG4gKlxuICovXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENoZWNrIHRvIG1ha2Ugc3VyZSBzZXJ2aWNlIHdvcmtlcnMgYXJlIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyLFxuICAvLyBhbmQgdGhhdCB0aGUgY3VycmVudCBwYWdlIGlzIGFjY2Vzc2VkIGZyb20gYSBzZWN1cmUgb3JpZ2luLiBVc2luZyBhXG4gIC8vIHNlcnZpY2Ugd29ya2VyIGZyb20gYW4gaW5zZWN1cmUgb3JpZ2luIHdpbGwgdHJpZ2dlciBKUyBjb25zb2xlIGVycm9ycy4gU2VlXG4gIC8vIGh0dHA6Ly93d3cuY2hyb21pdW0ub3JnL0hvbWUvY2hyb21pdW0tc2VjdXJpdHkvcHJlZmVyLXNlY3VyZS1vcmlnaW5zLWZvci1wb3dlcmZ1bC1uZXctZmVhdHVyZXNcbiAgdmFyIGlzTG9jYWxob3N0ID0gQm9vbGVhbih3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnIHx8XG4gICAgICAvLyBbOjoxXSBpcyB0aGUgSVB2NiBsb2NhbGhvc3QgYWRkcmVzcy5cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gJ1s6OjFdJyB8fFxuICAgICAgLy8gMTI3LjAuMC4xLzggaXMgY29uc2lkZXJlZCBsb2NhbGhvc3QgZm9yIElQdjQuXG4gICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUubWF0Y2goXG4gICAgICAgIC9eMTI3KD86XFwuKD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSl7M30kL1xuICAgICAgKVxuICAgICk7XG5cbiAgaWYgKCdzZXJ2aWNlV29ya2VyJyBpbiBuYXZpZ2F0b3IgJiZcbiAgICAgICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonIHx8IGlzTG9jYWxob3N0KSkge1xuICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKCdzZXJ2aWNlLXdvcmtlci5qcycpXG4gICAgLnRoZW4oZnVuY3Rpb24ocmVnaXN0cmF0aW9uKSB7XG4gICAgICAvLyB1cGRhdGVmb3VuZCBpcyBmaXJlZCBpZiBzZXJ2aWNlLXdvcmtlci5qcyBjaGFuZ2VzLlxuICAgICAgcmVnaXN0cmF0aW9uLm9udXBkYXRlZm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gdXBkYXRlZm91bmQgaXMgYWxzbyBmaXJlZCB0aGUgdmVyeSBmaXJzdCB0aW1lIHRoZSBTVyBpcyBpbnN0YWxsZWQsXG4gICAgICAgIC8vIGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gcHJvbXB0IGZvciBhIHJlbG9hZCBhdCB0aGF0IHBvaW50LlxuICAgICAgICAvLyBTbyBjaGVjayBoZXJlIHRvIHNlZSBpZiB0aGUgcGFnZSBpcyBhbHJlYWR5IGNvbnRyb2xsZWQsXG4gICAgICAgIC8vIGkuZS4gd2hldGhlciB0aGVyZSdzIGFuIGV4aXN0aW5nIHNlcnZpY2Ugd29ya2VyLlxuICAgICAgICBpZiAobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xuICAgICAgICAgIC8vIFRoZSB1cGRhdGVmb3VuZCBldmVudCBpbXBsaWVzIHRoYXQgcmVnaXN0cmF0aW9uLmluc3RhbGxpbmcgaXMgc2V0OlxuICAgICAgICAgIC8vIGh0dHBzOi8vc2xpZ2h0bHlvZmYuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvc3BlYy9zZXJ2aWNlX3dvcmtlci9pbmRleC5odG1sI3NlcnZpY2Utd29ya2VyLWNvbnRhaW5lci11cGRhdGVmb3VuZC1ldmVudFxuICAgICAgICAgIHZhciBpbnN0YWxsaW5nV29ya2VyID0gcmVnaXN0cmF0aW9uLmluc3RhbGxpbmc7XG5cbiAgICAgICAgICBpbnN0YWxsaW5nV29ya2VyLm9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5zdGFsbGluZ1dvcmtlci5zdGF0ZSkge1xuICAgICAgICAgICAgICBjYXNlICdpbnN0YWxsZWQnOlxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBvbGQgY29udGVudCB3aWxsIGhhdmUgYmVlbiBwdXJnZWQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGZyZXNoIGNvbnRlbnQgd2lsbCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgIC8vIEl0J3MgdGhlIHBlcmZlY3QgdGltZSB0byBkaXNwbGF5IGEgXCJOZXcgY29udGVudCBpc1xuICAgICAgICAgICAgICAgIC8vIGF2YWlsYWJsZTsgcGxlYXNlIHJlZnJlc2guXCIgbWVzc2FnZSBpbiB0aGUgcGFnZSdzIGludGVyZmFjZS5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdyZWR1bmRhbnQnOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluc3RhbGxpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZXJ2aWNlIHdvcmtlciBiZWNhbWUgcmVkdW5kYW50LicpO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uOicsIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gWW91ciBjdXN0b20gSmF2YVNjcmlwdCBnb2VzIGhlcmVcbn0pKCk7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=\n\n\"use strict\";var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {return typeof obj;} : function (obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;};var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}(function e(t, n, r) {function s(o, u) {if (!n[o]) {if (!t[o]) {var a = typeof require == \"function\" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);throw new Error(\"Cannot find module '\" + o + \"'\");}var f = n[o] = { exports: {} };t[o][0].call(f.exports, function (e) {var n = t[o][1][e];return s(n ? n : e);}, f, f.exports, e, t, n, r);}return n[o].exports;}var i = typeof require == \"function\" && require;for (var o = 0; o < r.length; o++) {s(r[o]);}return s;})({ 1: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {var\n      PosterDevice = function () {\n\n        function PosterDevice() {_classCallCheck(this, PosterDevice);\n          this.device = null;\n          this.onDisconnected = this.onDisconnected.bind(this);\n        }_createClass(PosterDevice, [{ key: \"request\", value: function request()\n\n          {var _this = this;\n            var options = {\n              filters: [{\n                name: 'MyDevice' }],\n\n              optionalServices: [0xFF02] };\n\n            return navigator.bluetooth.requestDevice(options).\n            then(function (device) {\n              _this.device = device;\n              _this.device.addEventListener('gattserverdisconnected', _this.onDisconnected);\n              return device;\n            });\n          } }, { key: \"connect\", value: function connect()\n\n          {\n            if (this.device) {\n              return this.device.gatt.connect();\n            }\n            return Promise.reject('Device is not connected.');\n          } }, { key: \"writeColor\", value: function writeColor(\n\n          data) {\n            return this.device.gatt.getPrimaryService(0xFF02).\n            then(function (service) {return service.getCharacteristic(0xFFFC);}).\n            then(function (characteristic) {return characteristic.writeValue(data);});\n          } }, { key: \"disconnect\", value: function disconnect()\n\n          {\n            if (this.device) {\n              return this.device.gatt.disconnect();\n            }\n            return Promise.reject('Device is not connected.');\n          } }, { key: \"onDisconnected\", value: function onDisconnected()\n\n          {\n            console.log('Device is disconnected.');\n          } }]);return PosterDevice;}();\n\n\n      var posterDevice = new PosterDevice();\n      module.exports = posterDevice;\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/app/device.js\", \"/app\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }], 2: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      // const BluetoothDevice = require('web-bluetooth');\n      // const stateManager = require('./app/state.js');\n      var posterDevice = require('./app/device.js');\n\n      // const service = '1ecce4f2-7f9e-11e6-ae22-56b6b6499611';\n      var characteristic = '488d7950-7f9e-11e6-ae22-56b6b6499611';\n\n      // const filter = {\n      //   name: 'MyDevice',\n      //   service: [service]\n      // };\n      var blue = void 0;\n\n      var connectButton = document.getElementById('js-connect');\n      // const disconnectButton = document.getElementById('js-disconnect');\n\n      var okButton = document.getElementById('js-ok');\n\n      // connectButton.addEventListener('click', () => {\n      //   connectButton.disabled = true;\n      //   stateManager.change('connecting');\n      //\n      //   blue = new BluetoothDevice(filter);\n      //   blue.connect()\n      //     .then(device => {\n      //       console.log(device);\n      //       stateManager.change('connected');\n      //       connectButton.disabled = false;\n      //     })\n      //     .catch(error => {\n      //       console.log(error);\n      //       stateManager.change('init');\n      //       connectButton.disabled = false;\n      //     });\n      // });\n      //\n      // disconnectButton.addEventListener('click', () => {\n      //   if (blue.disconnect()) {\n      //     stateManager.change('init');\n      //   } else {\n      //     console.log('error while disconnect');\n      //   }\n      // });\n\n      connectButton.addEventListener('click', function () {\n        posterDevice.request().\n        then(function () {return posterDevice.connect();}).\n        then(function () {\n          posterDevice.writeColor('001122');\n        }).\n        catch(function (error) {\n          console.log(error);\n        });\n      });\n      // connectButton.addEventListener('click', () => {\n      //   console.log('Requesting Bluetooth Device...');\n      //   navigator.bluetooth.requestDevice({\n      //     filters: [{services: [service]}]\n      //   })\n      //   .then(device => {\n      //     console.log('Connecting to GATT Server...');\n      //     return device.gatt.connect();\n      //   })\n      //   .then(server => {\n      //     console.log('Getting Service...');\n      //     return server.getPrimaryService(service);\n      //   })\n      //   .then(service => {\n      //     console.log('Getting Characteristics...');\n      //     // if (characteristic) {\n      //     //   // Get all characteristics that match this UUID.\n      //     //   return service.getCharacteristics(characteristic);\n      //     // }\n      //     // Get all characteristics.\n      //     return service.getCharacteristic(characteristic);\n      //     // return service.getCharacteristics();\n      //   })\n      //   .then(characteristics => {\n      //     // console.log('> Characteristics: ' +\n      //     //   characteristics.map(c => c.uuid).join('\\n' + ' '.repeat(19)));\n      //\n      //     return characteristics[0].readValue();\n      //   })\n      //   .then(value => {\n      //     console.log('Battery percentage is ' + value.getUint8(0));\n      //   })\n      //   .catch(error => {\n      //     console.log('Argh! ' + error);\n      //   });\n      // });\n\n      okButton.addEventListener('click', function () {\n        console.log('read: ' + characteristic);\n        blue.getValue(characteristic).\n        then(function (value) {\n          console.log(value);\n        });\n        // console.log('write: 026683da-7f8b-11e6-ae22-56b6b6499611');\n        // blue.writeValue('026683da-7f8b-11e6-ae22-56b6b6499611', 'ok')\n        //   .then(writeSuccess => {\n        //     console.log(writeSuccess);\n        //   })\n        //   .catch(error => {\n        //     console.log(error);\n        //   });\n      });\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/fake_85f83a39.js\", \"/\");\n  }, { \"./app/device.js\": 1, \"b55mWE\": 5, \"buffer\": 4 }], 3: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n      ;(function (exports) {\n        'use strict';\n\n        var Arr = typeof Uint8Array !== 'undefined' ?\n        Uint8Array :\n        Array;\n\n        var PLUS = '+'.charCodeAt(0);\n        var SLASH = '/'.charCodeAt(0);\n        var NUMBER = '0'.charCodeAt(0);\n        var LOWER = 'a'.charCodeAt(0);\n        var UPPER = 'A'.charCodeAt(0);\n        var PLUS_URL_SAFE = '-'.charCodeAt(0);\n        var SLASH_URL_SAFE = '_'.charCodeAt(0);\n\n        function decode(elt) {\n          var code = elt.charCodeAt(0);\n          if (code === PLUS ||\n          code === PLUS_URL_SAFE)\n          return 62; // '+'\n          if (code === SLASH ||\n          code === SLASH_URL_SAFE)\n          return 63; // '/'\n          if (code < NUMBER)\n          return -1; //no match\n          if (code < NUMBER + 10)\n          return code - NUMBER + 26 + 26;\n          if (code < UPPER + 26)\n          return code - UPPER;\n          if (code < LOWER + 26)\n          return code - LOWER + 26;\n        }\n\n        function b64ToByteArray(b64) {\n          var i, j, l, tmp, placeHolders, arr;\n\n          if (b64.length % 4 > 0) {\n            throw new Error('Invalid string. Length must be a multiple of 4');\n          }\n\n          // the number of equal signs (place holders)\n          // if there are two placeholders, than the two characters before it\n          // represent one byte\n          // if there is only one, then the three characters before it represent 2 bytes\n          // this is just a cheap hack to not do indexOf twice\n          var len = b64.length;\n          placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;\n\n          // base64 is 4/3 + up to two characters of the original data\n          arr = new Arr(b64.length * 3 / 4 - placeHolders);\n\n          // if there are placeholders, only get up to the last complete 4 chars\n          l = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n          var L = 0;\n\n          function push(v) {\n            arr[L++] = v;\n          }\n\n          for (i = 0, j = 0; i < l; i += 4, j += 3) {\n            tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));\n            push((tmp & 0xFF0000) >> 16);\n            push((tmp & 0xFF00) >> 8);\n            push(tmp & 0xFF);\n          }\n\n          if (placeHolders === 2) {\n            tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;\n            push(tmp & 0xFF);\n          } else if (placeHolders === 1) {\n            tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;\n            push(tmp >> 8 & 0xFF);\n            push(tmp & 0xFF);\n          }\n\n          return arr;\n        }\n\n        function uint8ToBase64(uint8) {\n          var i,\n          extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n          output = \"\",\n          temp,length;\n\n          function encode(num) {\n            return lookup.charAt(num);\n          }\n\n          function tripletToBase64(num) {\n            return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);\n          }\n\n          // go through the array every three bytes, we'll deal with trailing stuff later\n          for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n            temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n            output += tripletToBase64(temp);\n          }\n\n          // pad the end with zeros, but make sure to not forget the extra bytes\n          switch (extraBytes) {\n            case 1:\n              temp = uint8[uint8.length - 1];\n              output += encode(temp >> 2);\n              output += encode(temp << 4 & 0x3F);\n              output += '==';\n              break;\n            case 2:\n              temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];\n              output += encode(temp >> 10);\n              output += encode(temp >> 4 & 0x3F);\n              output += encode(temp << 2 & 0x3F);\n              output += '=';\n              break;}\n\n\n          return output;\n        }\n\n        exports.toByteArray = b64ToByteArray;\n        exports.fromByteArray = uint8ToBase64;\n      })(typeof exports === 'undefined' ? this.base64js = {} : exports);\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js\", \"/../../node_modules/gulp-browserify/node_modules/base64-js/lib\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }], 4: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      /*!\n                                                                                                                     * The buffer module from node.js, for the browser.\n                                                                                                                     *\n                                                                                                                     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n                                                                                                                     * @license  MIT\n                                                                                                                     */\n\n      var base64 = require('base64-js');\n      var ieee754 = require('ieee754');\n\n      exports.Buffer = Buffer;\n      exports.SlowBuffer = Buffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      Buffer.poolSize = 8192;\n\n      /**\n                               * If `Buffer._useTypedArrays`:\n                               *   === true    Use Uint8Array implementation (fastest)\n                               *   === false   Use Object implementation (compatible down to IE6)\n                               */\n      Buffer._useTypedArrays = function () {\n        // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,\n        // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding\n        // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support\n        // because we need to be able to add all the node Buffer API methods. This is an issue\n        // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438\n        try {\n          var buf = new ArrayBuffer(0);\n          var arr = new Uint8Array(buf);\n          arr.foo = function () {return 42;};\n          return 42 === arr.foo() &&\n          typeof arr.subarray === 'function'; // Chrome 9-10 lack `subarray`\n        } catch (e) {\n          return false;\n        }\n      }();\n\n      /**\n            * Class: Buffer\n            * =============\n            *\n            * The Buffer constructor returns instances of `Uint8Array` that are augmented\n            * with function properties for all the node `Buffer` API functions. We use\n            * `Uint8Array` so that square bracket notation works as expected -- it returns\n            * a single octet.\n            *\n            * By augmenting the instances, we can avoid modifying the `Uint8Array`\n            * prototype.\n            */\n      function Buffer(subject, encoding, noZero) {\n        if (!(this instanceof Buffer))\n        return new Buffer(subject, encoding, noZero);\n\n        var type = typeof subject === \"undefined\" ? \"undefined\" : _typeof(subject);\n\n        // Workaround: node's base64 implementation allows for non-padded strings\n        // while base64-js does not.\n        if (encoding === 'base64' && type === 'string') {\n          subject = stringtrim(subject);\n          while (subject.length % 4 !== 0) {\n            subject = subject + '=';\n          }\n        }\n\n        // Find the length\n        var length;\n        if (type === 'number')\n        length = coerce(subject);else\n        if (type === 'string')\n        length = Buffer.byteLength(subject, encoding);else\n        if (type === 'object')\n        length = coerce(subject.length); // assume that object is array-like\n        else\n          throw new Error('First argument needs to be a number, array or string.');\n\n        var buf;\n        if (Buffer._useTypedArrays) {\n          // Preferred: Return an augmented `Uint8Array` instance for best performance\n          buf = Buffer._augment(new Uint8Array(length));\n        } else {\n          // Fallback: Return THIS instance of Buffer (created by `new`)\n          buf = this;\n          buf.length = length;\n          buf._isBuffer = true;\n        }\n\n        var i;\n        if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {\n          // Speed optimization -- use set if we're copying from a typed array\n          buf._set(subject);\n        } else if (isArrayish(subject)) {\n          // Treat array-ish objects as a byte array\n          for (i = 0; i < length; i++) {\n            if (Buffer.isBuffer(subject))\n            buf[i] = subject.readUInt8(i);else\n\n            buf[i] = subject[i];\n          }\n        } else if (type === 'string') {\n          buf.write(subject, 0, encoding);\n        } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {\n          for (i = 0; i < length; i++) {\n            buf[i] = 0;\n          }\n        }\n\n        return buf;\n      }\n\n      // STATIC METHODS\n      // ==============\n\n      Buffer.isEncoding = function (encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case 'hex':\n          case 'utf8':\n          case 'utf-8':\n          case 'ascii':\n          case 'binary':\n          case 'base64':\n          case 'raw':\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            return true;\n          default:\n            return false;}\n\n      };\n\n      Buffer.isBuffer = function (b) {\n        return !!(b !== null && b !== undefined && b._isBuffer);\n      };\n\n      Buffer.byteLength = function (str, encoding) {\n        var ret;\n        str = str + '';\n        switch (encoding || 'utf8') {\n          case 'hex':\n            ret = str.length / 2;\n            break;\n          case 'utf8':\n          case 'utf-8':\n            ret = utf8ToBytes(str).length;\n            break;\n          case 'ascii':\n          case 'binary':\n          case 'raw':\n            ret = str.length;\n            break;\n          case 'base64':\n            ret = base64ToBytes(str).length;\n            break;\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            ret = str.length * 2;\n            break;\n          default:\n            throw new Error('Unknown encoding');}\n\n        return ret;\n      };\n\n      Buffer.concat = function (list, totalLength) {\n        assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\\n' +\n        'list should be an Array.');\n\n        if (list.length === 0) {\n          return new Buffer(0);\n        } else if (list.length === 1) {\n          return list[0];\n        }\n\n        var i;\n        if (typeof totalLength !== 'number') {\n          totalLength = 0;\n          for (i = 0; i < list.length; i++) {\n            totalLength += list[i].length;\n          }\n        }\n\n        var buf = new Buffer(totalLength);\n        var pos = 0;\n        for (i = 0; i < list.length; i++) {\n          var item = list[i];\n          item.copy(buf, pos);\n          pos += item.length;\n        }\n        return buf;\n      };\n\n      // BUFFER INSTANCE METHODS\n      // =======================\n\n      function _hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        var remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n\n        // must be an even number of digits\n        var strLen = string.length;\n        assert(strLen % 2 === 0, 'Invalid hex string');\n\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        for (var i = 0; i < length; i++) {\n          var byte = parseInt(string.substr(i * 2, 2), 16);\n          assert(!isNaN(byte), 'Invalid hex string');\n          buf[offset + i] = byte;\n        }\n        Buffer._charsWritten = i * 2;\n        return i;\n      }\n\n      function _utf8Write(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(utf8ToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      function _asciiWrite(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(asciiToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      function _binaryWrite(buf, string, offset, length) {\n        return _asciiWrite(buf, string, offset, length);\n      }\n\n      function _base64Write(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(base64ToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      function _utf16leWrite(buf, string, offset, length) {\n        var charsWritten = Buffer._charsWritten =\n        blitBuffer(utf16leToBytes(string), buf, offset, length);\n        return charsWritten;\n      }\n\n      Buffer.prototype.write = function (string, offset, length, encoding) {\n        // Support both (string, offset, length, encoding)\n        // and the legacy (string, encoding, offset, length)\n        if (isFinite(offset)) {\n          if (!isFinite(length)) {\n            encoding = length;\n            length = undefined;\n          }\n        } else {// legacy\n          var swap = encoding;\n          encoding = offset;\n          offset = length;\n          length = swap;\n        }\n\n        offset = Number(offset) || 0;\n        var remaining = this.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        encoding = String(encoding || 'utf8').toLowerCase();\n\n        var ret;\n        switch (encoding) {\n          case 'hex':\n            ret = _hexWrite(this, string, offset, length);\n            break;\n          case 'utf8':\n          case 'utf-8':\n            ret = _utf8Write(this, string, offset, length);\n            break;\n          case 'ascii':\n            ret = _asciiWrite(this, string, offset, length);\n            break;\n          case 'binary':\n            ret = _binaryWrite(this, string, offset, length);\n            break;\n          case 'base64':\n            ret = _base64Write(this, string, offset, length);\n            break;\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            ret = _utf16leWrite(this, string, offset, length);\n            break;\n          default:\n            throw new Error('Unknown encoding');}\n\n        return ret;\n      };\n\n      Buffer.prototype.toString = function (encoding, start, end) {\n        var self = this;\n\n        encoding = String(encoding || 'utf8').toLowerCase();\n        start = Number(start) || 0;\n        end = end !== undefined ?\n        Number(end) :\n        end = self.length;\n\n        // Fastpath empty strings\n        if (end === start)\n        return '';\n\n        var ret;\n        switch (encoding) {\n          case 'hex':\n            ret = _hexSlice(self, start, end);\n            break;\n          case 'utf8':\n          case 'utf-8':\n            ret = _utf8Slice(self, start, end);\n            break;\n          case 'ascii':\n            ret = _asciiSlice(self, start, end);\n            break;\n          case 'binary':\n            ret = _binarySlice(self, start, end);\n            break;\n          case 'base64':\n            ret = _base64Slice(self, start, end);\n            break;\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            ret = _utf16leSlice(self, start, end);\n            break;\n          default:\n            throw new Error('Unknown encoding');}\n\n        return ret;\n      };\n\n      Buffer.prototype.toJSON = function () {\n        return {\n          type: 'Buffer',\n          data: Array.prototype.slice.call(this._arr || this, 0) };\n\n      };\n\n      // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n      Buffer.prototype.copy = function (target, target_start, start, end) {\n        var source = this;\n\n        if (!start) start = 0;\n        if (!end && end !== 0) end = this.length;\n        if (!target_start) target_start = 0;\n\n        // Copy 0 bytes; we're done\n        if (end === start) return;\n        if (target.length === 0 || source.length === 0) return;\n\n        // Fatal error conditions\n        assert(end >= start, 'sourceEnd < sourceStart');\n        assert(target_start >= 0 && target_start < target.length,\n        'targetStart out of bounds');\n        assert(start >= 0 && start < source.length, 'sourceStart out of bounds');\n        assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds');\n\n        // Are we oob?\n        if (end > this.length)\n        end = this.length;\n        if (target.length - target_start < end - start)\n        end = target.length - target_start + start;\n\n        var len = end - start;\n\n        if (len < 100 || !Buffer._useTypedArrays) {\n          for (var i = 0; i < len; i++) {\n            target[i + target_start] = this[i + start];}\n        } else {\n          target._set(this.subarray(start, start + len), target_start);\n        }\n      };\n\n      function _base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n\n      function _utf8Slice(buf, start, end) {\n        var res = '';\n        var tmp = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; i++) {\n          if (buf[i] <= 0x7F) {\n            res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);\n            tmp = '';\n          } else {\n            tmp += '%' + buf[i].toString(16);\n          }\n        }\n\n        return res + decodeUtf8Char(tmp);\n      }\n\n      function _asciiSlice(buf, start, end) {\n        var ret = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; i++) {\n          ret += String.fromCharCode(buf[i]);}\n        return ret;\n      }\n\n      function _binarySlice(buf, start, end) {\n        return _asciiSlice(buf, start, end);\n      }\n\n      function _hexSlice(buf, start, end) {\n        var len = buf.length;\n\n        if (!start || start < 0) start = 0;\n        if (!end || end < 0 || end > len) end = len;\n\n        var out = '';\n        for (var i = start; i < end; i++) {\n          out += toHex(buf[i]);\n        }\n        return out;\n      }\n\n      function _utf16leSlice(buf, start, end) {\n        var bytes = buf.slice(start, end);\n        var res = '';\n        for (var i = 0; i < bytes.length; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n\n      Buffer.prototype.slice = function (start, end) {\n        var len = this.length;\n        start = clamp(start, len, 0);\n        end = clamp(end, len, len);\n\n        if (Buffer._useTypedArrays) {\n          return Buffer._augment(this.subarray(start, end));\n        } else {\n          var sliceLen = end - start;\n          var newBuf = new Buffer(sliceLen, undefined, true);\n          for (var i = 0; i < sliceLen; i++) {\n            newBuf[i] = this[i + start];\n          }\n          return newBuf;\n        }\n      };\n\n      // `get` will be removed in Node 0.13+\n      Buffer.prototype.get = function (offset) {\n        console.log('.get() is deprecated. Access using array indexes instead.');\n        return this.readUInt8(offset);\n      };\n\n      // `set` will be removed in Node 0.13+\n      Buffer.prototype.set = function (v, offset) {\n        console.log('.set() is deprecated. Access using array indexes instead.');\n        return this.writeUInt8(v, offset);\n      };\n\n      Buffer.prototype.readUInt8 = function (offset, noAssert) {\n        if (!noAssert) {\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset < this.length, 'Trying to read beyond buffer length');\n        }\n\n        if (offset >= this.length)\n        return;\n\n        return this[offset];\n      };\n\n      function _readUInt16(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val;\n        if (littleEndian) {\n          val = buf[offset];\n          if (offset + 1 < len)\n          val |= buf[offset + 1] << 8;\n        } else {\n          val = buf[offset] << 8;\n          if (offset + 1 < len)\n          val |= buf[offset + 1];\n        }\n        return val;\n      }\n\n      Buffer.prototype.readUInt16LE = function (offset, noAssert) {\n        return _readUInt16(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readUInt16BE = function (offset, noAssert) {\n        return _readUInt16(this, offset, false, noAssert);\n      };\n\n      function _readUInt32(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val;\n        if (littleEndian) {\n          if (offset + 2 < len)\n          val = buf[offset + 2] << 16;\n          if (offset + 1 < len)\n          val |= buf[offset + 1] << 8;\n          val |= buf[offset];\n          if (offset + 3 < len)\n          val = val + (buf[offset + 3] << 24 >>> 0);\n        } else {\n          if (offset + 1 < len)\n          val = buf[offset + 1] << 16;\n          if (offset + 2 < len)\n          val |= buf[offset + 2] << 8;\n          if (offset + 3 < len)\n          val |= buf[offset + 3];\n          val = val + (buf[offset] << 24 >>> 0);\n        }\n        return val;\n      }\n\n      Buffer.prototype.readUInt32LE = function (offset, noAssert) {\n        return _readUInt32(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readUInt32BE = function (offset, noAssert) {\n        return _readUInt32(this, offset, false, noAssert);\n      };\n\n      Buffer.prototype.readInt8 = function (offset, noAssert) {\n        if (!noAssert) {\n          assert(offset !== undefined && offset !== null,\n          'missing offset');\n          assert(offset < this.length, 'Trying to read beyond buffer length');\n        }\n\n        if (offset >= this.length)\n        return;\n\n        var neg = this[offset] & 0x80;\n        if (neg)\n        return (0xff - this[offset] + 1) * -1;else\n\n        return this[offset];\n      };\n\n      function _readInt16(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val = _readUInt16(buf, offset, littleEndian, true);\n        var neg = val & 0x8000;\n        if (neg)\n        return (0xffff - val + 1) * -1;else\n\n        return val;\n      }\n\n      Buffer.prototype.readInt16LE = function (offset, noAssert) {\n        return _readInt16(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readInt16BE = function (offset, noAssert) {\n        return _readInt16(this, offset, false, noAssert);\n      };\n\n      function _readInt32(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        var val = _readUInt32(buf, offset, littleEndian, true);\n        var neg = val & 0x80000000;\n        if (neg)\n        return (0xffffffff - val + 1) * -1;else\n\n        return val;\n      }\n\n      Buffer.prototype.readInt32LE = function (offset, noAssert) {\n        return _readInt32(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readInt32BE = function (offset, noAssert) {\n        return _readInt32(this, offset, false, noAssert);\n      };\n\n      function _readFloat(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        return ieee754.read(buf, offset, littleEndian, 23, 4);\n      }\n\n      Buffer.prototype.readFloatLE = function (offset, noAssert) {\n        return _readFloat(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readFloatBE = function (offset, noAssert) {\n        return _readFloat(this, offset, false, noAssert);\n      };\n\n      function _readDouble(buf, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset + 7 < buf.length, 'Trying to read beyond buffer length');\n        }\n\n        return ieee754.read(buf, offset, littleEndian, 52, 8);\n      }\n\n      Buffer.prototype.readDoubleLE = function (offset, noAssert) {\n        return _readDouble(this, offset, true, noAssert);\n      };\n\n      Buffer.prototype.readDoubleBE = function (offset, noAssert) {\n        return _readDouble(this, offset, false, noAssert);\n      };\n\n      Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset < this.length, 'trying to write beyond buffer length');\n          verifuint(value, 0xff);\n        }\n\n        if (offset >= this.length) return;\n\n        this[offset] = value;\n      };\n\n      function _writeUInt16(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'trying to write beyond buffer length');\n          verifuint(value, 0xffff);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {\n          buf[offset + i] =\n          (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>>\n          (littleEndian ? i : 1 - i) * 8;\n        }\n      }\n\n      Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n        _writeUInt16(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n        _writeUInt16(this, value, offset, false, noAssert);\n      };\n\n      function _writeUInt32(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'trying to write beyond buffer length');\n          verifuint(value, 0xffffffff);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {\n          buf[offset + i] =\n          value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n        }\n      }\n\n      Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n        _writeUInt32(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n        _writeUInt32(this, value, offset, false, noAssert);\n      };\n\n      Buffer.prototype.writeInt8 = function (value, offset, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset < this.length, 'Trying to write beyond buffer length');\n          verifsint(value, 0x7f, -0x80);\n        }\n\n        if (offset >= this.length)\n        return;\n\n        if (value >= 0)\n        this.writeUInt8(value, offset, noAssert);else\n\n        this.writeUInt8(0xff + value + 1, offset, noAssert);\n      };\n\n      function _writeInt16(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 1 < buf.length, 'Trying to write beyond buffer length');\n          verifsint(value, 0x7fff, -0x8000);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        if (value >= 0)\n        _writeUInt16(buf, value, offset, littleEndian, noAssert);else\n\n        _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert);\n      }\n\n      Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n        _writeInt16(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n        _writeInt16(this, value, offset, false, noAssert);\n      };\n\n      function _writeInt32(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');\n          verifsint(value, 0x7fffffff, -0x80000000);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        if (value >= 0)\n        _writeUInt32(buf, value, offset, littleEndian, noAssert);else\n\n        _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert);\n      }\n\n      Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n        _writeInt32(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n        _writeInt32(this, value, offset, false, noAssert);\n      };\n\n      function _writeFloat(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');\n          verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n      }\n\n      Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n        _writeFloat(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n        _writeFloat(this, value, offset, false, noAssert);\n      };\n\n      function _writeDouble(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          assert(value !== undefined && value !== null, 'missing value');\n          assert(typeof littleEndian === 'boolean', 'missing or invalid endian');\n          assert(offset !== undefined && offset !== null, 'missing offset');\n          assert(offset + 7 < buf.length,\n          'Trying to write beyond buffer length');\n          verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n        }\n\n        var len = buf.length;\n        if (offset >= len)\n        return;\n\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n      }\n\n      Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n        _writeDouble(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n        _writeDouble(this, value, offset, false, noAssert);\n      };\n\n      // fill(value, start=0, end=buffer.length)\n      Buffer.prototype.fill = function (value, start, end) {\n        if (!value) value = 0;\n        if (!start) start = 0;\n        if (!end) end = this.length;\n\n        if (typeof value === 'string') {\n          value = value.charCodeAt(0);\n        }\n\n        assert(typeof value === 'number' && !isNaN(value), 'value is not a number');\n        assert(end >= start, 'end < start');\n\n        // Fill 0 bytes; we're done\n        if (end === start) return;\n        if (this.length === 0) return;\n\n        assert(start >= 0 && start < this.length, 'start out of bounds');\n        assert(end >= 0 && end <= this.length, 'end out of bounds');\n\n        for (var i = start; i < end; i++) {\n          this[i] = value;\n        }\n      };\n\n      Buffer.prototype.inspect = function () {\n        var out = [];\n        var len = this.length;\n        for (var i = 0; i < len; i++) {\n          out[i] = toHex(this[i]);\n          if (i === exports.INSPECT_MAX_BYTES) {\n            out[i + 1] = '...';\n            break;\n          }\n        }\n        return '<Buffer ' + out.join(' ') + '>';\n      };\n\n      /**\n          * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n          * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n          */\n      Buffer.prototype.toArrayBuffer = function () {\n        if (typeof Uint8Array !== 'undefined') {\n          if (Buffer._useTypedArrays) {\n            return new Buffer(this).buffer;\n          } else {\n            var buf = new Uint8Array(this.length);\n            for (var i = 0, len = buf.length; i < len; i += 1) {\n              buf[i] = this[i];}\n            return buf.buffer;\n          }\n        } else {\n          throw new Error('Buffer.toArrayBuffer not supported in this browser');\n        }\n      };\n\n      // HELPER FUNCTIONS\n      // ================\n\n      function stringtrim(str) {\n        if (str.trim) return str.trim();\n        return str.replace(/^\\s+|\\s+$/g, '');\n      }\n\n      var BP = Buffer.prototype;\n\n      /**\n                                  * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n                                  */\n      Buffer._augment = function (arr) {\n        arr._isBuffer = true;\n\n        // save reference to original Uint8Array get/set methods before overwriting\n        arr._get = arr.get;\n        arr._set = arr.set;\n\n        // deprecated, will be removed in node 0.13+\n        arr.get = BP.get;\n        arr.set = BP.set;\n\n        arr.write = BP.write;\n        arr.toString = BP.toString;\n        arr.toLocaleString = BP.toString;\n        arr.toJSON = BP.toJSON;\n        arr.copy = BP.copy;\n        arr.slice = BP.slice;\n        arr.readUInt8 = BP.readUInt8;\n        arr.readUInt16LE = BP.readUInt16LE;\n        arr.readUInt16BE = BP.readUInt16BE;\n        arr.readUInt32LE = BP.readUInt32LE;\n        arr.readUInt32BE = BP.readUInt32BE;\n        arr.readInt8 = BP.readInt8;\n        arr.readInt16LE = BP.readInt16LE;\n        arr.readInt16BE = BP.readInt16BE;\n        arr.readInt32LE = BP.readInt32LE;\n        arr.readInt32BE = BP.readInt32BE;\n        arr.readFloatLE = BP.readFloatLE;\n        arr.readFloatBE = BP.readFloatBE;\n        arr.readDoubleLE = BP.readDoubleLE;\n        arr.readDoubleBE = BP.readDoubleBE;\n        arr.writeUInt8 = BP.writeUInt8;\n        arr.writeUInt16LE = BP.writeUInt16LE;\n        arr.writeUInt16BE = BP.writeUInt16BE;\n        arr.writeUInt32LE = BP.writeUInt32LE;\n        arr.writeUInt32BE = BP.writeUInt32BE;\n        arr.writeInt8 = BP.writeInt8;\n        arr.writeInt16LE = BP.writeInt16LE;\n        arr.writeInt16BE = BP.writeInt16BE;\n        arr.writeInt32LE = BP.writeInt32LE;\n        arr.writeInt32BE = BP.writeInt32BE;\n        arr.writeFloatLE = BP.writeFloatLE;\n        arr.writeFloatBE = BP.writeFloatBE;\n        arr.writeDoubleLE = BP.writeDoubleLE;\n        arr.writeDoubleBE = BP.writeDoubleBE;\n        arr.fill = BP.fill;\n        arr.inspect = BP.inspect;\n        arr.toArrayBuffer = BP.toArrayBuffer;\n\n        return arr;\n      };\n\n      // slice(start, end)\n      function clamp(index, len, defaultValue) {\n        if (typeof index !== 'number') return defaultValue;\n        index = ~~index; // Coerce to integer.\n        if (index >= len) return len;\n        if (index >= 0) return index;\n        index += len;\n        if (index >= 0) return index;\n        return 0;\n      }\n\n      function coerce(length) {\n        // Coerce length to a number (possibly NaN), round up\n        // in case it's fractional (e.g. 123.456) then do a\n        // double negate to coerce a NaN to 0. Easy, right?\n        length = ~~Math.ceil(+length);\n        return length < 0 ? 0 : length;\n      }\n\n      function isArray(subject) {\n        return (Array.isArray || function (subject) {\n          return Object.prototype.toString.call(subject) === '[object Array]';\n        })(subject);\n      }\n\n      function isArrayish(subject) {\n        return isArray(subject) || Buffer.isBuffer(subject) ||\n        subject && (typeof subject === \"undefined\" ? \"undefined\" : _typeof(subject)) === 'object' &&\n        typeof subject.length === 'number';\n      }\n\n      function toHex(n) {\n        if (n < 16) return '0' + n.toString(16);\n        return n.toString(16);\n      }\n\n      function utf8ToBytes(str) {\n        var byteArray = [];\n        for (var i = 0; i < str.length; i++) {\n          var b = str.charCodeAt(i);\n          if (b <= 0x7F)\n          byteArray.push(str.charCodeAt(i));else\n          {\n            var start = i;\n            if (b >= 0xD800 && b <= 0xDFFF) i++;\n            var h = encodeURIComponent(str.slice(start, i + 1)).substr(1).split('%');\n            for (var j = 0; j < h.length; j++) {\n              byteArray.push(parseInt(h[j], 16));}\n          }\n        }\n        return byteArray;\n      }\n\n      function asciiToBytes(str) {\n        var byteArray = [];\n        for (var i = 0; i < str.length; i++) {\n          // Node's code seems to be doing this and not & 0x7F..\n          byteArray.push(str.charCodeAt(i) & 0xFF);\n        }\n        return byteArray;\n      }\n\n      function utf16leToBytes(str) {\n        var c, hi, lo;\n        var byteArray = [];\n        for (var i = 0; i < str.length; i++) {\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n\n        return byteArray;\n      }\n\n      function base64ToBytes(str) {\n        return base64.toByteArray(str);\n      }\n\n      function blitBuffer(src, dst, offset, length) {\n        var pos;\n        for (var i = 0; i < length; i++) {\n          if (i + offset >= dst.length || i >= src.length)\n          break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n\n      function decodeUtf8Char(str) {\n        try {\n          return decodeURIComponent(str);\n        } catch (err) {\n          return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n        }\n      }\n\n      /*\n         * We have to make sure that the value is a valid integer. This means that it\n         * is non-negative. It has no fractional component and that it does not\n         * exceed the maximum allowed value.\n         */\n      function verifuint(value, max) {\n        assert(typeof value === 'number', 'cannot write a non-number as a number');\n        assert(value >= 0, 'specified a negative value for writing an unsigned value');\n        assert(value <= max, 'value is larger than maximum value for type');\n        assert(Math.floor(value) === value, 'value has a fractional component');\n      }\n\n      function verifsint(value, max, min) {\n        assert(typeof value === 'number', 'cannot write a non-number as a number');\n        assert(value <= max, 'value larger than maximum allowed value');\n        assert(value >= min, 'value smaller than minimum allowed value');\n        assert(Math.floor(value) === value, 'value has a fractional component');\n      }\n\n      function verifIEEE754(value, max, min) {\n        assert(typeof value === 'number', 'cannot write a non-number as a number');\n        assert(value <= max, 'value larger than maximum allowed value');\n        assert(value >= min, 'value smaller than minimum allowed value');\n      }\n\n      function assert(test, message) {\n        if (!test) throw new Error(message || 'Failed assertion');\n      }\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/gulp-browserify/node_modules/buffer/index.js\", \"/../../node_modules/gulp-browserify/node_modules/buffer\");\n  }, { \"b55mWE\": 5, \"base64-js\": 3, \"buffer\": 4, \"ieee754\": 6 }], 5: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      // shim for using process in browser\n\n      var process = module.exports = {};\n\n      process.nextTick = function () {\n        var canSetImmediate = typeof window !== 'undefined' &&\n        window.setImmediate;\n        var canPost = typeof window !== 'undefined' &&\n        window.postMessage && window.addEventListener;\n\n\n        if (canSetImmediate) {\n          return function (f) {return window.setImmediate(f);};\n        }\n\n        if (canPost) {\n          var queue = [];\n          window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n              ev.stopPropagation();\n              if (queue.length > 0) {\n                var fn = queue.shift();\n                fn();\n              }\n            }\n          }, true);\n\n          return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n          };\n        }\n\n        return function nextTick(fn) {\n          setTimeout(fn, 0);\n        };\n      }();\n\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      // TODO(shtylman)\n      process.cwd = function () {return '/';};\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/gulp-browserify/node_modules/process/browser.js\", \"/../../node_modules/gulp-browserify/node_modules/process\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }], 6: [function (require, module, exports) {\n    (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {\n      exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s = buffer[offset + i];\n\n        i += d;\n\n        e = s & (1 << -nBits) - 1;\n        s >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n\n      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n\n        value = Math.abs(value);\n\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n        buffer[offset + i - d] |= s * 128;\n      };\n\n    }).call(this, require(\"b55mWE\"), typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/../../node_modules/ieee754/index.js\", \"/../../node_modules/ieee754\");\n  }, { \"b55mWE\": 5, \"buffer\": 4 }] }, {}, [2]);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qLnZhbGxlbHVuZ2EvV29ya3NwYWNlcy90ZXNpcy9zZWFtbGVzcy1wb3N0ZXItY29udHJvbC9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvai52YWxsZWx1bmdhL1dvcmtzcGFjZXMvdGVzaXMvc2VhbWxlc3MtcG9zdGVyLWNvbnRyb2wvYXBwL3NjcmlwdHMvYXBwL2RldmljZS5qcyIsIi9Vc2Vycy9qLnZhbGxlbHVuZ2EvV29ya3NwYWNlcy90ZXNpcy9zZWFtbGVzcy1wb3N0ZXItY29udHJvbC9hcHAvc2NyaXB0cy9mYWtlXzg1ZjgzYTM5LmpzIiwiL1VzZXJzL2oudmFsbGVsdW5nYS9Xb3Jrc3BhY2VzL3Rlc2lzL3NlYW1sZXNzLXBvc3Rlci1jb250cm9sL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwiL1VzZXJzL2oudmFsbGVsdW5nYS9Xb3Jrc3BhY2VzL3Rlc2lzL3NlYW1sZXNzLXBvc3Rlci1jb250cm9sL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi9Vc2Vycy9qLnZhbGxlbHVuZ2EvV29ya3NwYWNlcy90ZXNpcy9zZWFtbGVzcy1wb3N0ZXItY29udHJvbC9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvai52YWxsZWx1bmdhL1dvcmtzcGFjZXMvdGVzaXMvc2VhbWxlc3MtcG9zdGVyLWNvbnRyb2wvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQ0FBO0FBRUEsQUFDQTs7Z0NBQ0E7d0JBQ0E7eURBQ0E7QUFDQSxBQUNBLFNBUEE7O0FBUUE7MEJBQ0E7d0JBQ0E7c0JBQ0EsQUFDQTs7aUNBQ0EsQUFDQTs7cURBQ0E7bUNBQ0E7NkJBQ0E7NEVBQ0E7cUJBQ0E7QUFDQTtBQUNBLEFBQ0E7O0FBQ0E7NkJBQ0E7c0NBQ0E7QUFDQTtrQ0FDQTtBQUNBLEFBQ0E7O2dCQUNBO3NEQUNBO3NFQUNBOzZFQUNBO0FBQ0EsQUFDQTs7QUFDQTs2QkFDQTtzQ0FDQTtBQUNBO2tDQUNBO0FBQ0EsQUFDQTs7QUFDQTt3QkFDQTtBQUNBLEFBQ0E7OztBQUNBO0FBQ0EsdUJBQ0EsQUFDQTs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQSxpQ0FDQTs7QUFDQTtBQUNBLDJCQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFDQTs7QUFDQTtBQUNBLEFBQ0E7O0FBQ0EsNkNBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQUFDQTs7QUFDQSwwREFDQTtxQkFDQTs4Q0FDQTt5QkFDQTtrQ0FDQTtBQUNBOytCQUNBO3NCQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEFBQ0E7O0FBQ0EscURBQ0E7K0JBQ0E7c0JBQ0E7OEJBQ0E7c0JBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxBQUNBOzs7O0FDNUdBO0FBQ0EsbUJBQ0E7O0FBQ0EsMkJBQ0E7QUFDQSxBQUNBOzt3Q0FDQTtBQUNBO0FBQ0EsQUFDQTs7a0NBQ0E7bUNBQ0E7b0NBQ0E7bUNBQ0E7bUNBQ0E7MkNBQ0E7NENBQ0EsQUFD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O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQ0E7O0FBQ0EsdUJBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQ0E7O0FBQ0Esd0NBQ0E7d0JBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EscUNBQ0E7d0JBQ0E7QUFDQSxBQUNBOzs7O0FDakVBO0FBQ0EsbUVBQ0E7ZUFDQTt1Q0FDQTtpQ0FDQTs0QkFDQTtxQkFDQTtvQ0FDQTs0QkFDQTtnQ0FDQSxBQUNBOzthQUNBLEFBQ0E7O2dDQUNBO2VBQ0E7aUJBQ0E7aUZBQ0EsQUFDQTs7Z0NBQ0E7ZUFDQTtpQkFDQTtpRkFDQSxBQUNBOztxQkFDQTtrQkFDQTsrQkFDQTswQ0FDQTtlQUNBOzhCQUNBO2tCQUNBO0FBQ0E7a0RBQ0E7QUFDQTs7QUFDQSwyRUFDQTtrQkFDQTt1Q0FDQTtpQ0FDQTs0QkFDQTtxRUFDQTtvQ0FDQTs0QkFDQTtnRUFDQSxBQUNBOzt5QkFDQSxBQUNBOztnREFDQTtpQ0FDQTtjQUNBO2VBQ0E7Z0RBQ0E7aURBQ0E7QUFDQTtpQkFDQTtBQUNBOzhCQUNBOzBCQUNBO2lCQUNBOzBDQUNBO0FBQ0E7OEJBQ0E7QUFDQTtpQkFDQTtBQUNBLEFBQ0E7O2lDQUNBO2dCQUNBO2dCQUNBO3FDQUNBOzhDQUNBO29CQUNBO2lCQUNBOzZEQUNBO2dCQUNBO0FBQ0E7QUFDQSxBQUNBOzt1RkFDQSxBQUNBOzt3QkFDQTtnQkFDQTtzRkFDQSxBQUNBOztzQ0FDQTtBQUNBLEFBQ0E7OztvQ050RkEiLCJmaWxlIjoiYXBwLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5jbGFzcyBQb3N0ZXJEZXZpY2Uge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGV2aWNlID0gbnVsbDtcbiAgICB0aGlzLm9uRGlzY29ubmVjdGVkID0gdGhpcy5vbkRpc2Nvbm5lY3RlZC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgcmVxdWVzdCgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgIGZpbHRlcnM6IFt7XG4gICAgICAgIG5hbWU6ICdNeURldmljZSdcbiAgICAgIH1dLFxuICAgICAgb3B0aW9uYWxTZXJ2aWNlczogWzB4RkYwMl1cbiAgICB9O1xuICAgIHJldHVybiBuYXZpZ2F0b3IuYmx1ZXRvb3RoLnJlcXVlc3REZXZpY2Uob3B0aW9ucylcbiAgICAudGhlbihkZXZpY2UgPT4ge1xuICAgICAgdGhpcy5kZXZpY2UgPSBkZXZpY2U7XG4gICAgICB0aGlzLmRldmljZS5hZGRFdmVudExpc3RlbmVyKCdnYXR0c2VydmVyZGlzY29ubmVjdGVkJywgdGhpcy5vbkRpc2Nvbm5lY3RlZCk7XG4gICAgICByZXR1cm4gZGV2aWNlO1xuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5kZXZpY2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmRldmljZS5nYXR0LmNvbm5lY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdEZXZpY2UgaXMgbm90IGNvbm5lY3RlZC4nKTtcbiAgfVxuXG4gIHdyaXRlQ29sb3IoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLmRldmljZS5nYXR0LmdldFByaW1hcnlTZXJ2aWNlKDB4RkYwMilcbiAgICAudGhlbihzZXJ2aWNlID0+IHNlcnZpY2UuZ2V0Q2hhcmFjdGVyaXN0aWMoMHhGRkZDKSlcbiAgICAudGhlbihjaGFyYWN0ZXJpc3RpYyA9PiBjaGFyYWN0ZXJpc3RpYy53cml0ZVZhbHVlKGRhdGEpKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuZGV2aWNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXZpY2UuZ2F0dC5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnRGV2aWNlIGlzIG5vdCBjb25uZWN0ZWQuJyk7XG4gIH1cblxuICBvbkRpc2Nvbm5lY3RlZCgpIHtcbiAgICBjb25zb2xlLmxvZygnRGV2aWNlIGlzIGRpc2Nvbm5lY3RlZC4nKTtcbiAgfVxufVxuXG5jb25zdCBwb3N0ZXJEZXZpY2UgPSBuZXcgUG9zdGVyRGV2aWNlKCk7XG5tb2R1bGUuZXhwb3J0cyA9IHBvc3RlckRldmljZTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJiNTVtV0VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9hcHAvZGV2aWNlLmpzXCIsXCIvYXBwXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gY29uc3QgQmx1ZXRvb3RoRGV2aWNlID0gcmVxdWlyZSgnd2ViLWJsdWV0b290aCcpO1xuLy8gY29uc3Qgc3RhdGVNYW5hZ2VyID0gcmVxdWlyZSgnLi9hcHAvc3RhdGUuanMnKTtcbmNvbnN0IHBvc3RlckRldmljZSA9IHJlcXVpcmUoJy4vYXBwL2RldmljZS5qcycpO1xuXG4vLyBjb25zdCBzZXJ2aWNlID0gJzFlY2NlNGYyLTdmOWUtMTFlNi1hZTIyLTU2YjZiNjQ5OTYxMSc7XG5jb25zdCBjaGFyYWN0ZXJpc3RpYyA9ICc0ODhkNzk1MC03ZjllLTExZTYtYWUyMi01NmI2YjY0OTk2MTEnO1xuXG4vLyBjb25zdCBmaWx0ZXIgPSB7XG4vLyAgIG5hbWU6ICdNeURldmljZScsXG4vLyAgIHNlcnZpY2U6IFtzZXJ2aWNlXVxuLy8gfTtcbmxldCBibHVlO1xuXG5jb25zdCBjb25uZWN0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2pzLWNvbm5lY3QnKTtcbi8vIGNvbnN0IGRpc2Nvbm5lY3RCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnanMtZGlzY29ubmVjdCcpO1xuXG5jb25zdCBva0J1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdqcy1vaycpO1xuXG4vLyBjb25uZWN0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuLy8gICBjb25uZWN0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbi8vICAgc3RhdGVNYW5hZ2VyLmNoYW5nZSgnY29ubmVjdGluZycpO1xuLy9cbi8vICAgYmx1ZSA9IG5ldyBCbHVldG9vdGhEZXZpY2UoZmlsdGVyKTtcbi8vICAgYmx1ZS5jb25uZWN0KClcbi8vICAgICAudGhlbihkZXZpY2UgPT4ge1xuLy8gICAgICAgY29uc29sZS5sb2coZGV2aWNlKTtcbi8vICAgICAgIHN0YXRlTWFuYWdlci5jaGFuZ2UoJ2Nvbm5lY3RlZCcpO1xuLy8gICAgICAgY29ubmVjdEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuLy8gICAgIH0pXG4vLyAgICAgLmNhdGNoKGVycm9yID0+IHtcbi8vICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbi8vICAgICAgIHN0YXRlTWFuYWdlci5jaGFuZ2UoJ2luaXQnKTtcbi8vICAgICAgIGNvbm5lY3RCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbi8vICAgICB9KTtcbi8vIH0pO1xuLy9cbi8vIGRpc2Nvbm5lY3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4vLyAgIGlmIChibHVlLmRpc2Nvbm5lY3QoKSkge1xuLy8gICAgIHN0YXRlTWFuYWdlci5jaGFuZ2UoJ2luaXQnKTtcbi8vICAgfSBlbHNlIHtcbi8vICAgICBjb25zb2xlLmxvZygnZXJyb3Igd2hpbGUgZGlzY29ubmVjdCcpO1xuLy8gICB9XG4vLyB9KTtcblxuY29ubmVjdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgcG9zdGVyRGV2aWNlLnJlcXVlc3QoKVxuICAudGhlbigoKSA9PiBwb3N0ZXJEZXZpY2UuY29ubmVjdCgpKVxuICAudGhlbigoKSA9PiB7XG4gICAgcG9zdGVyRGV2aWNlLndyaXRlQ29sb3IoJzAwMTEyMicpO1xuICB9KVxuICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgfSk7XG59KTtcbi8vIGNvbm5lY3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4vLyAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0aW5nIEJsdWV0b290aCBEZXZpY2UuLi4nKTtcbi8vICAgbmF2aWdhdG9yLmJsdWV0b290aC5yZXF1ZXN0RGV2aWNlKHtcbi8vICAgICBmaWx0ZXJzOiBbe3NlcnZpY2VzOiBbc2VydmljZV19XVxuLy8gICB9KVxuLy8gICAudGhlbihkZXZpY2UgPT4ge1xuLy8gICAgIGNvbnNvbGUubG9nKCdDb25uZWN0aW5nIHRvIEdBVFQgU2VydmVyLi4uJyk7XG4vLyAgICAgcmV0dXJuIGRldmljZS5nYXR0LmNvbm5lY3QoKTtcbi8vICAgfSlcbi8vICAgLnRoZW4oc2VydmVyID0+IHtcbi8vICAgICBjb25zb2xlLmxvZygnR2V0dGluZyBTZXJ2aWNlLi4uJyk7XG4vLyAgICAgcmV0dXJuIHNlcnZlci5nZXRQcmltYXJ5U2VydmljZShzZXJ2aWNlKTtcbi8vICAgfSlcbi8vICAgLnRoZW4oc2VydmljZSA9PiB7XG4vLyAgICAgY29uc29sZS5sb2coJ0dldHRpbmcgQ2hhcmFjdGVyaXN0aWNzLi4uJyk7XG4vLyAgICAgLy8gaWYgKGNoYXJhY3RlcmlzdGljKSB7XG4vLyAgICAgLy8gICAvLyBHZXQgYWxsIGNoYXJhY3RlcmlzdGljcyB0aGF0IG1hdGNoIHRoaXMgVVVJRC5cbi8vICAgICAvLyAgIHJldHVybiBzZXJ2aWNlLmdldENoYXJhY3RlcmlzdGljcyhjaGFyYWN0ZXJpc3RpYyk7XG4vLyAgICAgLy8gfVxuLy8gICAgIC8vIEdldCBhbGwgY2hhcmFjdGVyaXN0aWNzLlxuLy8gICAgIHJldHVybiBzZXJ2aWNlLmdldENoYXJhY3RlcmlzdGljKGNoYXJhY3RlcmlzdGljKTtcbi8vICAgICAvLyByZXR1cm4gc2VydmljZS5nZXRDaGFyYWN0ZXJpc3RpY3MoKTtcbi8vICAgfSlcbi8vICAgLnRoZW4oY2hhcmFjdGVyaXN0aWNzID0+IHtcbi8vICAgICAvLyBjb25zb2xlLmxvZygnPiBDaGFyYWN0ZXJpc3RpY3M6ICcgK1xuLy8gICAgIC8vICAgY2hhcmFjdGVyaXN0aWNzLm1hcChjID0+IGMudXVpZCkuam9pbignXFxuJyArICcgJy5yZXBlYXQoMTkpKSk7XG4vL1xuLy8gICAgIHJldHVybiBjaGFyYWN0ZXJpc3RpY3NbMF0ucmVhZFZhbHVlKCk7XG4vLyAgIH0pXG4vLyAgIC50aGVuKHZhbHVlID0+IHtcbi8vICAgICBjb25zb2xlLmxvZygnQmF0dGVyeSBwZXJjZW50YWdlIGlzICcgKyB2YWx1ZS5nZXRVaW50OCgwKSk7XG4vLyAgIH0pXG4vLyAgIC5jYXRjaChlcnJvciA9PiB7XG4vLyAgICAgY29uc29sZS5sb2coJ0FyZ2ghICcgKyBlcnJvcik7XG4vLyAgIH0pO1xuLy8gfSk7XG5cbm9rQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICBjb25zb2xlLmxvZygncmVhZDogJyArIGNoYXJhY3RlcmlzdGljKTtcbiAgYmx1ZS5nZXRWYWx1ZShjaGFyYWN0ZXJpc3RpYylcbiAgICAudGhlbih2YWx1ZSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgfSk7XG4gIC8vIGNvbnNvbGUubG9nKCd3cml0ZTogMDI2NjgzZGEtN2Y4Yi0xMWU2LWFlMjItNTZiNmI2NDk5NjExJyk7XG4gIC8vIGJsdWUud3JpdGVWYWx1ZSgnMDI2NjgzZGEtN2Y4Yi0xMWU2LWFlMjItNTZiNmI2NDk5NjExJywgJ29rJylcbiAgLy8gICAudGhlbih3cml0ZVN1Y2Nlc3MgPT4ge1xuICAvLyAgICAgY29uc29sZS5sb2cod3JpdGVTdWNjZXNzKTtcbiAgLy8gICB9KVxuICAvLyAgIC5jYXRjaChlcnJvciA9PiB7XG4gIC8vICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gIC8vICAgfSk7XG59KTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJiNTVtV0VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9mYWtlXzg1ZjgzYTM5LmpzXCIsXCIvXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYjU1bVdFXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MlxuXG4vKipcbiAqIElmIGBCdWZmZXIuX3VzZVR5cGVkQXJyYXlzYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKGNvbXBhdGlibGUgZG93biB0byBJRTYpXG4gKi9cbkJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgaWYgYnJvd3NlciBzdXBwb3J0cyBUeXBlZCBBcnJheXMuIFN1cHBvcnRlZCBicm93c2VycyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLFxuICAvLyBDaHJvbWUgNyssIFNhZmFyaSA1LjErLCBPcGVyYSAxMS42KywgaU9TIDQuMisuIElmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYWRkaW5nXG4gIC8vIHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcywgdGhlbiB0aGF0J3MgdGhlIHNhbWUgYXMgbm8gYFVpbnQ4QXJyYXlgIHN1cHBvcnRcbiAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gYWRkIGFsbCB0aGUgbm9kZSBCdWZmZXIgQVBJIG1ldGhvZHMuIFRoaXMgaXMgYW4gaXNzdWVcbiAgLy8gaW4gRmlyZWZveCA0LTI5LiBOb3cgZml4ZWQ6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOFxuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiZcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAvLyBDaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gV29ya2Fyb3VuZDogbm9kZSdzIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgc3RyaW5nc1xuICAvLyB3aGlsZSBiYXNlNjQtanMgZG9lcyBub3QuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcgJiYgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzdWJqZWN0ID0gc3RyaW5ndHJpbShzdWJqZWN0KVxuICAgIHdoaWxlIChzdWJqZWN0Lmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0ICsgJz0nXG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0KVxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QubGVuZ3RoKSAvLyBhc3N1bWUgdGhhdCBvYmplY3QgaXMgYXJyYXktbGlrZVxuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgYXJyYXkgb3Igc3RyaW5nLicpXG5cbiAgdmFyIGJ1ZlxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgICBlbHNlXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3RbaV1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgIW5vWmVybykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuLy8gU1RBVElDIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPT0gbnVsbCAmJiBiICE9PSB1bmRlZmluZWQgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoIC8gMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGFzc2VydChpc0FycmF5KGxpc3QpLCAnVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdCwgW3RvdGFsTGVuZ3RoXSlcXG4nICtcbiAgICAgICdsaXN0IHNob3VsZCBiZSBhbiBBcnJheS4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBCVUZGRVIgSU5TVEFOQ0UgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gX2hleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgYXNzZXJ0KHN0ckxlbiAlIDIgPT09IDAsICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBhc3NlcnQoIWlzTmFOKGJ5dGUpLCAnSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMlxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBfdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2FzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2JpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIF9hc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gX2hleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IF91dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gX2FzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IF9iaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gX2Jhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBfdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcbiAgc3RhcnQgPSBOdW1iZXIoc3RhcnQpIHx8IDBcbiAgZW5kID0gKGVuZCAhPT0gdW5kZWZpbmVkKVxuICAgID8gTnVtYmVyKGVuZClcbiAgICA6IGVuZCA9IHNlbGYubGVuZ3RoXG5cbiAgLy8gRmFzdHBhdGggZW1wdHkgc3RyaW5nc1xuICBpZiAoZW5kID09PSBzdGFydClcbiAgICByZXR1cm4gJydcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gX2hleFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IF91dGY4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gX2FzY2lpU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IF9iaW5hcnlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gX2Jhc2U2NFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBfdXRmMTZsZVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGFzc2VydCh0YXJnZXRfc3RhcnQgPj0gMCAmJiB0YXJnZXRfc3RhcnQgPCB0YXJnZXQubGVuZ3RoLFxuICAgICAgJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSBzb3VyY2UubGVuZ3RoLCAnc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAgfHwgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIF9hc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gX2JpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIF9hc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gX2hleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gX3V0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSsxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSBjbGFtcChzdGFydCwgbGVuLCAwKVxuICBlbmQgPSBjbGFtcChlbmQsIGxlbiwgbGVuKVxuXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgdmFyIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmXG4gIH1cbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDJdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgICB2YWwgfD0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApXG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMV0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMl0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAzXVxuICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0XSA8PCAyNCA+Pj4gMClcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICB2YXIgbmVnID0gdGhpc1tvZmZzZXRdICYgMHg4MFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQxNihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MzIoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRmxvYXQgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWREb3VibGUgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAgICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB0aGlzLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB0aGlzLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQxNihidWYsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQzMihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MzIoYnVmLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApXG4gIH1cblxuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpLCAndmFsdWUgaXMgbm90IGEgbnVtYmVyJylcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5sZW5ndGgsICdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSB0aGlzLmxlbmd0aCwgJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHRoaXNbaV0gPSB2YWx1ZVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCA9IFtdXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpc1tpXSlcbiAgICBpZiAoaSA9PT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPidcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpXG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbmZ1bmN0aW9uIGNsYW1wIChpbmRleCwgbGVuLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHJldHVybiBkZWZhdWx0VmFsdWVcbiAgaW5kZXggPSB+fmluZGV4OyAgLy8gQ29lcmNlIHRvIGludGVnZXIuXG4gIGlmIChpbmRleCA+PSBsZW4pIHJldHVybiBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICBpbmRleCArPSBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBjb2VyY2UgKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpXG4gIHJldHVybiBsZW5ndGggPCAwID8gMCA6IGxlbmd0aFxufVxuXG5mdW5jdGlvbiBpc0FycmF5IChzdWJqZWN0KSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoc3ViamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgfSkoc3ViamVjdClcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50ICh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA+PSAwLCAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmc2ludCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodGVzdCwgbWVzc2FnZSkge1xuICBpZiAoIXRlc3QpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdGYWlsZWQgYXNzZXJ0aW9uJylcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJiNTVtV0VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJiNTVtV0VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYjU1bVdFXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvaWVlZTc1NFwiKSJdfQ==\n","/*!\n *\n *  Web Starter Kit\n *  Copyright 2015 Google Inc. All rights reserved.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *    https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License\n *\n */\n/* eslint-env browser */\n(function() {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  var isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n      // [::1] is the IPv6 localhost address.\n      window.location.hostname === '[::1]' ||\n      // 127.0.0.1/8 is considered localhost for IPv4.\n      window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n      )\n    );\n\n  if ('serviceWorker' in navigator &&\n      (window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js')\n    .then(function(registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function() {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {\n          // The updatefound event implies that registration.installing is set:\n          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n          var installingWorker = registration.installing;\n\n          installingWorker.onstatechange = function() {\n            switch (installingWorker.state) {\n              case 'installed':\n                // At this point, the old content will have been purged and the\n                // fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in the page's interface.\n                break;\n\n              case 'redundant':\n                throw new Error('The installing ' +\n                                'service worker became redundant.');\n\n              default:\n                // Ignore\n            }\n          };\n        }\n      };\n    }).catch(function(e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nclass PosterDevice {\n\n  constructor() {\n    this.device = null;\n    this.onDisconnected = this.onDisconnected.bind(this);\n  }\n\n  request() {\n    let options = {\n      filters: [{\n        name: 'MyDevice'\n      }],\n      optionalServices: [0xFF02]\n    };\n    return navigator.bluetooth.requestDevice(options)\n    .then(device => {\n      this.device = device;\n      this.device.addEventListener('gattserverdisconnected', this.onDisconnected);\n      return device;\n    });\n  }\n\n  connect() {\n    if (this.device) {\n      return this.device.gatt.connect();\n    }\n    return Promise.reject('Device is not connected.');\n  }\n\n  writeColor(data) {\n    return this.device.gatt.getPrimaryService(0xFF02)\n    .then(service => service.getCharacteristic(0xFFFC))\n    .then(characteristic => characteristic.writeValue(data));\n  }\n\n  disconnect() {\n    if (this.device) {\n      return this.device.gatt.disconnect();\n    }\n    return Promise.reject('Device is not connected.');\n  }\n\n  onDisconnected() {\n    console.log('Device is disconnected.');\n  }\n}\n\nconst posterDevice = new PosterDevice();\nmodule.exports = posterDevice;\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/app/device.js\",\"/app\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n// const BluetoothDevice = require('web-bluetooth');\n// const stateManager = require('./app/state.js');\nconst posterDevice = require('./app/device.js');\n\n// const service = '1ecce4f2-7f9e-11e6-ae22-56b6b6499611';\nconst characteristic = '488d7950-7f9e-11e6-ae22-56b6b6499611';\n\n// const filter = {\n//   name: 'MyDevice',\n//   service: [service]\n// };\nlet blue;\n\nconst connectButton = document.getElementById('js-connect');\n// const disconnectButton = document.getElementById('js-disconnect');\n\nconst okButton = document.getElementById('js-ok');\n\n// connectButton.addEventListener('click', () => {\n//   connectButton.disabled = true;\n//   stateManager.change('connecting');\n//\n//   blue = new BluetoothDevice(filter);\n//   blue.connect()\n//     .then(device => {\n//       console.log(device);\n//       stateManager.change('connected');\n//       connectButton.disabled = false;\n//     })\n//     .catch(error => {\n//       console.log(error);\n//       stateManager.change('init');\n//       connectButton.disabled = false;\n//     });\n// });\n//\n// disconnectButton.addEventListener('click', () => {\n//   if (blue.disconnect()) {\n//     stateManager.change('init');\n//   } else {\n//     console.log('error while disconnect');\n//   }\n// });\n\nconnectButton.addEventListener('click', () => {\n  posterDevice.request()\n  .then(() => posterDevice.connect())\n  .then(() => {\n    posterDevice.writeColor('001122');\n  })\n  .catch(error => {\n    console.log(error);\n  });\n});\n// connectButton.addEventListener('click', () => {\n//   console.log('Requesting Bluetooth Device...');\n//   navigator.bluetooth.requestDevice({\n//     filters: [{services: [service]}]\n//   })\n//   .then(device => {\n//     console.log('Connecting to GATT Server...');\n//     return device.gatt.connect();\n//   })\n//   .then(server => {\n//     console.log('Getting Service...');\n//     return server.getPrimaryService(service);\n//   })\n//   .then(service => {\n//     console.log('Getting Characteristics...');\n//     // if (characteristic) {\n//     //   // Get all characteristics that match this UUID.\n//     //   return service.getCharacteristics(characteristic);\n//     // }\n//     // Get all characteristics.\n//     return service.getCharacteristic(characteristic);\n//     // return service.getCharacteristics();\n//   })\n//   .then(characteristics => {\n//     // console.log('> Characteristics: ' +\n//     //   characteristics.map(c => c.uuid).join('\\n' + ' '.repeat(19)));\n//\n//     return characteristics[0].readValue();\n//   })\n//   .then(value => {\n//     console.log('Battery percentage is ' + value.getUint8(0));\n//   })\n//   .catch(error => {\n//     console.log('Argh! ' + error);\n//   });\n// });\n\nokButton.addEventListener('click', () => {\n  console.log('read: ' + characteristic);\n  blue.getValue(characteristic)\n    .then(value => {\n      console.log(value);\n    });\n  // console.log('write: 026683da-7f8b-11e6-ae22-56b6b6499611');\n  // blue.writeValue('026683da-7f8b-11e6-ae22-56b6b6499611', 'ok')\n  //   .then(writeSuccess => {\n  //     console.log(writeSuccess);\n  //   })\n  //   .catch(error => {\n  //     console.log(error);\n  //   });\n});\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/fake_85f83a39.js\",\"/\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js\",\"/../../node_modules/gulp-browserify/node_modules/base64-js/lib\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = Buffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192\n\n/**\n * If `Buffer._useTypedArrays`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (compatible down to IE6)\n */\nBuffer._useTypedArrays = (function () {\n  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,\n  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding\n  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support\n  // because we need to be able to add all the node Buffer API methods. This is an issue\n  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438\n  try {\n    var buf = new ArrayBuffer(0)\n    var arr = new Uint8Array(buf)\n    arr.foo = function () { return 42 }\n    return 42 === arr.foo() &&\n        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`\n  } catch (e) {\n    return false\n  }\n})()\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (subject, encoding, noZero) {\n  if (!(this instanceof Buffer))\n    return new Buffer(subject, encoding, noZero)\n\n  var type = typeof subject\n\n  // Workaround: node's base64 implementation allows for non-padded strings\n  // while base64-js does not.\n  if (encoding === 'base64' && type === 'string') {\n    subject = stringtrim(subject)\n    while (subject.length % 4 !== 0) {\n      subject = subject + '='\n    }\n  }\n\n  // Find the length\n  var length\n  if (type === 'number')\n    length = coerce(subject)\n  else if (type === 'string')\n    length = Buffer.byteLength(subject, encoding)\n  else if (type === 'object')\n    length = coerce(subject.length) // assume that object is array-like\n  else\n    throw new Error('First argument needs to be a number, array or string.')\n\n  var buf\n  if (Buffer._useTypedArrays) {\n    // Preferred: Return an augmented `Uint8Array` instance for best performance\n    buf = Buffer._augment(new Uint8Array(length))\n  } else {\n    // Fallback: Return THIS instance of Buffer (created by `new`)\n    buf = this\n    buf.length = length\n    buf._isBuffer = true\n  }\n\n  var i\n  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {\n    // Speed optimization -- use set if we're copying from a typed array\n    buf._set(subject)\n  } else if (isArrayish(subject)) {\n    // Treat array-ish objects as a byte array\n    for (i = 0; i < length; i++) {\n      if (Buffer.isBuffer(subject))\n        buf[i] = subject.readUInt8(i)\n      else\n        buf[i] = subject[i]\n    }\n  } else if (type === 'string') {\n    buf.write(subject, 0, encoding)\n  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {\n    for (i = 0; i < length; i++) {\n      buf[i] = 0\n    }\n  }\n\n  return buf\n}\n\n// STATIC METHODS\n// ==============\n\nBuffer.isEncoding = function (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.isBuffer = function (b) {\n  return !!(b !== null && b !== undefined && b._isBuffer)\n}\n\nBuffer.byteLength = function (str, encoding) {\n  var ret\n  str = str + ''\n  switch (encoding || 'utf8') {\n    case 'hex':\n      ret = str.length / 2\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8ToBytes(str).length\n      break\n    case 'ascii':\n    case 'binary':\n    case 'raw':\n      ret = str.length\n      break\n    case 'base64':\n      ret = base64ToBytes(str).length\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = str.length * 2\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.concat = function (list, totalLength) {\n  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\\n' +\n      'list should be an Array.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  } else if (list.length === 1) {\n    return list[0]\n  }\n\n  var i\n  if (typeof totalLength !== 'number') {\n    totalLength = 0\n    for (i = 0; i < list.length; i++) {\n      totalLength += list[i].length\n    }\n  }\n\n  var buf = new Buffer(totalLength)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\n// BUFFER INSTANCE METHODS\n// =======================\n\nfunction _hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  assert(strLen % 2 === 0, 'Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16)\n    assert(!isNaN(byte), 'Invalid hex string')\n    buf[offset + i] = byte\n  }\n  Buffer._charsWritten = i * 2\n  return i\n}\n\nfunction _utf8Write (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(utf8ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _asciiWrite (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(asciiToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _binaryWrite (buf, string, offset, length) {\n  return _asciiWrite(buf, string, offset, length)\n}\n\nfunction _base64Write (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(base64ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _utf16leWrite (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(utf16leToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nBuffer.prototype.write = function (string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length\n      length = undefined\n    }\n  } else {  // legacy\n    var swap = encoding\n    encoding = offset\n    offset = length\n    length = swap\n  }\n\n  offset = Number(offset) || 0\n  var remaining = this.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase()\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = _hexWrite(this, string, offset, length)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = _utf8Write(this, string, offset, length)\n      break\n    case 'ascii':\n      ret = _asciiWrite(this, string, offset, length)\n      break\n    case 'binary':\n      ret = _binaryWrite(this, string, offset, length)\n      break\n    case 'base64':\n      ret = _base64Write(this, string, offset, length)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = _utf16leWrite(this, string, offset, length)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toString = function (encoding, start, end) {\n  var self = this\n\n  encoding = String(encoding || 'utf8').toLowerCase()\n  start = Number(start) || 0\n  end = (end !== undefined)\n    ? Number(end)\n    : end = self.length\n\n  // Fastpath empty strings\n  if (end === start)\n    return ''\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = _hexSlice(self, start, end)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = _utf8Slice(self, start, end)\n      break\n    case 'ascii':\n      ret = _asciiSlice(self, start, end)\n      break\n    case 'binary':\n      ret = _binarySlice(self, start, end)\n      break\n    case 'base64':\n      ret = _base64Slice(self, start, end)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = _utf16leSlice(self, start, end)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toJSON = function () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function (target, target_start, start, end) {\n  var source = this\n\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (!target_start) target_start = 0\n\n  // Copy 0 bytes; we're done\n  if (end === start) return\n  if (target.length === 0 || source.length === 0) return\n\n  // Fatal error conditions\n  assert(end >= start, 'sourceEnd < sourceStart')\n  assert(target_start >= 0 && target_start < target.length,\n      'targetStart out of bounds')\n  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')\n  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length)\n    end = this.length\n  if (target.length - target_start < end - start)\n    end = target.length - target_start + start\n\n  var len = end - start\n\n  if (len < 100 || !Buffer._useTypedArrays) {\n    for (var i = 0; i < len; i++)\n      target[i + target_start] = this[i + start]\n  } else {\n    target._set(this.subarray(start, start + len), target_start)\n  }\n}\n\nfunction _base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction _utf8Slice (buf, start, end) {\n  var res = ''\n  var tmp = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    if (buf[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])\n      tmp = ''\n    } else {\n      tmp += '%' + buf[i].toString(16)\n    }\n  }\n\n  return res + decodeUtf8Char(tmp)\n}\n\nfunction _asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++)\n    ret += String.fromCharCode(buf[i])\n  return ret\n}\n\nfunction _binarySlice (buf, start, end) {\n  return _asciiSlice(buf, start, end)\n}\n\nfunction _hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction _utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function (start, end) {\n  var len = this.length\n  start = clamp(start, len, 0)\n  end = clamp(end, len, len)\n\n  if (Buffer._useTypedArrays) {\n    return Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    var newBuf = new Buffer(sliceLen, undefined, true)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n    return newBuf\n  }\n}\n\n// `get` will be removed in Node 0.13+\nBuffer.prototype.get = function (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` will be removed in Node 0.13+\nBuffer.prototype.set = function (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nBuffer.prototype.readUInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  return this[offset]\n}\n\nfunction _readUInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    val = buf[offset]\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n  } else {\n    val = buf[offset] << 8\n    if (offset + 1 < len)\n      val |= buf[offset + 1]\n  }\n  return val\n}\n\nBuffer.prototype.readUInt16LE = function (offset, noAssert) {\n  return _readUInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt16BE = function (offset, noAssert) {\n  return _readUInt16(this, offset, false, noAssert)\n}\n\nfunction _readUInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    if (offset + 2 < len)\n      val = buf[offset + 2] << 16\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n    val |= buf[offset]\n    if (offset + 3 < len)\n      val = val + (buf[offset + 3] << 24 >>> 0)\n  } else {\n    if (offset + 1 < len)\n      val = buf[offset + 1] << 16\n    if (offset + 2 < len)\n      val |= buf[offset + 2] << 8\n    if (offset + 3 < len)\n      val |= buf[offset + 3]\n    val = val + (buf[offset] << 24 >>> 0)\n  }\n  return val\n}\n\nBuffer.prototype.readUInt32LE = function (offset, noAssert) {\n  return _readUInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt32BE = function (offset, noAssert) {\n  return _readUInt32(this, offset, false, noAssert)\n}\n\nBuffer.prototype.readInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null,\n        'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  var neg = this[offset] & 0x80\n  if (neg)\n    return (0xff - this[offset] + 1) * -1\n  else\n    return this[offset]\n}\n\nfunction _readInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = _readUInt16(buf, offset, littleEndian, true)\n  var neg = val & 0x8000\n  if (neg)\n    return (0xffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt16LE = function (offset, noAssert) {\n  return _readInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt16BE = function (offset, noAssert) {\n  return _readInt16(this, offset, false, noAssert)\n}\n\nfunction _readInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = _readUInt32(buf, offset, littleEndian, true)\n  var neg = val & 0x80000000\n  if (neg)\n    return (0xffffffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt32LE = function (offset, noAssert) {\n  return _readInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt32BE = function (offset, noAssert) {\n  return _readInt32(this, offset, false, noAssert)\n}\n\nfunction _readFloat (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 23, 4)\n}\n\nBuffer.prototype.readFloatLE = function (offset, noAssert) {\n  return _readFloat(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readFloatBE = function (offset, noAssert) {\n  return _readFloat(this, offset, false, noAssert)\n}\n\nfunction _readDouble (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 52, 8)\n}\n\nBuffer.prototype.readDoubleLE = function (offset, noAssert) {\n  return _readDouble(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readDoubleBE = function (offset, noAssert) {\n  return _readDouble(this, offset, false, noAssert)\n}\n\nBuffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xff)\n  }\n\n  if (offset >= this.length) return\n\n  this[offset] = value\n}\n\nfunction _writeUInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {\n    buf[offset + i] =\n        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n            (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n  _writeUInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n  _writeUInt16(this, value, offset, false, noAssert)\n}\n\nfunction _writeUInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffffffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {\n    buf[offset + i] =\n        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n  _writeUInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n  _writeUInt32(this, value, offset, false, noAssert)\n}\n\nBuffer.prototype.writeInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7f, -0x80)\n  }\n\n  if (offset >= this.length)\n    return\n\n  if (value >= 0)\n    this.writeUInt8(value, offset, noAssert)\n  else\n    this.writeUInt8(0xff + value + 1, offset, noAssert)\n}\n\nfunction _writeInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fff, -0x8000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    _writeUInt16(buf, value, offset, littleEndian, noAssert)\n  else\n    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)\n}\n\nBuffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n  _writeInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n  _writeInt16(this, value, offset, false, noAssert)\n}\n\nfunction _writeInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fffffff, -0x80000000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    _writeUInt32(buf, value, offset, littleEndian, noAssert)\n  else\n    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)\n}\n\nBuffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n  _writeInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n  _writeInt32(this, value, offset, false, noAssert)\n}\n\nfunction _writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n}\n\nBuffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n  _writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n  _writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction _writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 7 < buf.length,\n        'Trying to write beyond buffer length')\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n}\n\nBuffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n  _writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n  _writeDouble(this, value, offset, false, noAssert)\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (typeof value === 'string') {\n    value = value.charCodeAt(0)\n  }\n\n  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')\n  assert(end >= start, 'end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  assert(start >= 0 && start < this.length, 'start out of bounds')\n  assert(end >= 0 && end <= this.length, 'end out of bounds')\n\n  for (var i = start; i < end; i++) {\n    this[i] = value\n  }\n}\n\nBuffer.prototype.inspect = function () {\n  var out = []\n  var len = this.length\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i])\n    if (i === exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...'\n      break\n    }\n  }\n  return '<Buffer ' + out.join(' ') + '>'\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer._useTypedArrays) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1)\n        buf[i] = this[i]\n      return buf.buffer\n    }\n  } else {\n    throw new Error('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function (arr) {\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array get/set methods before overwriting\n  arr._get = arr.get\n  arr._set = arr.set\n\n  // deprecated, will be removed in node 0.13+\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\n// slice(start, end)\nfunction clamp (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index;  // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\n\nfunction coerce (length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it's fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length)\n  return length < 0 ? 0 : length\n}\n\nfunction isArray (subject) {\n  return (Array.isArray || function (subject) {\n    return Object.prototype.toString.call(subject) === '[object Array]'\n  })(subject)\n}\n\nfunction isArrayish (subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n      subject && typeof subject === 'object' &&\n      typeof subject.length === 'number'\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    var b = str.charCodeAt(i)\n    if (b <= 0x7F)\n      byteArray.push(str.charCodeAt(i))\n    else {\n      var start = i\n      if (b >= 0xD800 && b <= 0xDFFF) i++\n      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16))\n    }\n  }\n  return byteArray\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(str)\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  var pos\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length))\n      break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction decodeUtf8Char (str) {\n  try {\n    return decodeURIComponent(str)\n  } catch (err) {\n    return String.fromCharCode(0xFFFD) // UTF 8 invalid char\n  }\n}\n\n/*\n * We have to make sure that the value is a valid integer. This means that it\n * is non-negative. It has no fractional component and that it does not\n * exceed the maximum allowed value.\n */\nfunction verifuint (value, max) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value >= 0, 'specified a negative value for writing an unsigned value')\n  assert(value <= max, 'value is larger than maximum value for type')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifsint (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifIEEE754 (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n}\n\nfunction assert (test, message) {\n  if (!test) throw new Error(message || 'Failed assertion')\n}\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/gulp-browserify/node_modules/buffer/index.js\",\"/../../node_modules/gulp-browserify/node_modules/buffer\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/gulp-browserify/node_modules/process/browser.js\",\"/../../node_modules/gulp-browserify/node_modules/process\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n}).call(this,require(\"b55mWE\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../../node_modules/ieee754/index.js\",\"/../../node_modules/ieee754\")","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})"],"sourceRoot":"/source/"}